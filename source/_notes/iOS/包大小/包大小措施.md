找时间翻译下：

[iOS App Security: An Introduction to Objective-C Metadata & Symbols in Swift & Objective-C Apps (Part 1 of 2)](http://guardsquare.com/zh-hans/blog/ios-app-security-introduction-objective-c-metadata-symbols-swift-objective-c-apps-part-1-2)

[iOS App Security: Protecting SDK Symbols & Preventing Information Leakage (Part 2 of 2)](https://www.guardsquare.com/en/blog/ios-app-security-protecting-sdk-symbols-preventing-information-leakage-part-2-2)







京东商城iOS App瘦身实践

https://mp.weixin.qq.com/s/xzlFQJ2b-rrw5QIszSLXXQ



可以从 assetutil 输出结果的 ThinningParameters 字段中，找到 thin 参数：

从越狱机上获取 car，然后通过 assetutil 获取对应机型的 thin 参数 或者

通过 adhoc thin 对应机型的 ipa ，然后 assetutil 查看 car 的 thin 参数

更新： adhoc thin中 Packaging.log 也会使用 assetutil ，直接看这里面的参数即可



assetutil 的参数会根据支持的最小版本做调整



最低支持 13.0

Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/usr/bin/assetutil --scale 3 --idiom phone --subtype 2436 --display-gamut P3 --memory 3 --graphicsclass APPLE5 --graphicsclassfallbacks APPLE4:APPLE3:APPLE3v1:APPLE2:APPLE1:GLES2,0 --hostedidioms car --deployment-target 13.0 --output\=/var/folders/50/3f5nr6h10h1csn8byghy30q80000gn/T/IPATool.sEIIbpr/055a1b27c23b3d9dc4acb5c68743e32aef293098/Payload/Assets.app/Assets.car /var/folders/50/3f5nr6h10h1csn8byghy30q80000gn/T/XcodeDistPipeline.\~\~\~oIBGzR/Root/Payload/Assets.app/Assets.car



最低支持 8.0

/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/usr/bin/assetutil --scale 3 --idiom phone --subtype 570 --display-gamut sRGB --memory 1 --graphicsclass MTL2,2 --graphicsclassfallbacks MTL1,2:GLES2,0 --hostedidioms car,watch --output\=/var/folders/50/3f5nr6h10h1csn8byghy30q80000gn/T/IPATool.6Gzs1kA/80732b35afde0f4c7002c75fe99c800e11d5f0ed/Payload/Assets.app/Assets.car /var/folders/50/3f5nr6h10h1csn8byghy30q80000gn/T/XcodeDistPipeline.\~\~\~mI2hHB/Root/Payload/Assets.app/Assets.car



Code Size Performance Guidelines

https://developer.apple.com/library/archive/documentation/Performance/Conceptual/CodeFootprint/CodeFootprint.html#//apple_ref/doc/uid/10000149-SW1



Managing Code Size

https://developer.apple.com/library/archive/documentation/Performance/Conceptual/CodeFootprint/Articles/CompilerOptions.html



GMTC 上分享滴滴出行 iOS 端瘦身实践的 Slides

https://www.jianshu.com/p/6422a6861562



Reducing the size of my App

https://developer.apple.com/library/archive/qa/qa1795/_index.html



iOS安装包瘦身指南

https://www.zoomfeng.com/blog/ipa-size-thin.html



iOS微信安装包瘦身

http://www.cocoachina.com/articles/14562



干货|今日头条iOS端安装包大小优化—思路与实践

https://techblog.toutiao.com/2018/06/04/gan-huo-jin-ri-tou-tiao-iosduan-an-zhuang-bao-da-xiao-you-hua-si-lu-yu-shi-jian/



iOS 瘦身之删除 FrameWork 中无用 mach-O 文件

https://www.infoq.cn/article/ios-thinning-delete-unnecessary-mach-o



iOS 安装包大小优化

https://www.jianshu.com/p/49ba62b36d0d



Xcode中和symbols有关的几个设置

https://www.jianshu.com/p/11710e7ab661



开启Link Time Optimization(LTO)后到底有什么优化

https://www.jianshu.com/p/58fef052291a



Mach-O 可执行文件

https://objccn.io/issue-6-3/



基于 clang 插件的一种 iOS 包大小瘦身方案

https://www.infoq.cn/article/clang-plugin-ios-app-size-reducing



iOS 安装包瘦身（下篇）

https://sq.163yun.com/blog/article/200384401846304768



如何使用 Clang Plugin 找到项目中的无用代码（Part 1）

https://blog.gocy.tech/2017/09/12/DetectingUselessCodeWithClang-p1/



深入理解Macho文件（二）- 消失的__**OBJC****段与新生的**__DATA段

https://satanwoo.github.io/2017/06/29/Macho-2/



xcrun size -x -m -l 查看目标文件各个段大小



local symbol binding 

global symbol binding

https://binarydodo.wordpress.com/2016/05/12/symbol-binding-types-in-elf-and-their-effect-on-linking-of-relocatable-files/



xcrun nm 和 nm 出来的结果不一样

oc 产生的 local symbol：

\- s    oc 会针对每个成员变量创建一个静态全局变量，放在data section 中 (小数据优化)

\- b    未初始化静态/全局变量 (bss)

\- T    external 的全局非静态函数 

\- t	   non-external 的全局非静态函数（__**attribute**__(( visibility("hidden") ))修饰的函数就是 non-external 的），符号表中有这些函数符号信息，但实际在链接重定向之后就不需要这些信息了



即使用 __**attribute**__(( visibility("hidden") ) 修饰成 non-external 的，函数还是全局的，只是符号表里的标志不一样，如果有相同的符号还是会报符号重定义错误，所以 non-external 实际表示的是 was a private external，不允许它们在库中被导出，但是可以在库中的源文件之间共享，隐藏的符号还会被留在符号表中用于库内部符号绑定重定向，但是会被标记成私有的。



所有的信息还是符号表里面的



oc 的方法函数地址等信息在编译链接之后，都保存在对应的 _DATA 段相关 section 里面了，所以 oc 方法转换成的函数都是 no-external 的，编译链接之后可以直接清除掉（还是因为 OC 方法的访问方式不是直接走函数指针，而是消息机制，通过名称来找对应的 imp，而不是直接将函数地址写进 text 段中，所以 OC 方法的符号信息可以不导出，链接时其他目标文件引用到当前目标文件的对应方法时，不需要通过符号表去进行符号绑定和重定位，而是在运行时走 objc_msgSend ），方法调用不会产生函数的 undefined symbol ，只会针对目标类生成 undefined symbol 。



一个OC类编译链接之后 nm -m 的结果

\- OC 类 ，external 的（实体在 __**DATA.**__objc_data 段中）

\- OC 成员变量，external 或 non-external 的 ，看声明的地方，在 @implementation 里面就是 non-external 的，在@interface相反（实体在 __**DATA.**__objc_ivar 段中）

\- OC 方法，non-external 的 （实体在 __**TEXT.**__text 段中）



strip type 才是真正裁剪配置

export file 只是变更符号表中符号是否私有的标志



flutter

https://juejin.im/post/5bd2ac975188252928653585



安卓 so 配置

https://wiki.corp.kuaishou.com/pages/viewpage.action?pageId=232991417



c++ no exception

http://gcc.gnu.org/onlinedocs/gcc-4.7.0/libstdc++/manual/manual/using_exceptions.html



iOS可执行文件瘦身方法

https://blog.cnbang.net/tech/2544/



如何在嵌入式C++开发中缩减代码尺寸

http://kuangqi.me/embedded/reduce-the-code-size-in-embedded-cpp/



exports file 符号过滤

https://developer.apple.com/library/archive/documentation/Performance/Conceptual/CodeFootprint/Articles/ReducingExports.html

https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Tasks/ExportingInterfaces.html



安卓的编译配置

https://wiki.corp.kuaishou.com/pages/viewpage.action?pageId=232991417



1.

这个最有用的一个选项是Deployment Postprocessing和Strip Linked Product，两个需要都设置为YES才有用 (每个 Pod 工程都需要设置，这块要用脚本)（更新，cocoapods 集成的 pod不用，否则 dsym 里面符号会缺失，某个 mr 说的）



2.

去掉异常支持，Enable C++ Exceptions和Enable Objective-C Exceptions设为NO，并且Other C Flags添加-fno-exceptions，可执行文件减少了27M，其中__**gcc_except_tab****段减少了****17.3M****，**__text减少了9.7M，效果特别明显。可以对某些文件单独支持异常，编译选项加上-fexceptions即可。但有个问题，假如ABC三个文件，AC文件支持了异常，B不支持，如果C抛了异常，在模拟器下A还是能捕获异常不至于Crash，但真机下捕获不了（有知道原因可以在下面留言：）。去掉异常后，Appstore后续几个版本Crash率没有明显上升。个人认为关键路径支持异常处理就好，像启动时NSCoder读取setting配置文件得要支持捕获异常，等等





https://clang.llvm.org/docs/ClangCommandLineReference.html#cmdoption-clang-fobjc-exceptions



-fobjc-exceptions, -fno-objc-exceptions

Enable Objective-C exceptions



-fcxx-exceptions, -fno-cxx-exceptions

Enable C++ exceptions



ARC exception support can be enabled with -fobjc-arc-exceptions or disabled with -fno-objc-arc-exceptions. By default, it is disabled in Objective-C but enabled in Objective-C++. (oc try catch 会造成内存泄漏，需要开启 -fobjc-arc-exceptions)

https://stackoverflow.com/questions/4648952/objective-c-exceptions



C++异常机制的实现方式和开销分析

[http://baiy.cn/doc/cpp/inside_exception.htm#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BC%80%E9%94%80%E5%88%86%E6%9E%90](http://baiy.cn/doc/cpp/inside_exception.htm#异常处理机制的开销分析)



去除 objc exception 后

0x07119308	0x0027A190	__TEXT	__gcc_except_tab (2597264, 2.48M)





0x071412E8	0x002A5AD4	__TEXT	__gcc_except_tab

0x00007A40	0x063A17B0	__TEXT	__text





正式方案：所有组件默认都不 no exception ，针对个别组件和文件特殊处理

针对组件：PodfileConfigGloabl 做白名单

针对文件：各组件 podspec 



s.compiler_flags = {'Classes/Something.m' => '-fobjc-exceptions'}



3.

protobuf 代码精简



\4. 

无用类、方法



\5. 

ABTest 下线已全量的Key

大资源上CDN

无用资源删减

重复资源统一 -> 扫描相似图片











link-time optimization



strip type = no global symbol



all 动态库需要符号，无法 all



如果是静态库，静态链接在编译链接阶段就会进行符号绑定和重定向，可执行文件对静态库符号的引用已经替换成了相对地址，所以可以把这些静态库对外的不好的 strip 掉



如果是动态库，符号绑定和重定向就在启动时进行，动态链接需要动态库暴露符号绑定和重定向信息，这些必要的符号就无法 strip 掉，从而导致包增大



no global symbol 可以把 local binding 的符号和 debug 符号去掉



Concerning the reduction of the binary file size, this is how my release configuration file looks like concerning the stripping of the binary and I guess that's how most developers do it:



DEPLOYMENT_POSTPROCESSING = YES

COPY_PHASE_STRIP = NO (not necessary since my copied binaries are already stripped and codesigned)

STRIP_INSTALLED_PRODUCT = YES

STRIP_STYLE = all

SEPARATE_STRIP = YES

DEAD_CODE_STRIPPING = YES

GCC_GENERATE_DEBUGGING_SYMBOLS = NO

With these build settings, Xcode seems to be doing the same as running "strip" manually on the binary, at least from what the file size says.



I haven't found any other way to reduce the binary size even more yet. Note the "DEPLOYMENT_POSTPROCESSING" flag there - the binary size will be a lot bigger without it and for example all C functions will not be stripped.



DEPLOYMENT_POSTPROCESSING 在 archive 时会自动设置成 YES





strip type 为 all symbols 时，会把符号表整个裁掉，动态符号表不动，也就是那些 undef 的符号都在



OC 由于其动态特性，class 、方法和成员变量等产生的符号，不管是导入导出都会在符号表(C 函数导入符号会在动态符号表，而导出却在符号表中，这个有点想不通，和 elf 不一样) ，不会进入动态符号表，所以即使把符号表全部裁掉了，也不会影响实际运行。但是如果动态库里是 C 符号，外部又引用了这个符号，那么 strip 就会失败 （macho 好奇怪，导出函数并不会在动态符号表，而是在符号表，导致裁剪符号表时，把导出符号都裁掉了，我看 elf 文件就会把导出函数放到动态符号表中）



更新：macho 有个 Dynamic Loader Info 段，段里面有个Export Info ，这里面会指定导出符号，而这些导出符号实际值需要在符号表中获取



更新：macho 可执行文件可以执行 strip all symbol ，并且不会裁动态符号表中的 undef 符号，但是动态库执行 strip all symbol ，如果引用了其他库的符号，会报以下错误（貌似strip目标是动态库时，会把动态符号表也裁了）



all symbol 可能导致错误：

 symbols referenced by indirect symbol table entries that can't be stripped



https://lists.apple.com/archives/xcode-users/2016/Dec/msg00102.html



 According to the man page of strip command, they state: “For dynamic shared libraries, the maximum level of stripping is usually -x (to remove all non-global symbols).”



strip 有个 --strip-unneeded 可以关注下



--discard-all

  Remove non-global symbols.

--strip-unneeded 

 Remove all symbols that are not needed for relocation processing.

--strip-debug

 Remove debugging symbols only.

--strip-all

  Remove all symbols.





xcode 的 strip 和直接执行 strip 不一样

\1. Xcode的：/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/strip

\2. 直接执行的： /usr/local/opt/binutils/bin/strip



elf so 动态库，strip 不会裁剪 .dynsym ，只会裁剪 .symtab，看这里 https://www.technovelty.org/linux/stripping-shared-libraries.html



What symbol tables stay after a strip In ELF format?

https://reverseengineering.stackexchange.com/questions/2539/what-symbol-tables-stay-after-a-strip-in-elf-format





更新：貌似 macho 的导出符号也在动态符号表里面，只是 machoview 没展示出来？https://adrummond.net/posts/macho | dyld 中 class macho_dysymtab_command







Hazel 软件，自动划分文件夹中的文件





https://stackoverflow.com/questions/311882/what-do-statically-linked-and-dynamically-linked-mean



各机型支持设备情况

https://developer.apple.com/library/archive/documentation/DeviceInformation/Reference/iOSDeviceCompatibility/DeviceCompatibilityMatrix/DeviceCompatibilityMatrix.html
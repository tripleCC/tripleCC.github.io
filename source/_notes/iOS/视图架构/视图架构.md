

### 描述步骤

- 是什么— 职责划分
- 有什么好处—  易用性、代码量
- 有什么问题— VC耦合单测困难、业务堆积庞杂
- 如何解决— 拆分业务（P、VM）、改善数据交互（VM绑定）

### 具体解析

代码越少，问题越少

- Model，数据层（包括网络请求获取数据、数据库获取数据等都属于数据层面的事情-》**提供存储数据的接口**）
- View，展示层
- Controller/Presenter/ViewModel，Model 和 View 之间的胶水。View 触发变更动作时，它负责去修改相应的 Model；当 Model 的值发生变化时，它负责去更新对应的 View。



由于 C 内置了 V 容器，导致 C 和 V 高度耦合，也就难以对 C 进行单测，因为需要去mock V 的生命周期，所以我们要做的就是将 C 中可测试的业务拆分出来，和 V 解耦开， MVP 中的 P，MVVM 中的 VM 就是承载了 C 中拆分的这些业务

### iOS 中的 MVC

![](<https://dn-coding-net-production-pp.codehub.cn/8d779f6a-265b-43c3-90be-dc9997b9963d.png>)

View 和 Model 相互独立，只通过 Controller 建立数据联系。由一般不会把业务写在 View 和 Model 中，Controller 就成了业务承载者。C 相当于中介者。

一般工作流程：**View（界面）触发事件-》Controller（业务）处理了业务，触发数据更新-》不知道谁更新了 Model 的数据-》Model（带着数据）回到Controller-》Controller处理了业务，触发View 更新-》View更新数据**

在 iOS 里面，由于 Controller 需要管理 View 的整个生命周期（Controller 内置了一个 View），所以 Controller 和 View 很难做到相互独立。由于 View 主要负责将用户的操作行为抛给 Controller 去处理，而 Model 除了承载部分数据转换和业务逻辑工作，无法再塞更多东西了，Controller 往往成为所有东西的代理和数据源，甚至还有网络请求的发起和取消，以及更多业务。

由于 Controller 和 View 高度耦合，导致难以对 Controller 进行单元测试。

**实际上现在我们在 Controller 里面直接让 Model 配置 View 不符合苹果定义的 MVC** ：

```
var userCell = tableView.dequeueReusableCellWithIdentifier("identifier") as UserCell
userCell.configureWithUser(user)
```

不过严格遵守苹果 MVC，在 C 中配置 V 会导致 C 更重。

**MVC 各模块职责**：

- M
  - 给 C 提供数据
  - 给 C 存储数据提供接口
  - 提供经过抽象的业务基础组件，供 C 调度
- C
  - 管理 V 容器的生命周期
  - 负责生成所有 V 的实例，并放入 V 容器
  - 监听来自 V 与业务有关的事件，并完成的 Model 交互逻辑
- V
  - 响应与业务无关事件
  - 界面元素表达

问题：容易造成 V 臃肿

### MVP（接口）

![](<https://dn-coding-net-production-pp.codehub.cn/d8ad72b3-f150-4988-af6f-0db785c40793.png>)

MVP 中的 Controller 也属于 V，这里的 V 也可以表示 View 和 Controller。

P 负责 V 与 M 的交互，也就是一些业务逻辑从  V 拆到了 P 中，并且彻底切断了 View 和 Model 的联系。

P 和 V 基于**接口交互**，由 P 定义接口， V 实现接口，最终由 P 调用接口。

问题：需要写挺多胶水代码（实现协议）

### MVVM（绑定）

![](<https://dn-coding-net-production-pp.codehub.cn/1b8ff549-4fa4-489a-adf3-e8ba52e6bb96.png>)



**在 MVC 的基础上，把 C 拆出一个处理数据业务的 VM ，加上VM和V的数据与事件绑定，就是 MVVM。VM 能主动对 M 做更改，也能在 M 更新的时候调整自己，然后通过 V 和 VM 之间的绑定更新 V。**

MVVM ，和上图不太一致，严格来说应该是 MVMCV（**View <-> C <-> ViewModel <-> Model**）。

View 不宜直接持有 ViewModel ，所以需要通过 Controller ，对 View 和 ViewModel 进行绑定，当 View 产生数据后，通过绑定将数据传递给 ViewModel。

ReactiveCocoa 的绑定主要体现在 View -> ViewModel 这一方向数据流动上，能更好地体现 MVVM 的精髓，减少一些样板代码。

每个 View 仅对应一个 ViewModel。



### VIPER

![](<https://dn-coding-net-production-pp.codehub.cn/aaa8d85f-b66a-4bb2-a8f5-13fae704d3b1.png>)



### 资料

[iOS应用架构谈 view层的组织和调用方案](https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html)

[iOS 架构模式 - 简述 MVC, MVP, MVVM 和 VIPER (译)](<https://blog.coding.net/blog/ios-architecture-patterns>)

[MVVM With ReactiveCocoa](<http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/>)

[Overview of the ModelView – ViewModel (MVVM) pattern and data-binding](<https://russelleast.wordpress.com/2008/08/09/overview-of-the-modelview-viewmodel-mvvm-pattern-and-data-binding/>)
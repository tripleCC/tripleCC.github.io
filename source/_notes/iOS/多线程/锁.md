#####互斥锁/递归锁——NSLock/NSRecursiveLock

主动睡眠，主动让出时间片

可以用初始值为 1 的信号量实现

同一时刻，只能有一个线程访问资源

递归锁允许递归调用加锁

都用 pthread_mutex_lock 实现

#####读写锁 （共享、独占）

读锁允许多个线程同时读，写锁同一时刻只允许一个线程写

读 读 不阻塞

读 写 阻塞

写 写 阻塞

写 读 阻塞

#####空转锁(自旋锁)——OSSpinLock

死循环，如果锁保护代码执行时间长，不宜用自旋锁，耗费 CPU 时间片

同一时刻，只能有一个线程访问资源

```c
bool lock = false; // 一开始没有锁上，任何线程都可以申请锁  
do {  
    while(lock); // 如果 lock 为 true 就一直死循环，相当于申请锁 （需要原子操作）
    lock = true; // 挂上锁，这样别的线程就无法获得锁
        Critical section  // 锁保护代码
    lock = false; // 相当于释放锁，这样别的线程可以进入临界区
        Reminder section // 不需要锁保护的代码        
}
```

#####条件变量——NSCondition

主动睡眠，主动让出时间片

阻塞线程，等待数据就绪——生产消费者

需要配合互斥锁使用，保证数据安全

可被多个线程等待

#####信号量

主动睡眠，主动让出时间片

设置初始数值，访问资源减1，释放资源加1，大于0即不阻塞

允许多个线程访问资源

#### @synchronized

对象哈希值为key，递归锁为value的哈希表

### 资料

[pthread的各种同步机制](https://casatwy.com/pthreadde-ge-chong-tong-bu-ji-zhi.html)

[深入理解 iOS 中的锁](<https://bestswifter.com/ios-lock/>)
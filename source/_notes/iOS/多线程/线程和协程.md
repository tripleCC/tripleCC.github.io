[1Differences between a "coroutine" and a "thread"?](<https://stackoverflow.com/questions/1934715/difference-between-a-coroutine-and-a-thread>)

[协程的优势](<https://github.com/alibaba/coobjc/blob/master/README_cn.md#0x4-%E5%8D%8F%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF>)

[协程的好处有哪些？](<https://www.zhihu.com/question/20511233>)

[添加协程](<https://zhuanlan.zhihu.com/p/25964339>)

[协程与事件循环](<https://malcolmyu.github.io/malnote/2015/11/18/Coroutine-and-Event-Loop/>)



**协程**是计算机程序的一类组件，推广了[协作式多任务](https://zh.wikipedia.org/wiki/%E5%8D%8F%E4%BD%9C%E5%BC%8F%E5%A4%9A%E4%BB%BB%E5%8A%A1)的[子程序](https://zh.wikipedia.org/wiki/%E5%AD%90%E7%A8%8B%E5%BA%8F)，允许执行被挂起与被恢复。

子例程是协程的特例。



调度方：

- 协程由开发者和开发语言决定什么时候执行调度，内核不参与，执行**协作式调度**，需要当前协程**主动去调度**下一个协程
- 线程由操作系统内核决定什么时候执行调度，一个用户线程肯定对应着一个内核线程（反过来不一定）

并行/并发程度：

- 多个协程可以并发，但是无法并行，并发也就代表着同一时间点只有一个协程运行
- 多个线程可以并发，甚至多核并行执行



async/await 是一种异步模式，一般会借助协程实现



协程调度器



同步阻塞 -> 异步回调非阻塞 -> 同步非阻塞（协程）



有栈协程：用(e)rsp栈寄存器来索引局部变量，上下文是协程私有的栈。 访问上下文数据也就是局部变量的时候，我们无需显式的使用栈寄存器+偏移量来访问，而是直接访问变量名。

无栈协程：用this来索引对象的成员变量，上下文就是对象自己。访问上下文数据也就是成员变量的时候，我们无需显式的使用this+成员偏移量（或者变量名）来访问，而是直接访问变量名。

[How do stackless coroutines differ from stackful coroutines?](https://stackoverflow.com/questions/28977302/how-do-stackless-coroutines-differ-from-stackful-coroutines)



- 进程：变量隔离，自动切换运行上下文
- 线程：不变量隔离，自动切换运行上下文切换
- 协程：不变量隔离，不自动切换运行上下文切换



你可以在任何地方下个“断点”，然后编译器会把“剩下的部分”包装成一个闭包（或者通俗一点叫lambda表达式）给你。



协程的核心思想在于：**控制流的主动让出和恢复**。



**命令式编程：**

**迭代器（Iterator）**

可以把生成器看做迭代器的工厂函数，生成器创建的迭代器可以自动维护自己的状态，自定义的迭代器则需要创建者维护内部状态。



保存和恢复调用栈



yield 回到上一次 resume 点

resume 回到上一次 yield 点




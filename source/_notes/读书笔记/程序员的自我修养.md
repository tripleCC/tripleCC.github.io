



《动态链接、静态链接》我的理解：

- 动态链接、静态链接更多的是指如何处理链接的库，以及和链接库相关的符号引用（注意，这里的动作目标是“库”），一个可执行文件的构建过程中，可能同时包含了动态链接和静态链接
- 我们常说的动态链接 / 静态链接生成的可执行文件，指的是链接时，优先采用什么方式去链接依赖库，一般系统的依赖库都会有静态链接库和动态链接库两个版本，指定可执行文件的链接方式后，链接器会优先选择对应的库版本以指定的方式去链接依赖库
- 而常说的动态链接库通常指给动态链接使用的库，静态链接库通常指给静态链接使用的库
- 至于链接时的具体区别，如果引用的符号在静态链接库中，则按照静态链接规则，在链接阶段合并该静态链接库，并将可执行文件中的此符号重定位；如果引用的符号在动态链接库中，则链接器会标志此符号为一个动态链接符号（放入动态符号表），不合并该动态链接库，也不会进行重定位，把重定位过程留到装载时再进行



每个重定位的入口都是对一个符号的引用，那么当链接器需要对某个符号的引用进行重定位时，它就要确定这个符号的目标地址，这时候链接器就回去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。（猜想上面那个确定重定位入口符号引用地址的过程就是符号绑定）



[dyld 动态链接](https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html)



![截屏2019-10-30上午9.45.10](/Users/songruiwang/GitHubIO/hexo/source/images/截屏2019-10-30上午9.45.10.png)

也就是说，即使是动态库中的符号，也需要链接成可执行文件时，参与链接器符号解析过程，至少要明确这个符号在动态库中是存在的，才能判断引用函数的性质。

![截屏2019-10-30下午12.41.14](/Users/songruiwang/GitHubIO/hexo/source/images/截屏2019-10-30下午12.41.14.png)

符号解析：

![截屏2019-10-30下午12.53.42](/Users/songruiwang/GitHubIO/hexo/source/images/截屏2019-10-30下午12.53.42.png)

多任务，抢占式，优先级划分，每个任务快速切换，执行超过时长可暂停



不用物理内存

- 地址空间不隔离
- 内存使用效率低
- 程序运行的地址不确定



n 位机器最大地址空间 2^n 字节

目前 PC 操作系统普遍分页 4 KB

**页错误**将进程虚拟页的映射对象从磁盘页转移到物理页



内存共享，虚拟空间的有些页被映射到了同一个物理页

MMU-》虚拟地址转换为物理地址



线程，程序执行流的最小单元，由线程ID、当前指令指针（PC）、寄存器集合、堆栈4部分组成

进程中的线程共享程序的内存空间（代码段、数据段、堆等）及一些进程级资源（打开文件、信号等）



线程私有存储空间：

- 栈 （局部变量、函数参数等）
- 线程局部存储 TSL
- 寄存器



IO 密集、CPU 密集（线程等待）



抢占、不可抢占线程（线程内部放弃执行）



fork 进程写时复制，所以快



原子操作：单指令操作



同步

- 信号量（访问范围任何进程）
- 互斥量（访问范围任何进程，需同个线程持有释放）
- 临界区（访问范围局限同个进程，需同个线程持有释放）
- 读写锁（获取方式：共享的、独占的）
- 条件变量 （notify）



volatile

- 阻止编译器为了提高速度将变量缓存到寄存器内而不写回
- 组织编译器调整操作 volatile 变量的指令顺序（不能组织 CPU 动态调度换序）



预处理(.i)、编译(.s)、汇编(.o)、链接

预处理 -E

- 处理 # 开始的预编译指令，如 #include、#define
- 删除 #define，展开宏定义
- 处理条件预编译指令，如 #if、#ifdef、#elif、#else、#endif
- 处理 #include，递归插入包含文件
- 删除注释，如//、\\**\
- 添加行号和文件标识，用以编译时产生调试行号等信息
- 保留 #pragma （编译指示）

编译 -S

- 转成汇编代码
- 词法分析、语法分析、语义分析及优化

汇编 -C

- 汇编代码转成机器可执行的指令，生成目标文件

链接 

- 生成可执行文件



词法分析

- 字符串分割成记号
- 关键字、标识符、字面量、特殊符号

语法分析

- 语法树，以表达式为节点的树

语义分析

- 表达式类型



编译器

- 前端，负责产生机器无关的中间代码
- 后端，负责将中间代码转换成目标机器代码

重定位

- 重新计算各个目标的地址过程



链接

- 地址和空间分配
- 符号决议（符号绑定）（决议倾向静态链接，绑定倾向动态链接）
- 重定位



程序指令、程序数据

程序指令

- 代码段(.text) 

程序数据

- 数据段(.data)
- .bss段



分离的好处

- 读写权限分离
- 增加缓存命中
- 共享只读内存



大小端：看左边放的是大小位



目标文件中的重定位表



链接的本质，把多个不同的目标文件之间相互粘到一起，对函数和变量的地址的引用



符号修饰与函数签名



C++符号名=函数+函数签名



extern "C" : 大括号内的名称修饰机制不起作用，为修饰后符号

C++会以C++的规则对名称进行修饰，C 不会，如果 C++ 引入 C 函数时，修饰了函数名，则链接时会找不到对应的 C 函数

```
#if defined(__cplusplus)
#define FOUNDATION_EXPORT extern "C"
#else
#define FOUNDATION_EXPORT extern
#endif
```



#### 符号重定义/未定义错误

强符号

- 函数和初始化了的全局变量

弱符号

- 未初始化的全局变量



链接器处理多次定义的全局符号：

- 不允许强符号被多次定义；如果有多个强符号定义，则链接器报符号重定义错误
- 如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号
- 如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个



强引用

- 符号决议时，如果没有找到该符号的定义，链接器报未定于错误

弱引用

- 和强引用相反，不会报



无论是可执行文件、目标文件或库，它们实际上都是基于段的文件或是这种文件的集合。

> 对于 iOS CocoaPods 工程，最终的 App 的可执行文件只会包含静态库，动态 framework 和动态库都独立放在另一个文件夹中



空间+地址分配

​	可确定每个符号的虚拟地址



重定位指令	

​	根据符号地址修正需要重定位的指令，比如函数调用

​	根据文件中的重定位表

​	重定位过程中每个重定位入口都是对一个符号的引用，当链接器需要对某个符号的引用进行重定位时，就要确定这个符号的目标地址，链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位

​	链接器扫描完所欲输入目标文件后，所有未定义的符号都应该能够在全局符号表中找到，否则链接器就报符号未定义错误



ABI 

​	符号修饰标准、变量内存布局、函数调用方式等和可执行二进制兼容性相关的内容



静态库

​	可以简单地看成一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件



进程的建立

​	创建一个独立的虚拟地址空间

​	读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系

​	将 CPU 的指令寄存器设置成可执行文件的入口地址，启动执行



虚拟空间由一组页映射函数将虚拟空间的各个页映射至相应的物理空间。

创建一个虚拟空间实际上并不是创建空间，而是创建映射函数所需要的相应的数据结构。

映射关系只是保存在操作系统内部的一个数据结构，发生页错误时，可以通过查找此数据结构来定位错误页在可执行文件中的位置。



段的权限划分：

​	以代码段为代表的权限为可读可执行的段

​	以数据段和 BSS 段为代表的权限为可读可写的段

​	以只读数据段为代表的权限为只读的段



Segment 和 Section 是从不同角度来划分同一个可执行文件



Segment

​	权限相同的 Section 合并在一起的段 （装载映射角度）

Section

​	文件中的段（链接存储角度）



段映射长度需要是系统页长度的整数倍，所以将类型属性的 Section 聚合成 Segment 一起映射可以减少空间的浪费





在iOS中，重定位有两种

​	编译链接时，因为目标文件不知道可执行文件全局信息，所以某些指令的值是暂定的，链接生成可执行文件时，会通过目标文件的重定位表以及所有输入目标文件符号表组成的全局符号表进行重定位

​	运行时，重定位用来修正随机地址偏移造成指令值的错位



数据段和 BSS 段的区别

​	数据段从文件中初始化内容，BSS段的内容全部初始化为0



页错误：

![Snip20190822_30](/Users/songruiwang/GitHubIO/hexo/source/images/Snip20190822_30.png)

VMA 

​	虚拟内存区域，虚拟空间中的一个段

​	映射可执行文件中的各个 Segment，将虚拟内存和可执行文件关联起来



操作系统通过给进程空间划分出一个个 VMA 来管理进程的虚拟空间



http://venkateshabbarapu.blogspot.com/2012/09/process-segments-and-vma.html

https://blog.acean.vip/post/linux-kernel/gai-shu-linuxnei-he-san-jia-ma-che-zhi-nei-cun-guan-li



Each virtual memory area (VMA) is a contiguous range of virtual addresses; these areas never overlap. An instance of vm_area_struct fully describes a memory area, including its start and end addresses, flags to determine access rights and behaviors, and the vm_file field to specify which file is being mapped by the area, if any. A VMA that does not map a file is anonymous. Each memory segment above (e.g., heap, stack) corresponds to a single VMA, with the exception of the memory mapping segment. This is not a requirement, though it is usual in x86 machines. VMAs do not care which segment they are in.



静态链接：

-  空间浪费

- 更新困难



共享一个目标文件模块的好处:

- 节省内存
- 减少物理页面的换入换出
- 增加CPU的命中率



链接器：

- 静态链接器 (ld，作用于编译链接)
- 动态链接器 (dyld，作用于运行时)



静态链接器重定位符号:

- （链接时重定位）符号定义在其他静态目标模块中，按照静态链接规则，将目标模块对于符号的引用地址重定位
- （装载时重定位，rebasing，基址重置）符号定义在动态共享对象中，链接器将符号的引用标记为一个动态链接符号，不进行地址重定位，这个过程留到装载时进行（上面关于 iOS 重定位分两种描述有偏差）



在系统开始运行可执行文件之前，首先会把控制权交给动态链接器，由它完成所有的动态链接工作以后把控制权交给可执行文件，然后开始执行。



共享对象的最终装载地址在编译时是不确定的，而是在装载时，装载器根据当前地址空间的空闲情况，动态分配一块足够大下的虚拟地址空间给相应的共享对象（通过将不同进程的虚拟地址空间映射到同一个物理地址空间来共享）

地址无关代码（共享指令部分不随着装载地址的改变而改变）：

- 装载时重定位可解决绝对地址引用问题，但是这样重定位的指令无法被多个进程共享，因为每个进程所需要的偏移是不一致的
- **动态链接库中的数据部分对于多个进程来说有多个副本，将指令中需要修改的部分分离出来，放到数据部分中，指令部分就可以保持不变，数据部分每个进程都有各自的副本，不会互相影响**（PIC）



mach-o 中有个Dynamic symbol table ，其实就是为了解决地址无关代码，在 table 中保存需要访问动态链接库的函数或者变量偏移，实际访问时，通过这个 table 获取函数在进程空间的实际地址

GOT: 全局偏移表（global offset table）



动态链接库被两个进程加载时，它的数据段部分在每个进程中都有独立的副本，任一进程访问的只是自己的那个副本，不会影响其他进程。对于同个进程中的不同线程来说，共享同一个进程地址空间，所以会互相影响，不过线程也有类似的私有副本，叫做线程私有存储 TLS。



由于共享对象的数据段在每个进程中都有自己的备份，并不担心被其他进程改变，所以可以使用重定位的方法来解决数据段中绝对地址引用问题：

```
static int a;
static int *p = &a;
// p 保存的地址为绝对地址
```



延迟绑定：

[Lazy binding](http://www.qnx.com/developers/docs/qnxcar2/index.jsp?topic=%2Fcom.qnx.doc.neutrino.prog%2Ftopic%2Fdevel_Lazy_binding.html)

动态链接下，无差别地处理函数引用的符号查找及重定位，需要耗费不少时间，为了加快应用启动速度，可以让大部分函数采用延迟绑定的方法，第一次用到该函数时才进行绑定，如果没用到则不进行绑定。

PLT : procedure linkage table ，程序连接表

ELF 采用 .got、.got.plt 段处理延迟绑定

- 符号如果没有被绑定， .got.plt 中对应实现会调用动态链接器函数完成符号解析和重定位工作，然后将地址存入 got ，后续再调用，由于 got 值已经是符号地址，所以直接 jmp

mach-o 采用 .got、.la_symbol_ptr、.stubs、.stub_helper 段处理延迟绑定

- 调用 stub 值中 jmpq 语句，跳转到 la_symbol_ptr 中值对应的辅助地址，然后通过 stub_helper 计算真实地址，存入 la_symbol_ptr 中，后续执行 stub 中的语句，由于 la_symbol_ptr 是调用符号的实际地址，所以不需要再进行绑定

https://stackoverflow.com/questions/8825537/mach-o-symbol-stubs-ios

[https://turingh.github.io/2016/03/10/Mach-O%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/](https://turingh.github.io/2016/03/10/Mach-O的动态链接/)

https://feicong.github.io/2017/01/13/macho/



动态链接器是一个共享对象，操作系统同样通过映射的方式将它加载到进程的地址空间中。操作系统加载完动态链接器之后，就将控制权交给动态链接器的入口地址。当动态链接器得到控制权之后，它开始执行一系列自身的初始化操作，然后根据当前的环境参数，开始对可执行文件进行动态链接工作。当所有动态链接工作完成之后，动态链接器会将控制权转交到可执行文件的入口地址，程序正式开始执行。



动态链接下，无论是可执行文件或共享对象，一旦它依赖于其他共享对象，也就是说有导入的符号时，那么它的代码或数据中就会有对于导入符号的引用，在编译时这些导入符号的地址未知，在静态链接中，这些未知的地址引用在最终链接时被修正，但是在动态链接中，导入的符号地址在运行时才确定，所以需要在运行时将这些导入符号的引用修正，即需要重定位。



对于使用 PIC 技术的可执行文件或共享对象来说，虽然他们的代码段不需要重定位（因为地址无关），但是数据段还包含了绝对地址的引用，因为代码段中绝对地址相关的部分被分离了出来，变成了 GOT，而 GOT 实际上是数据段的一部分，除 GOT 以外，数据段可能还包含绝对地址引用



[Linux 中 mmap() 函数的内存映射问题理解？](https://www.zhihu.com/question/48161206)

mmap的工作原理，当你发起这个调用的时候，它只是在你的虚拟空间中分配了一段空间 (VMA)，连真实的物理地址都不会分配的，当你访问这段空间，CPU陷入OS内核执行异常处理，然后异常处理会在这个时间分配物理内存，并用文件的内容填充这片内存，然后才返回你进程的上下文，这时你的程序才会感知到这片内存里有数据


动态链接步骤：

- 启动动态链接器本身
- 装载所有需要的共享对象
- 重定位和初始化



使用 PIC 模式编译的共享对象，对于模块内部的函数调用也是采用跟模块外部函数调用一样的方式，即 GOT / PLT 的方式。



当一个新的共享对象被装载进来的时候，它的符号表会被合并到全局符号表中，所以当所有的共享对象都被装载进来的时候，全局符号表里面将包含进程中动态链接所需要的所有符号。



动态链接器步骤：

- 动态链接器自举
  - 让自己可以使用全局/静态变量和内部函数
- 装载共享对象
  - 全局符号介入：当一个符号需要被加入全局符号表时，如果相同的符号名已经存在，则后加入的符号被忽略
  - 广度优先
- 重定位和初始化
  - 遍历可执行文件和共享对象的重定位表，将 GOT/PLT 中每个需要重定位的位置进行修正
  - 如果共享对象有 init 段，则执行其中的代码，执行初始化



http://www.m4b.io/reverse/engineering/mach/binaries/2015/03/29/mach-binaries.html



运行时加载：让程序自己在运行时控制加载制定的模块，并且可以在不需要该模块时将其卸载

- dlopen 打开一个动态库，并将其加载到进程的地址空间，完成初始化过程
- dlsym 找到所需要的符号
- dlerror 判断上一次调用是否成功
- dlclose 卸载已经加载的模块（使用计数器，为0卸载）

、

装载时重定位和地址无关代码是解决绝对地址引用问题的两个方法，装载时重定位的缺点时无法共享代码段，但是它的运行速度较快；地址无关代码的缺点是运行速度稍慢，但它可以实现代码段在各个进程之间的共享。



动态符号表：保存所有关于目标文件符号的定义和引用（导入导出符号）



栈

- 用于维护函数调用上下文，离开栈，函数调用就没法实现
- 通常在用户空间高地址分配，有数兆字节大小

堆

- 容纳应用程序动态分配的内存区域
- 通常在栈的下方，比栈大很多，可以有几十至数百兆字节大小



栈帧

- 函数的返回地址和参数
- 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量
- 保存的上下文：包括在函数调用前后需要保持不变的寄存器



esp：extended stack pointer，栈顶指针

ebp：extended base pointer，栈底指针



函数调用惯例

- 函数参数的传递顺序和方式
  - 压栈顺序：从左至右、从右至左
  - 允许使用寄存器传参
- 栈的维护方式
  - 弹参操作由调用方，或函数本身完成
- 名字修饰策略（name-mangling）



如果返回值类型尺寸太大，C语言在函数返回时会使用一个临时的栈上内存区域作为中转，结果返回值对象会被拷贝两次。

- 首先 main 函数在栈上额外开辟了一片空间，并将这块空间的一部分作为传递返回值的临时对象，这里称为 temp
- 将 temp 对象的地址作为隐藏参数传递给 return_test 函数
- return_test 函数将数据拷贝给 temp 对象，并将 temp 对象的地址用 exa 传出 （1）
- return_test 返回之后，main 函数将 eax 指向的 temp 对象的内容拷贝给 n （2）



malloc 申请的空间连续性

- 空间指虚拟空间，则连续的，每一次 malloc 分配后返回的地址空间都可以看做是一块连续的地址
- 空间指物理控价你，则不一定连续，因为一块连续的虚拟地址空间有可能是若干个不连续的物理页拼凑而成的



malloc 申请的内存，进程结束以后还会不会存在

- 不会存在。当进程结束以后，所有与进程相关的资源，包括进程的地址空间、物理内存、打开的文件、网络链接等都被操作系统关闭或者收回，所以无论 malloc 申请了多少内存，进程结束以后都不存在了



eax：通常用来保存返回值

栈帧结构：

![Snip20190903_1](/Users/songruiwang/GitHubIO/hexo/source/images/Snip20190903_1.png)



典型程序运行步骤：

- 操作系统砸i 创建进程后，把控制权交到了程序的入口，这个入口往往是运行库中的某个入口函数
- 入口函数对运行库和程序运行环境进行初始化，包括堆、IO、线程、全局变量构造、等
- 入口函数在完成初始化之后，调用 main 函数，正式开始执行程序主体部分
- main 函数执行完毕以后，返回到入口函数，入口函数进行清理工作，包括全局变量析构、堆销毁，关闭 IO 等，然后进行系统调用结束进程



线程私有（栈、线程局部存储、寄存器）：

- 局部变量
- 函数的参数
- TLS 数据

线程之间共享：

- 全局变量
- 堆上的数据
- 函数里的静态变量
- 程序代码
- 打开文件



errno，错误号，保存在每个线程的 TLS 中



中断：指程序执行过程中，遇到紧急处理的事件时，暂时终止cpu上现行的程序，转去执行相应的事件处理程序，待处理完成后再返回原程序被中断处或调度其他程序执行的过程

中断是一个硬件或软件发出的请求

中断一般具有两个属性，一个称为中断号，一个称为中断处理程序。在内核中，有一个数组称为中断向量表，这个数组的第n项包含了指向n号中断的中断处理程序的指针。当中断到来时，cpu 会暂停当前执行的代码，根据中断的中断号，在中断向量表中找到对应的中断处理程序，并调用它。中断处理程序执行完成之后，cpu会继续执行之前的代码



通常意义上，中断有两种类型，一种称为硬件中断，这种中断来自于硬件的异常或其他事件的发生，如电源掉电，键盘被按下等。另一种称为软中断，软件中断通常是一条指令（i386 下是 int），带有一个参数记录中断号，使用这条指令用户可以手动触发某个中断并执行其中断处理程序·

![IMG_5472](/Users/songruiwang/GitHubIO/hexo/source/images/IMG_5472.png)

Linux使用 0x80 号中断作为系统调用的入口，exa 寄存器用于表示系统调用接口号，当系统调用返回时，exa又作为调用结果的返回值






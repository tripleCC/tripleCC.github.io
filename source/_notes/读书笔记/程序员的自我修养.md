



《动态链接、静态链接》我的理解：

- 动态链接、静态链接更多的是指如何处理链接的库，以及和链接库相关的符号引用（注意，这里的动作目标是“库”），一个可执行文件的构建过程中，可能同时包含了动态链接和静态链接
- 而常说的动态链接库通常指给动态链接使用的库，静态链接库通常指给静态链接使用的库
- 至于链接时的具体区别，如果引用的符号在静态链接库中，则按照静态链接规则，在链接阶段合并该静态链接库，并将可执行文件中的此符号重定位；如果引用的符号在动态链接库中，则链接器会标志此符号为一个动态链接符号，不合并该动态链接库，也不会进行重定位，把重定位过程留到装载时再进行



空间+地址分配

​	可确定每个符号的虚拟地址



重定位指令	

​	根据符号地址修正需要重定位的指令，比如函数调用

​	根据文件中的重定位表

​	重定位过程中每个重定位入口都是对一个符号的引用，当链接器需要对某个符号的引用进行重定位时，就要确定这个符号的目标地址，链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位

​	链接器扫描完所欲输入目标文件后，所有未定义的符号都应该能够在全局符号表中找到，否则链接器就报符号未定义错误



ABI 

​	符号修饰标准、变量内存布局、函数调用方式等和可执行二进制兼容性相关的内容



静态库

​	可以简单地看成一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件



进程的建立

​	创建一个独立的虚拟地址空间

​	读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系

​	将 CPU 的指令寄存器设置成可执行文件的入口地址，启动执行



虚拟空间由一组页映射函数将虚拟空间的各个页映射至相应的物理空间。

创建一个虚拟空间实际上并不是创建空间，而是创建映射函数所需要的相应的数据结构。

映射关系只是保存在操作系统内部的一个数据结构，发生页错误时，可以通过查找此数据结构来定位错误页在可执行文件中的位置。



段的权限划分：

​	以代码段为代表的权限为可读可执行的段

​	以数据段和 BSS 段为代表的权限为可读可写的段

​	以只读数据段为代表的权限为只读的段



Segment 和 Section 是从不同角度来划分同一个可执行文件



Segment

​	权限相同的 Section 合并在一起的段 （装载映射角度）

Section

​	文件中的段（链接存储角度）



段映射长度需要是系统页长度的整数倍，所以将类型属性的 Section 聚合成 Segment 一起映射可以减少空间的浪费





在iOS中，重定位有两种

​	编译链接时，因为目标文件不知道可执行文件全局信息，所以某些指令的值是暂定的，链接生成可执行文件时，会通过目标文件的重定位表以及所有输入目标文件符号表组成的全局符号表进行重定位

​	运行时，重定位用来修正随机地址偏移造成指令值的错位



数据段和 BSS 段的区别

​	数据段从文件中初始化内容，BSS段的内容全部初始化为0



页错误：

![Snip20190822_30](/Users/songruiwang/GitHubIO/hexo/source/images/Snip20190822_30.png)

VMA 

​	虚拟内存区域，虚拟空间中的一个段

​	映射可执行文件中的各个 Segment，将虚拟内存和可执行文件关联起来



操作系统通过给进程空间划分出一个个 VMA 来管理进程的虚拟空间



http://venkateshabbarapu.blogspot.com/2012/09/process-segments-and-vma.html

https://blog.acean.vip/post/linux-kernel/gai-shu-linuxnei-he-san-jia-ma-che-zhi-nei-cun-guan-li



Each virtual memory area (VMA) is a contiguous range of virtual addresses; these areas never overlap. An instance of vm_area_struct fully describes a memory area, including its start and end addresses, flags to determine access rights and behaviors, and the vm_file field to specify which file is being mapped by the area, if any. A VMA that does not map a file is anonymous. Each memory segment above (e.g., heap, stack) corresponds to a single VMA, with the exception of the memory mapping segment. This is not a requirement, though it is usual in x86 machines. VMAs do not care which segment they are in.



静态链接：

-  空间浪费

- 更新困难



共享一个目标文件模块的好处:

- 节省内存
- 减少物理页面的换入换出
- 增加CPU的命中率



链接器：

- 静态链接器 (ld，作用于编译链接)
- 动态链接器 (dyld，作用于运行时)



静态链接器重定位符号:

- （链接时重定位）符号定义在其他静态目标模块中，按照静态链接规则，将目标模块对于符号的引用地址重定位
- （装载时重定位，rebasing，基址重置）符号定义在动态共享对象中，链接器将符号的引用标记为一个动态链接符号，不进行地址重定位，这个过程留到装载时进行（上面关于 iOS 重定位分两种描述有偏差）



在系统开始运行可执行文件之前，首先会把控制权交给动态链接器，由它完成所有的动态链接工作以后把控制权交给可执行文件，然后开始执行。



共享对象的最终装载地址在编译时是不确定的，而是在装载时，装载器根据当前地址空间的空闲情况，动态分配一块足够大下的虚拟地址空间给相应的共享对象（通过将不同进程的虚拟地址空间映射到同一个物理地址空间来共享）

地址无关代码（共享指令部分不随着装载地址的改变而改变）：

- 装载时重定位可解决绝对地址引用问题，但是这样重定位的指令无法被多个进程共享，因为每个进程所需要的偏移是不一致的
- **动态链接库中的数据部分对于多个进程来说有多个副本，将指令中需要修改的部分分离出来，放到数据部分中，指令部分就可以保持不变，数据部分每个进程都有各自的副本，不会互相影响**（PIC）



mach-o 中有个Dynamic symbol table ，其实就是为了解决地址无关代码，在 table 中保存需要访问动态链接库的函数或者变量偏移，实际访问时，通过这个 table 获取函数在进程空间的实际地址

GOT: 全局偏移表（global offset table）



动态链接库被两个进程加载时，它的数据段部分在每个进程中都有独立的副本，任一进程访问的只是自己的那个副本，不会影响其他进程。对于同个进程中的不同线程来说，共享同一个进程地址空间，所以会互相影响，不过线程也有类似的私有副本，叫做线程私有存储 TLS。



由于共享对象的数据段在每个进程中都有自己的备份，并不担心被其他进程改变，所以可以使用重定位的方法来解决数据段中绝对地址引用问题：

```
static int a;
static int *p = &a;
// p 保存的地址为绝对地址
```



延迟绑定：

动态链接下，无差别地处理函数引用的符号查找及重定位，需要耗费不少时间，为了加快应用启动速度，可以让大部分函数采用延迟绑定的方法，第一次用到该函数时才进行绑定，如果没用到则不进行绑定。

PLT : procedure linkage table ，程序连接表

ELF 采用 .got、.got.plt 段处理延迟绑定

- 符号如果没有被绑定， .got.plt 中对应实现会调用动态链接器函数完成符号解析和重定位工作，然后将地址存入 got ，后续再调用，由于 got 值已经是符号地址，所以直接 jmp

mach-o 采用 .got、.la_symbol_ptr、.stubs、.stub_helper 段处理延迟绑定

- 调用 stub 值中 jmpq 语句，跳转到 la_symbol_ptr 中值对应的辅助地址，然后通过 stub_helper 计算真实地址，存入 la_symbol_ptr 中，后续执行 stub 中的语句，由于 la_symbol_ptr 是调用符号的实际地址，所以不需要再进行绑定

https://stackoverflow.com/questions/8825537/mach-o-symbol-stubs-ios

[https://turingh.github.io/2016/03/10/Mach-O%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/](https://turingh.github.io/2016/03/10/Mach-O的动态链接/)

https://feicong.github.io/2017/01/13/macho/



动态链接器是一个共享对象，操作系统同样通过映射的方式将它加载到进程的地址空间中。操作系统加载完动态链接器之后，就将控制权交给动态链接器的入口地址。当动态链接器得到控制权之后，它开始执行一系列自身的初始化操作，然后根据当前的环境参数，开始对可执行文件进行动态链接工作。当所有动态链接工作完成之后，动态链接器会将控制权转交到可执行文件的入口地址，程序正式开始执行。



动态链接下，无论是可执行文件或共享对象，一旦它依赖于其他共享对象，也就是说有导入的符号时，那么它的代码或数据中就会有对于导入符号的引用，在编译时这些导入符号的地址未知，在静态链接中，这些未知的地址引用在最终链接时被修正，但是在动态链接中，导入的符号地址在运行时才确定，所以需要在运行时将这些导入符号的引用修正，即需要重定位。



对于使用 PIC 技术的可执行文件或共享对象来说，虽然他们的代码段不需要重定位（因为地址无关），但是数据段还包含了绝对地址的引用，因为代码段中绝对地址相关的部分被分离了出来，变成了 GOT，而 GOT 实际上是数据段的一部分，除 GOT 以外，数据段可能还包含绝对地址引用



[Linux 中 mmap() 函数的内存映射问题理解？](https://www.zhihu.com/question/48161206)

mmap的工作原理，当你发起这个调用的时候，它只是在你的虚拟空间中分配了一段空间 (VMA)，连真实的物理地址都不会分配的，当你访问这段空间，CPU陷入OS内核执行异常处理，然后异常处理会在这个时间分配物理内存，并用文件的内容填充这片内存，然后才返回你进程的上下文，这时你的程序才会感知到这片内存里有数据


动态链接步骤：

- 启动动态链接器本身
- 装载所有需要的共享对象
- 重定位和初始化



使用 PIC 模式编译的共享对象，对于模块内部的函数调用也是采用跟模块外部函数调用一样的方式，即 GOT / PLT 的方式。



当一个新的共享对象被装载进来的时候，它的符号表会被合并到全局符号表中，所以当所有的共享对象都被装载进来的时候，全局符号表里面将包含进程中动态链接所需要的所有符号。



动态链接器步骤：

- 动态链接器自举
  - 让自己可以使用全局/静态变量和内部函数
- 装载共享对象
  - 全局符号介入：当一个符号需要被加入全局符号表时，如果相同的符号名已经存在，则后加入的符号被忽略
  - 广度优先
- 重定位和初始化
  - 遍历可执行文件和共享对象的重定位表，将 GOT/PLT 中每个需要重定位的位置进行修正
  - 如果共享对象有 init 段，则执行其中的代码，执行初始化



http://www.m4b.io/reverse/engineering/mach/binaries/2015/03/29/mach-binaries.html



运行时加载：让程序自己在运行时控制加载制定的模块，并且可以在不需要该模块时将其卸载

- dlopen 打开一个动态库，并将其加载到进程的地址空间，完成初始化过程
- dlsym 找到所需要的符号
- dlerror 判断上一次调用是否成功
- dlclose 卸载已经加载的模块（使用计数器，为0卸载）

、

装载时重定位和地址无关代码是解决绝对地址引用问题的两个方法，装载时重定位的缺点时无法共享代码段，但是它的运行速度较快；地址无关代码的缺点是运行速度稍慢，但它可以实现代码段在各个进程之间的共享。



动态符号表：保存所有关于目标文件符号的定义和引用（导入导出符号）



栈

- 用于维护函数调用上下文，离开栈，函数调用就没法实现
- 通常在用户空间高地址分配，有数兆字节大小

堆

- 容纳应用程序动态分配的内存区域
- 通常在栈的下方，比栈大很多，可以有几十至数百兆字节大小



栈帧

- 函数的返回地址和参数
- 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量
- 保存的上下文：包括在函数调用前后需要保持不变的寄存器



esp：extended stack pointer，栈顶指针

ebp：extended base pointer，栈底指针



函数调用惯例

- 函数参数的传递顺序和方式
  - 压栈顺序：从左至右、从右至左
  - 允许使用寄存器传参
- 栈的维护方式
  - 弹参操作由调用方，或函数本身完成
- 名字修饰策略（name-mangling）



如果返回值类型尺寸太大，C语言在函数返回时会使用一个临时的栈上内存区域作为中转，结果返回值对象会被拷贝两次。

- 首先 main 函数在栈上额外开辟了一片空间，并将这块空间的一部分作为传递返回值的临时对象，这里称为 temp
- 将 temp 对象的地址作为隐藏参数传递给 return_test 函数
- return_test 函数将数据拷贝给 temp 对象，并将 temp 对象的地址用 exa 传出 （1）
- return_test 返回之后，main 函数将 eax 指向的 temp 对象的内容拷贝给 n （2）



malloc 申请的空间连续性

- 空间指虚拟空间，则连续的，每一次 malloc 分配后返回的地址空间都可以看做是一块连续的地址
- 空间指物理控价你，则不一定连续，因为一块连续的虚拟地址空间有可能是若干个不连续的物理页拼凑而成的



malloc 申请的内存，进程结束以后还会不会存在

- 不会存在。当进程结束以后，所有与进程相关的资源，包括进程的地址空间、物理内存、打开的文件、网络链接等都被操作系统关闭或者收回，所以无论 malloc 申请了多少内存，进程结束以后都不存在了



eax：通常用来保存返回值

栈帧结构：

![Snip20190903_1](/Users/songruiwang/GitHubIO/hexo/source/images/Snip20190903_1.png)



典型程序运行步骤：

- 操作系统砸i 创建进程后，把控制权交到了程序的入口，这个入口往往是运行库中的某个入口函数
- 入口函数对运行库和程序运行环境进行初始化，包括堆、IO、线程、全局变量构造、等
- 入口函数在完成初始化之后，调用 main 函数，正式开始执行程序主体部分
- main 函数执行完毕以后，返回到入口函数，入口函数进行清理工作，包括全局变量析构、堆销毁，关闭 IO 等，然后进行系统调用结束进程


空间+地址分配

​	可确定每个符号的虚拟地址



重定位指令	

​	根据符号地址修正需要重定位的指令，比如函数调用

​	根据文件中的重定位表

​	重定位过程中每个重定位入口都是对一个符号的引用，当链接器需要对某个符号的引用进行重定位时，就要确定这个符号的目标地址，链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位

​	链接器扫描完所欲输入目标文件后，所有未定义的符号都应该能够在全局符号表中找到，否则链接器就报符号未定义错误



ABI 

​	符号修饰标准、变量内存布局、函数调用方式等和可执行二进制兼容性相关的内容



静态库

​	可以简单地看成一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件



进程的建立

​	创建一个独立的虚拟地址空间

​	读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系

​	将 CPU 的指令寄存器设置成可执行文件的入口地址，启动执行



虚拟空间由一组页映射函数将虚拟空间的各个页映射至相应的物理空间。

创建一个虚拟空间实际上并不是创建空间，而是创建映射函数所需要的相应的数据结构。

映射关系只是保存在操作系统内部的一个数据结构，发生页错误时，可以通过查找此数据结构来定位错误页在可执行文件中的位置。



段的权限划分：

​	以代码段为代表的权限为可读可执行的段

​	以数据段和 BSS 段为代表的权限为可读可写的段

​	以只读数据段为代表的权限为只读的段



Segment 和 Section 是从不同角度来划分同一个可执行文件



Segment

​	权限相同的 Section 合并在一起的段 （装载映射角度）

Section

​	文件中的段（链接存储角度）



段映射长度需要是系统页长度的整数倍，所以将类型属性的 Section 聚合成 Segment 一起映射可以减少空间的浪费





在iOS中，重定位有两种

​	编译链接时，因为目标文件不知道可执行文件全局信息，所以某些指令的值是暂定的，链接生成可执行文件时，会通过目标文件的重定位表以及所有输入目标文件符号表组成的全局符号表进行重定位

​	运行时，重定位用来修正随机地址偏移造成指令值的错位



数据段和 BSS 段的区别

​	数据段从文件中初始化内容，BSS段的内容全部初始化为0



页错误：

![Snip20190822_30](/Users/songruiwang/GitHubIO/hexo/source/images/Snip20190822_30.png)

VMA 

​	虚拟内存区域，虚拟空间中的一个段

​	映射可执行文件中的各个 Segment，将虚拟内存和可执行文件关联起来



操作系统通过给进程空间划分出一个个 VMA 来管理进程的虚拟空间



http://venkateshabbarapu.blogspot.com/2012/09/process-segments-and-vma.html

https://blog.acean.vip/post/linux-kernel/gai-shu-linuxnei-he-san-jia-ma-che-zhi-nei-cun-guan-li



Each virtual memory area (VMA) is a contiguous range of virtual addresses; these areas never overlap. An instance of vm_area_struct fully describes a memory area, including its start and end addresses, flags to determine access rights and behaviors, and the vm_file field to specify which file is being mapped by the area, if any. A VMA that does not map a file is anonymous. Each memory segment above (e.g., heap, stack) corresponds to a single VMA, with the exception of the memory mapping segment. This is not a requirement, though it is usual in x86 machines. VMAs do not care which segment they are in.



静态链接：

-  空间浪费

- 更新困难



共享一个目标文件模块的好处:

- 节省内存
- 减少物理页面的换入换出
- 增加CPU的命中率



链接器：

- 静态链接器 (ld，作用于编译链接)
- 动态链接器 (dyld，作用于运行时)



静态链接器重定位符号:

- （链接时重定位）符号定义在其他静态目标模块中，按照静态链接规则，将目标模块对于符号的引用地址重定位
- （装载时重定位，rebasing，基址重置）符号定义在动态共享对象中，链接器将符号的引用标记为一个动态链接符号，不进行地址重定位，这个过程留到装载时进行（上面关于 iOS 重定位分两种描述有偏差）



在系统开始运行可执行文件之前，首先会把控制权交给动态链接器，由它完成所有的动态链接工作以后把控制权交给可执行文件，然后开始执行。



共享对象的最终装载地址在编译时是不确定的，而是在装载时，装载器根据当前地址空间的空闲情况，动态分配一块足够大下的虚拟地址空间给相应的共享对象（通过将不同进程的虚拟地址空间映射到同一个物理地址空间来共享）

地址无关代码（共享指令部分不随着装载地址的改变而改变）：

- 装载时重定位可解决绝对地址引用问题，但是这样重定位的指令无法被多个进程共享，因为每个进程所需要的偏移是不一致的
- **动态链接库中的数据部分对于多个进程来说有多个副本，将指令中需要修改的部分分离出来，放到数据部分中，指令部分就可以保持不变，数据部分每个进程都有各自的副本，不会互相影响**（PIC）



mach-o 中有个Dynamic symbol table ，其实就是为了解决地址无关代码，在 table 中保存需要访问动态链接库的函数或者变量偏移，实际访问时，通过这个 table 获取函数在进程空间的实际地址

GOT: 全局偏移表（global offset table）



动态链接库被两个进程加载时，它的数据段部分在每个进程中都有独立的副本，任一进程访问的只是自己的那个副本，不会影响其他进程。对于同个进程中的不同线程来说，共享同一个进程地址空间，所以会互相影响，不过线程也有类似的私有副本，叫做线程私有存储 TLS。



由于共享对象的数据段在每个进程中都有自己的备份，并不担心被其他进程改变，所以可以使用重定位的方法来解决数据段中绝对地址引用问题：

```
static int a;
static int *p = &a;
// p 保存的地址为绝对地址
```



延迟绑定：

动态链接下，无差别地处理函数引用的符号查找及重定位，需要耗费不少时间，为了加快应用启动速度，可以让大部分函数采用延迟绑定的方法，第一次用到该函数时才进行绑定，如果没用到则不进行绑定。

PLT : procedure linkage table ，程序连接表

ELF 采用 .got、.got.plt 段处理延迟绑定

- 符号如果没有被绑定， .got.plt 中对应实现会调用动态链接器函数完成符号解析和重定位工作，然后将地址存入 got ，后续再调用，由于 got 值已经是符号地址，所以直接 jmp

mach-o 采用 .got、.la_symbol_ptr、.stubs、.stub_helper 段处理延迟绑定

- 调用 stub 值中 jmpq 语句，跳转到 la_symbol_ptr 中值对应的辅助地址，然后通过 stub_helper 计算真实地址，存入 la_symbol_ptr 中，后续执行 stub 中的语句，由于 la_symbol_ptr 是调用符号的实际地址，所以不需要再进行绑定

https://stackoverflow.com/questions/8825537/mach-o-symbol-stubs-ios

[https://turingh.github.io/2016/03/10/Mach-O%E7%9A%84%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/](https://turingh.github.io/2016/03/10/Mach-O的动态链接/)

https://feicong.github.io/2017/01/13/macho/
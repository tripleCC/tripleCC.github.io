<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[tripleCC的技术博客]]></title>
  <link href="http://triplecc.github.io/atom.xml" rel="self"/>
  <link href="http://triplecc.github.io/"/>
  <updated>2015-08-28T12:11:01+08:00</updated>
  <id>http://triplecc.github.io/</id>
  <author>
    <name><![CDATA[tripleCC]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[UINavigationBar属性小结及返回按钮更改]]></title>
    <link href="http://triplecc.github.io/blog/2015-04-27-uinavigationbarshu-xing-xiao-jie-ji-fan-hui-an-niu-geng-gai/"/>
    <updated>2015-04-27T20:17:32+08:00</updated>
    <id>http://triplecc.github.io/blog/uinavigationbarshu-xing-xiao-jie-ji-fan-hui-an-niu-geng-gai</id>
    <content type="html"><![CDATA[<h2>UINavigationBar属性</h2>

<ul>
<li>如果想统一设置，可以通过以下方法，获取当前类下的所有对象的导航条，然后进行设置</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="bp">UINavigationBar</span> <span class="nl">appearanceWhenContainedIn</span><span class="p">:</span><span class="nb">self</span><span class="p">,</span> <span class="nb">nil</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>背景图片<br>
<img src="./images/Snip20150724_4.png" alt="" /></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="c1">// barMetrics需要设置成UIBarMetricsDefault</span>
</span><span class='line'>  <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">setBackgroundimages</span><span class="p">:(</span><span class="n">UIimages</span> <span class="o">*</span><span class="p">)</span><span class="n">backgroundimages</span> <span class="nl">forBarMetrics</span><span class="p">:(</span><span class="n">UIBarMetrics</span><span class="p">)</span><span class="n">barMetrics</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>背景阴影图片<br>
<img src="./images/Snip20150724_5.png" alt="" /></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="k">@property</span><span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span><span class="k">retain</span><span class="p">)</span> <span class="n">UIimages</span> <span class="o">*</span><span class="n">shadowimages</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>背景颜色<br>
<img src="./images/Snip20150724_6.png" alt="" /></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="k">@property</span><span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span><span class="k">retain</span><span class="p">)</span> <span class="bp">UIColor</span> <span class="o">*</span><span class="n">barTintColor</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>标题文字属性<br>
<img src="./images/Snip20150724_10.png" alt="" /></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="k">@property</span><span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span><span class="k">copy</span><span class="p">)</span> <span class="bp">NSDictionary</span> <span class="o">*</span><span class="n">titleTextAttributes</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>系统类型按钮文字颜色<br>
<img src="./images/Snip20150724_9.png" alt="" /></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="k">@property</span><span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span><span class="k">retain</span><span class="p">)</span> <span class="bp">UIColor</span> <span class="o">*</span><span class="n">tintColor</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>返回按钮图片<br>
<img src="./images/Snip20150724_11.png" alt="" /></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="c1">// 必须要两个都设置，并且图片要设置成不渲染</span>
</span><span class='line'>  <span class="k">@property</span><span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span><span class="k">retain</span><span class="p">)</span> <span class="n">UIimages</span> <span class="o">*</span><span class="n">backIndicatorimages</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span><span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span><span class="k">retain</span><span class="p">)</span> <span class="n">UIimages</span> <span class="o">*</span><span class="n">backIndicatorTransitionMaskimages</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>标题垂直偏移<br>
<img src="./images/Snip20150724_12.png" alt="" /></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">setTitleVerticalPositionAdjustment</span><span class="p">:(</span><span class="n">CGFloat</span><span class="p">)</span><span class="n">adjustment</span> <span class="nl">forBarMetrics</span><span class="p">:(</span><span class="n">UIBarMetrics</span><span class="p">)</span><span class="n">barMetrics</span>
</span></code></pre></td></tr></table></div></figure>


<h2>返回按钮更改</h2>

<p>系统原装效果:<br>
<img src="./images/Snip20150724_13.png" alt="" /><br></p>

<p>如果有以下需求:</p>

<ul>
<li>去除上面返回按钮上“我是标题”字样，并设置返回图片为白色</li>
</ul>


<h6>分析</h6>

<ul>
<li>图片修改

<ul>
<li>方式1：设置返回图片颜色</li>
<li>方式2：直接设置返回图片</li>
<li>方式3：使用按钮覆盖返回图片(这种方式会使返回箭头图片和左边距离加大，但可以用取巧的方式调整)</li>
</ul>
</li>
<li>文字修改

<ul>
<li>方式1：设置控制器navigationItem的backBarButtonItem显示文字为""</li>
<li>方式2：设置返回按钮文字偏移量，使其移出屏幕</li>
<li>方式3：采用控制器navigationItem的leftBarButtonItem进行覆盖</li>
</ul>
</li>
</ul>


<h6>解决</h6>

<p>综合以上说明，这里给出三种方式(都是针对的自定义UINavigationController)：</p>

<ul>
<li>方式1:在<code>-pushViewController:animated:</code>中设置文字 ，在<code>+initialize</code>方法中设置返回图片或改变返回图片颜色

<ul>
<li>注意导航栏对图片的渲染</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">pushViewController</span><span class="p">:(</span><span class="bp">UIViewController</span> <span class="o">*</span><span class="p">)</span><span class="n">viewController</span> <span class="nl">animated</span><span class="p">:(</span><span class="kt">BOOL</span><span class="p">)</span><span class="n">animated</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">viewController</span><span class="p">.</span><span class="n">navigationItem</span><span class="p">.</span><span class="n">backBarButtonItem</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIBarButtonItem</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTitle</span><span class="p">:</span><span class="s">@&quot;&quot;</span> <span class="nl">style</span><span class="p">:</span><span class="n">UIBarButtonItemStyleDone</span> <span class="nl">target</span><span class="p">:</span><span class="nb">nil</span> <span class="nl">action</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="nl">pushViewController</span><span class="p">:</span><span class="n">viewController</span> <span class="nl">animated</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 获取特定类的所有导航条</span>
</span><span class='line'><span class="bp">UINavigationBar</span> <span class="o">*</span><span class="n">navigationBar</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UINavigationBar</span> <span class="nl">appearanceWhenContainedIn</span><span class="p">:</span><span class="nb">self</span><span class="p">,</span> <span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 方式1：使用自己的图片替换原来的返回图片</span>
</span><span class='line'><span class="n">navigationBar</span><span class="p">.</span><span class="n">backIndicatorImage</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageNamed</span><span class="p">:</span><span class="s">@&quot;NavBack&quot;</span><span class="p">];</span>
</span><span class='line'><span class="n">navigationBar</span><span class="p">.</span><span class="n">backIndicatorTransitionMaskImage</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageNamed</span><span class="p">:</span><span class="s">@&quot;NavBack&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 方式2：设置返回图片颜色</span>
</span><span class='line'><span class="n">navigationBar</span><span class="p">.</span><span class="n">tintColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="n">whiteColor</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>方式2:在<code>+initialize</code>方法中设置所有返回按钮文字的偏移量，其他设置和方式1一致</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="p">[[</span><span class="bp">UIBarButtonItem</span> <span class="n">appearance</span><span class="p">]</span> <span class="nl">setBackButtonTitlePositionAdjustment</span><span class="p">:</span><span class="n">UIOffsetMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">100</span><span class="p">)</span> <span class="nl">forBarMetrics</span><span class="p">:</span><span class="n">UIBarMetricsDefault</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>方式3.重写<code>-pushViewController:animated:</code>方法,使用控制器的<code>navigationItem的leftBarButtonItem</code>覆盖返回按钮

<ul>
<li>需要判断是否为根控制器，如果是根控制器就不添加

<ul>
<li>导航控制器的<code>viewControllers.count</code>不为0即表示传入的为非根控制器</li>
</ul>
</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">pushViewController:</span><span class="p">(</span><span class="bp">UIViewController</span> <span class="o">*</span><span class="p">)</span><span class="nv">viewController</span> <span class="nf">animated:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">animated</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">viewControllers</span><span class="p">.</span><span class="n">count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">viewController</span><span class="p">.</span><span class="n">navigationItem</span><span class="p">.</span><span class="n">leftBarButtonItem</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIBarButtonItem</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithImage</span><span class="p">:[</span><span class="bp">UIImage</span> <span class="nl">imageNamed</span><span class="p">:</span><span class="s">@&quot;NavBack&quot;</span><span class="p">]</span> <span class="nl">style</span><span class="p">:</span><span class="n">UIBarButtonItemStyleDone</span> <span class="nl">target</span><span class="p">:</span><span class="nb">self</span> <span class="nl">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">back</span><span class="p">)];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="nb">super</span> <span class="nl">pushViewController</span><span class="p">:</span><span class="n">viewController</span> <span class="nl">animated</span><span class="p">:</span><span class="n">animated</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">back</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="p">[</span><span class="nb">self</span> <span class="nl">popViewControllerAnimated</span><span class="p">:</span><span class="nb">YES</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h6>方案对比</h6>

<ul>
<li>方案1和方案2改动较小，对系统自带的返回功能无影响。<br></li>
<li>方式3灵活性最高，但是会<code>使系统的滑动返回失效</code>，需要自己实现，具体实现参照<a href="https://github.com/forkingdog/FDFullscreenPopGesture">forkingdog全屏手势分类</a><br></li>
<li>方式3还会使按钮更加偏向右边：</li>
</ul>


<p><img src="./images/Snip20150722_10.png" alt="" /><br>
通过以下方式可以使按钮向左边靠：
<img src="./images/Snip20150722_11.png" alt="" /><br>
- 采用customView，<code>添加自己定义的UIButton</code><br></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">...</span>
</span><span class='line'><span class="c1">// 返回按钮内容左靠</span>
</span><span class='line'><span class="n">button</span><span class="p">.</span><span class="n">contentHorizontalAlignment</span> <span class="o">=</span> <span class="n">UIControlContentHorizontalAlignmentLeft</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 让返回按钮内容继续向左边偏移10</span>
</span><span class='line'><span class="n">button</span><span class="p">.</span><span class="n">contentEdgeInsets</span> <span class="o">=</span> <span class="n">UIEdgeInsetsMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">viewController</span><span class="p">.</span><span class="n">navigationItem</span><span class="p">.</span><span class="n">leftBarButtonItem</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIBarButtonItem</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithCustomView</span><span class="p">:</span><span class="n">button</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[runtime应用之关联对象和MethodSwizzling]]></title>
    <link href="http://triplecc.github.io/blog/2015-04-10-runtimeying-yong-zhi-guan-lian-dui-xiang-he-methodswizzling/"/>
    <updated>2015-04-10T14:53:13+08:00</updated>
    <id>http://triplecc.github.io/blog/runtimeying-yong-zhi-guan-lian-dui-xiang-he-methodswizzling</id>
    <content type="html"><![CDATA[<h1>UIView-FDCollapsibleConstraints</h1>

<h2>框架使用效果</h2>

<p><img src="./images/screenshot0.gif" alt="" /><br>
<img src="./images/screenshot1.gif" alt="" /><br></p>

<h2>源代码解析</h2>

<ul>
<li><p>实现思路</p>

<ul>
<li><code>将需要和view关联且需要动态修改的约束添加进一个特定的数组里面</code></li>
<li><code>根据view的内容是否为nil，对特定数组中的约束值进行统一设置</code></li>
</ul>
</li>
<li><p>头文件</p>

<ul>
<li><code>IBOutletCollection</code>表示xib中的相同的控件连接到一个数组中（<a href="http://southpeak.github.io/blog/2015/05/10/ioszhi-shi-xiao-ji-di-%5B%3F%5D-qi-2015-dot-05-dot-10/">介绍链接</a>）

<ul>
<li>这里表示将NSLayoutConstraint控件添加到fd_collapsibleConstraints数组中</li>
<li>IBOutletCollectionh和IBOutlet操作方式一样，需要<code>在IB中进行相应的拖拽</code>才能把对应的控件加到数组中（<code>UIView-&gt;NSLayoutConstraint</code>）</li>
<li>设置了IBOutletCollection之后，当从storybooard或者xib中加载时，根据<code>KVC原理</code>，<code>最终会</code>调用fd_collapsibleConstraints的setter方法，然后就可以在其setter方法中做相应的操作了</li>
</ul>
</li>
<li><code>IBInspectable</code> 表示这个属性可以在IB中更改，如下图
<img src="./images/Snip20150704_1.png" alt="" />

<ul>
<li>还有一个这里没用，<code>IB_DESIGNABLE</code>，这个表示可以在IB中实时显示修改的效果</li>
</ul>
</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="bp">UIView</span> <span class="nl">(FDCollapsibleConstraints)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// Assigning this property immediately disables the view&#39;s collapsible constraints&#39;</span>
</span><span class='line'><span class="c1">/// by setting their constants to zero.</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">fd_collapsed</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// Specify constraints to be affected by &quot;fd_collapsed&quot; property by connecting in</span>
</span><span class='line'><span class="c1">/// Interface Builder.</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">copy</span><span class="p">)</span> <span class="n">IBOutletCollection</span><span class="p">(</span><span class="bp">NSLayoutConstraint</span><span class="p">)</span> <span class="bp">NSArray</span> <span class="o">*</span><span class="n">fd_collapsibleConstraints</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@interface</span> <span class="bp">UIView</span> <span class="nl">(FDAutomaticallyCollapseByIntrinsicContentSize)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// Enable to automatically collapse constraints in &quot;fd_collapsibleConstraints&quot; when</span>
</span><span class='line'><span class="c1">/// you set or indirectly set this view&#39;s &quot;intrinsicContentSize&quot; to {0, 0} or absent.</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// For example:</span>
</span><span class='line'><span class="c1">///  imagesView.images = nil;</span>
</span><span class='line'><span class="c1">///  label.text = nil, label.text = @&quot;&quot;;</span>
</span><span class='line'><span class="c1">///</span>
</span><span class='line'><span class="c1">/// &quot;NO&quot; by default, you may enable it by codes.</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">fd_autoCollapse</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">/// &quot;IBInspectable&quot; property, more friendly to Interface Builder.</span>
</span><span class='line'><span class="c1">/// You gonna find this attribute in &quot;Attribute Inspector&quot;, toggle &quot;On&quot; to enable.</span>
</span><span class='line'><span class="c1">/// Why not a &quot;fd_&quot; prefix? Xcode Attribute Inspector will clip it like a shit.</span>
</span><span class='line'><span class="c1">/// You should not assgin this property directly by code, use &quot;fd_autoCollapse&quot; instead.</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">assign</span><span class="p">,</span> <span class="k">getter</span><span class="o">=</span><span class="n">fd_autoCollapse</span><span class="p">)</span> <span class="n">IBInspectable</span> <span class="kt">BOOL</span> <span class="n">autoCollapse</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>_FDOriginalConstantStorage

<ul>
<li>在这个分类中，给NSLayoutConstraint约束关联一个存储<code>约束初始值</code>的浮点数，以便在修改约束值后，可以还原

<ul>
<li>objc_setAssociatedObject 设置关联对象</li>
<li>objc_getAssociatedObject 获取关联对象</li>
</ul>
</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">/// A stored property extension for NSLayoutConstraint&#39;s original constant.</span>
</span><span class='line'><span class="k">@implementation</span> <span class="bp">NSLayoutConstraint</span> <span class="nl">(_FDOriginalConstantStorage)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 给NSLayoutConstraint关联一个初始约束值</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setFd_originalConstant:</span><span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">originalConstant</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="n">fd_originalConstant</span><span class="p">),</span> <span class="l">@(</span><span class="n">originalConstant</span><span class="l">)</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_RETAIN</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nf">fd_originalConstant</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="cp">#if CGFLOAT_IS_DOUBLE</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">_cmd</span><span class="p">)</span> <span class="n">doubleValue</span><span class="p">];</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">_cmd</span><span class="p">)</span> <span class="n">floatValue</span><span class="p">];</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>FDCollapsibleConstraints

<ul>
<li>实现fd_collapsibleConstraints属性的setter和getter方法 (<code>关联一个存储约束的对象</code>)

<ul>
<li>在<code>getter方法中创建关联对象constraints</code>（和<code>懒加载</code>的方式类似，不过不是创建成员变量）</li>
<li>在<code>setter方法中设置约束的初始值</code>，并<code>添加进关联对象constraints</code>中，方便统一操作</li>
</ul>
</li>
<li>从IB中关联的约束，根据KVC地层原理，最终会调用setFd_collapsibleConstraints:方法，也就是这一步不需要手动调用，系统自己完成（在awakeFromNib之前完成IB这些值的映射）</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="o">-</span> <span class="p">(</span><span class="bp">NSMutableArray</span> <span class="o">*</span><span class="p">)</span><span class="n">fd_collapsibleConstraints</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 获取对象的所有约束关联值</span>
</span><span class='line'>    <span class="bp">NSMutableArray</span> <span class="o">*</span><span class="n">constraints</span> <span class="o">=</span> <span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">_cmd</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">constraints</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">constraints</span> <span class="o">=</span> <span class="l">@[]</span><span class="p">.</span><span class="n">mutableCopy</span><span class="p">;</span>
</span><span class='line'>        <span class="c1">// 设置对象的所有约束关联值</span>
</span><span class='line'>        <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">_cmd</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_RETAIN</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">constraints</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// IBOutletCollection表示xib中的相同的控件连接到一个数组中</span>
</span><span class='line'>  <span class="c1">// 因为设置了IBOutletCollection，所以从xib使用KVC加载时，最终会调用set方法</span>
</span><span class='line'>  <span class="c1">// 然后就来到了这个方法</span>
</span><span class='line'>  <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">setFd_collapsibleConstraints</span><span class="p">:(</span><span class="bp">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="n">fd_collapsibleConstraints</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Hook assignments to our custom `fd_collapsibleConstraints` property.</span>
</span><span class='line'>    <span class="c1">// 返回保存原始约束的数组，使用关联对象</span>
</span><span class='line'>    <span class="bp">NSMutableArray</span> <span class="o">*</span><span class="n">constraints</span> <span class="o">=</span> <span class="p">(</span><span class="bp">NSMutableArray</span> <span class="o">*</span><span class="p">)</span><span class="nb">self</span><span class="p">.</span><span class="n">fd_collapsibleConstraints</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">fd_collapsibleConstraints</span> <span class="nl">enumerateObjectsUsingBlock</span><span class="p">:</span><span class="o">^</span><span class="p">(</span><span class="bp">NSLayoutConstraint</span> <span class="o">*</span><span class="n">constraint</span><span class="p">,</span> <span class="bp">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// Store original constant value</span>
</span><span class='line'>        <span class="c1">// 保存原始的约束</span>
</span><span class='line'>        <span class="n">constraint</span><span class="p">.</span><span class="n">fd_originalConstant</span> <span class="o">=</span> <span class="n">constraint</span><span class="p">.</span><span class="n">constant</span><span class="p">;</span>
</span><span class='line'>        <span class="p">[</span><span class="n">constraints</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">constraint</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>使用Method Swizzling交换自己的和系统的-setValue:forKey:方法

<ul>
<li>实现自己的KVC的-setValue:forKey:方法</li>
<li>Method Swizzling的完全体</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">load</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
</span><span class='line'><span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="kt">Class</span> <span class="k">class</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="k">class</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">SEL</span> <span class="n">origionSel</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="n">viewDidLoad</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">SEL</span> <span class="n">swizzlingSel</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="n">tpc_viewDidLoad</span><span class="p">);</span>
</span><span class='line'>    <span class="c1">//    IMP origionMethod = class_getMethodImplementation(class, origionSel);</span>
</span><span class='line'>    <span class="c1">//    IMP swizzlingMethod = class_getMethodImplementation(class, swizzlingSel);</span>
</span><span class='line'>    <span class="n">Method</span> <span class="n">origionMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="k">class</span><span class="p">,</span> <span class="n">origionSel</span><span class="p">);</span>
</span><span class='line'>    <span class="n">Method</span> <span class="n">swizzlingMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="k">class</span><span class="p">,</span> <span class="n">swizzlingSel</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">BOOL</span> <span class="n">hasAdded</span> <span class="o">=</span> <span class="n">class_addMethod</span><span class="p">(</span><span class="k">class</span><span class="p">,</span> <span class="n">origionSel</span><span class="p">,</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">swizzlingMethod</span><span class="p">),</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">swizzlingMethod</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">hasAdded</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">class_replaceMethod</span><span class="p">(</span><span class="k">class</span><span class="p">,</span> <span class="n">swizzlingSel</span><span class="p">,</span> <span class="n">method_getImplementation</span><span class="p">(</span><span class="n">origionMethod</span><span class="p">),</span> <span class="n">method_getTypeEncoding</span><span class="p">(</span><span class="n">origionMethod</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">method_exchangeImplementations</span><span class="p">(</span><span class="n">origionMethod</span><span class="p">,</span> <span class="n">swizzlingMethod</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">});</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>这一步作者的意思是这种类型的IBOutlet不会触发其setter方法，但是经过测试，注释掉这段代码后，系统还是自己触发了setter方法，说明这种IBOutlet还是可以触发setter方法的。所以，即使没有这一段代码，应该也是可行的<br>
<img src="./images/Snip20150704_8.png" alt="" /><br></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#pragma mark - Hacking KVC</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// load先从原类,再调用分类的开始调用</span>
</span><span class='line'><span class="c1">// 也就是调用的顺序是</span>
</span><span class='line'><span class="c1">// 原类</span>
</span><span class='line'><span class="c1">// FDCollapsibleConstraints</span>
</span><span class='line'><span class="c1">// FDAutomaticallyCollapseByIntrinsicContentSize</span>
</span><span class='line'><span class="c1">// 所以并不冲突</span>
</span><span class='line'>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">load</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">// Swizzle setValue:forKey: to intercept assignments to `fd_collapsibleConstraints`</span>
</span><span class='line'>  <span class="c1">// from Interface Builder. We should not do so by overriding setvalue:forKey:</span>
</span><span class='line'>  <span class="c1">// as the primary class implementation would be bypassed.</span>
</span><span class='line'>  <span class="kt">SEL</span> <span class="n">originalSelector</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="nl">setValue</span><span class="p">:</span><span class="nl">forKey</span><span class="p">:);</span>
</span><span class='line'>  <span class="kt">SEL</span> <span class="n">swizzledSelector</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="nl">fd_setValue</span><span class="p">:</span><span class="nl">forKey</span><span class="p">:);</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">Class</span> <span class="k">class</span> <span class="o">=</span> <span class="bp">UIView</span><span class="p">.</span><span class="k">class</span><span class="p">;</span>
</span><span class='line'>  <span class="n">Method</span> <span class="n">originalMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="k">class</span><span class="p">,</span> <span class="n">originalSelector</span><span class="p">);</span>
</span><span class='line'>  <span class="n">Method</span> <span class="n">swizzledMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="k">class</span><span class="p">,</span> <span class="n">swizzledSelector</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">method_exchangeImplementations</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">,</span> <span class="n">swizzledMethod</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">// xib也就是xml，再加载进行decode时，会调用setValue:forKey:，把他的方法替换成自身的，然后获取添加的约束</span>
</span><span class='line'><span class="c1">// 不使用重写这个KVC方法的方式，是因为这样会覆盖view本身在这个方法中进行的操作</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">fd_setValue:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">value</span> <span class="nf">forKey:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">key</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="bp">NSString</span> <span class="o">*</span><span class="n">injectedKey</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithUTF8String</span><span class="p">:</span><span class="n">sel_getName</span><span class="p">(</span><span class="k">@selector</span><span class="p">(</span><span class="n">fd_collapsibleConstraints</span><span class="p">))];</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">([</span><span class="n">key</span> <span class="nl">isEqualToString</span><span class="p">:</span><span class="n">injectedKey</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// This kind of IBOutlet won&#39;t trigger property&#39;s setter, so we forward it.</span>
</span><span class='line'>      <span class="c1">// 作者的意思是，IBOutletCollection不会触发对应属性的setter方法，所以这里执行手动调用</span>
</span><span class='line'>      <span class="nb">self</span><span class="p">.</span><span class="n">fd_collapsibleConstraints</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// Forward the rest of KVC&#39;s to original implementation.</span>
</span><span class='line'>      <span class="p">[</span><span class="nb">self</span> <span class="nl">fd_setValue</span><span class="p">:</span><span class="n">value</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">key</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>设置对应的约束值

<ul>
<li>注意，这里只要传入的是YES，那么，这个UIView对应的存入<code>constraints关联对象的所有约束</code>，都会置为0</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#pragma mark - Dynamic Properties</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setFd_collapsed:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">collapsed</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">fd_collapsibleConstraints</span> <span class="nl">enumerateObjectsUsingBlock</span><span class="p">:</span>
</span><span class='line'> <span class="o">^</span><span class="p">(</span><span class="bp">NSLayoutConstraint</span> <span class="o">*</span><span class="n">constraint</span><span class="p">,</span> <span class="bp">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="k">if</span> <span class="p">(</span><span class="n">collapsed</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>         <span class="c1">// 如果view的内容为nil，则将view关联的constraints对象所有值设置为0</span>
</span><span class='line'>         <span class="n">constraint</span><span class="p">.</span><span class="n">constant</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 如果view的内容不为nil，则将view关联的constraints对象所有值返回成原值</span>
</span><span class='line'>         <span class="n">constraint</span><span class="p">.</span><span class="n">constant</span> <span class="o">=</span> <span class="n">constraint</span><span class="p">.</span><span class="n">fd_originalConstant</span><span class="p">;</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'> <span class="p">}];</span>
</span><span class='line'>    <span class="c1">// 设置fd_collapsed关联对象，供自动collapsed使用</span>
</span><span class='line'>  <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="n">fd_collapsed</span><span class="p">),</span> <span class="l">@(</span><span class="n">collapsed</span><span class="l">)</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_RETAIN</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">fd_collapsedFDAutomaticallyCollapseByIntrinsicContentSize</span><span class="p">{</span>
</span><span class='line'><span class="k">return</span> <span class="p">[</span><span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">_cmd</span><span class="p">)</span> <span class="n">boolValue</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>FDAutomaticallyCollapseByIntrinsicContentSize

<ul>
<li>使用Method Swizzling交换自己的和系统的-fd_updateConstraints方法</li>
<li>[self fd_updateConstraints]调用的是self的updateConstraints方法，fd_updateConstraints和updateConstraints方法的Method（映射SEL和IMP）已经调换了</li>
<li><code>intrinsicContentSize(控件的内置大小)</code>默认为UIViewNoIntrinsicMetric，当<code>控件中没有内容时</code>，调用intrinsicContentSize返回的即为<code>默认值</code>（<a href="http://www.mgenware.com/blog/?p=491">介绍链接</a>）</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="cp">#pragma mark - Hacking &quot;-updateConstraints&quot;</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">load</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Swizzle to hack &quot;-updateConstraints&quot; method</span>
</span><span class='line'>    <span class="kt">SEL</span> <span class="n">originalSelector</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="n">updateConstraints</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">SEL</span> <span class="n">swizzledSelector</span> <span class="o">=</span> <span class="k">@selector</span><span class="p">(</span><span class="n">fd_updateConstraints</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">Class</span> <span class="k">class</span> <span class="o">=</span> <span class="bp">UIView</span><span class="p">.</span><span class="k">class</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Method</span> <span class="n">originalMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="k">class</span><span class="p">,</span> <span class="n">originalSelector</span><span class="p">);</span>
</span><span class='line'>    <span class="n">Method</span> <span class="n">swizzledMethod</span> <span class="o">=</span> <span class="n">class_getInstanceMethod</span><span class="p">(</span><span class="k">class</span><span class="p">,</span> <span class="n">swizzledSelector</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">method_exchangeImplementations</span><span class="p">(</span><span class="n">originalMethod</span><span class="p">,</span> <span class="n">swizzledMethod</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">fd_updateConstraints</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Call primary method&#39;s implementation</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="n">fd_updateConstraints</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">fd_autoCollapse</span> <span class="o">&amp;&amp;</span> <span class="nb">self</span><span class="p">.</span><span class="n">fd_collapsibleConstraints</span><span class="p">.</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// &quot;Absent&quot; means this view doesn&#39;t have an intrinsic content size, {-1, -1} actually.</span>
</span><span class='line'>        <span class="k">const</span> <span class="bp">CGSize</span> <span class="n">absentIntrinsicContentSize</span> <span class="o">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="n">UIViewNoIntrinsicMetric</span><span class="p">,</span> <span class="n">UIViewNoIntrinsicMetric</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 当设置控件显示内容为nil时，计算出来的contentSize和上面的相等</span>
</span><span class='line'>        <span class="c1">// Calculated intrinsic content size</span>
</span><span class='line'>        <span class="k">const</span> <span class="bp">CGSize</span> <span class="n">contentSize</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">intrinsicContentSize</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// When this view doesn&#39;t have one, or has no intrinsic content size after calculating,</span>
</span><span class='line'>        <span class="c1">// it going to be collapsed.</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">CGSizeEqualToSize</span><span class="p">(</span><span class="n">contentSize</span><span class="p">,</span> <span class="n">absentIntrinsicContentSize</span><span class="p">)</span> <span class="o">||</span>
</span><span class='line'>            <span class="n">CGSizeEqualToSize</span><span class="p">(</span><span class="n">contentSize</span><span class="p">,</span> <span class="n">CGSizeZero</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// 当控件没有内容时，则设置控件关联对象constraints的所有约束值为0</span>
</span><span class='line'>            <span class="nb">self</span><span class="p">.</span><span class="n">fd_collapsed</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>          <span class="c1">// 当控件有内容时，则设置控件关联对象constraints的所有约束值返回为原值</span>
</span><span class='line'>            <span class="nb">self</span><span class="p">.</span><span class="n">fd_collapsed</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>设置一些动态属性（关联对象）</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="cp">#pragma mark - Dynamic Properties</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="n">fd_autoCollapse</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">objc_getAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="n">_cmd</span><span class="p">)</span> <span class="n">boolValue</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">setFd_autoCollapse</span><span class="p">:(</span><span class="kt">BOOL</span><span class="p">)</span><span class="n">autoCollapse</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">objc_setAssociatedObject</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="k">@selector</span><span class="p">(</span><span class="n">fd_autoCollapse</span><span class="p">),</span> <span class="l">@(</span><span class="n">autoCollapse</span><span class="l">)</span><span class="p">,</span> <span class="n">OBJC_ASSOCIATION_RETAIN</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">setAutoCollapse</span><span class="p">:(</span><span class="kt">BOOL</span><span class="p">)</span><span class="n">collapse</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// Just forwarding</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">fd_autoCollapse</span> <span class="o">=</span> <span class="n">collapse</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Block技巧与底层解析]]></title>
    <link href="http://triplecc.github.io/blog/2015-02-10-blockji-qiao-yu-di-ceng-jie-xi/"/>
    <updated>2015-02-10T20:17:10+08:00</updated>
    <id>http://triplecc.github.io/blog/blockji-qiao-yu-di-ceng-jie-xi</id>
    <content type="html"><![CDATA[<h1>目录</h1>

<ul>
<li>Block底层解析

<ul>
<li>什么是block？

<ul>
<li>block编译转换结构</li>
<li>block实际结构</li>
</ul>
</li>
<li>block的类型

<ul>
<li>NSConcreteGlobalBlock和NSConcreteStackBlock</li>
<li>NSConcreteMallocBlock</li>
</ul>
</li>
<li>捕捉变量对block结构的影响

<ul>
<li>局部变量</li>
<li>全局变量</li>
<li>局部静态变量</li>
<li>__block修饰的变量</li>
<li>self隐式循环引用</li>
</ul>
</li>
<li>不同类型block的复制

<ul>
<li>栈block</li>
<li>堆block</li>
<li>全局block</li>
</ul>
</li>
<li>block辅助函数

<ul>
<li>__block修饰的基本类型的辅助函数</li>
<li>对象的辅助函数</li>
</ul>
</li>
<li>ARC中block的工作

<ul>
<li>block试验</li>
<li>block作为参数传递</li>
<li>block作为返回值</li>
<li>block属性</li>
</ul>
</li>
</ul>
</li>
<li>参考博文</li>
</ul>


<h1>Block底层解析</h1>

<p>最近看了一些block的资料，并动手做了一些实践，摘录并添加了一些结论。</p>

<h2>什么是block？</h2>

<p>首先，看一个极简的block：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="o">^</span><span class="p">{</span> <span class="p">};</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h6>block编译转换结构</h6>

<p>对其执行<code>clang -rewrite-objc</code>编译转换成C++实现，得到以下代码：<br></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">__block_impl</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">void</span> <span class="o">*</span><span class="n">isa</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">Flags</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">Reserved</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="o">*</span><span class="n">FuncPtr</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__main_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
</span><span class='line'>  <span class="n">__main_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="n">__main_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="p">)};</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="cm">/* @autoreleasepool */</span> <span class="p">{</span> <span class="n">__AtAutoreleasePool</span> <span class="n">__autoreleasepool</span><span class="p">;</span>
</span><span class='line'>        <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>不难看出其中的<code>__main_block_impl_0</code>就是block的一个C++的实现(最后面的<code>_0</code>代表是main中的第几个block)，也就是说也是一个<code>结构体</code>。<br>
其中<code>__block_impl</code>的定义如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">__block_impl</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">isa</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">Flags</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">Reserved</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">FuncPtr</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>其结构体成员如下：</p>

<ul>
<li>isa，指向所属类的指针，也就是block的类型</li>
<li>flags，标志变量，在实现block的内部操作时会用到</li>
<li>Reserved，保留变量</li>
<li>FuncPtr，block执行时调用的函数指针
可以看出，它包含了isa指针（包含isa指针的皆为对象），也就是说block也是一个<code>对象</code>(runtime里面，对象和类都是用结构体表示)。<br></li>
</ul>


<p><code>__main_block_desc_0</code>的定义如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="n">__main_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="p">)};</span>
</span></code></pre></td></tr></table></div></figure>


<p>其结构成员含义如下：</p>

<ul>
<li>reserved：保留字段</li>
<li>Block_size：block大小(sizeof(struct __main_block_impl_0))</li>
</ul>


<p>以上代码在定义<code>__main_block_desc_0</code>结构体时，同时创建了<code>__main_block_desc_0_DATA</code>，并给它赋值，以供在<code>main</code>函数中对<code>__main_block_impl_0</code>进行初始化。
<code>__main_block_impl_0</code>定义了显式的构造函数，其函数体如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="n">__main_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看出，</p>

<ul>
<li><code>__main_block_impl_0</code>的<code>isa</code>指针指向了<code>_NSConcreteStackBlock</code>，</li>
<li>从<code>main</code>函数中看， <code>__main_block_impl_0</code>的<code>FuncPtr</code>指向了函数<code>__main_block_func_0</code></li>
<li><code>__main_block_impl_0</code>的<code>Desc</code>也指向了定义<code>__main_block_desc_0</code>时就创建的<code>__main_block_desc_0_DATA</code>，其中纪录了block结构体大小等信息。</li>
</ul>


<p>以上就是根据编译转换的结果，对一个简单block的解析，后面会将block操作<code>不同类型的外部变量</code>，对block结构的影响进行相应的说明。<br></p>

<h6>block实际结构</h6>

<p>接下来观察下<code>Block_private.h</code>文件中对block的相关结构体的真实定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cm">/* Revised new layout. */</span>
</span><span class='line'><span class="k">struct</span> <span class="n">Block_descriptor</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">reserved</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="k">copy</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dispose</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">Block_layout</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">void</span> <span class="o">*</span><span class="n">isa</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">reserved</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">invoke</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="p">...);</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">Block_descriptor</span> <span class="o">*</span><span class="n">descriptor</span><span class="p">;</span>
</span><span class='line'>    <span class="cm">/* Imported variables. */</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>有了上文对编译转换的分析，这里只针对略微不同的成员进行分析：</p>

<ul>
<li>invoke，同上文的FuncPtr，block执行时调用的函数指针，block定义时内部的执行代码都在这个函数中<br></li>
<li>Block_descriptor，block的详细描述<br>

<ul>
<li>copy/dispose，辅助拷贝/销毁函数，处理block范围外的变量时使用</li>
</ul>
</li>
</ul>


<p>总体来说，block就是一个里面存储了指向<code>函数体中包含定义block时的代码块</code>的函数指针，以及<code>block外部上下文</code>变量等信息的结构体。</p>

<h2>block的类型</h2>

<p>block的常见类型有3种：</p>

<ul>
<li>_NSConcreteGlobalBlock（全局）</li>
<li>_NSConcreteStackBlock（栈）</li>
<li>_NSConcreteMallocBlock（堆）</li>
</ul>


<p>附上APUE的进程虚拟内存段分布图：<br>
<img src="./images/Snip20150720_3.png" alt="" /></p>

<p>其中前2种在<code>Block.h</code>种声明，后1种在<code>Block_private.h</code>中声明，所以最后1种基本不会在源码中出现。<br>
由于无法直接创建<code>_NSConcreteMallocBlock</code>类型的block，所以这里只对前面2种进行手动创建分析，最后1种通过源代码分析。<br></p>

<h6>NSConcreteGlobalBlock和NSConcreteStackBlock</h6>

<p>首先，根据前面两种类型，编写以下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">globalBlock</span><span class="p">)()</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">stackBlock1</span><span class="p">)()</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">};</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对其进行编译转换后得到以下缩略代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// globalBlock</span>
</span><span class='line'><span class="k">struct</span> <span class="n">__globalBlock_block_impl_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__globalBlock_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
</span><span class='line'>  <span class="n">__globalBlock_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__globalBlock_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteGlobalBlock</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// stackBlock</span>
</span><span class='line'><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__main_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
</span><span class='line'>  <span class="n">__main_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="cm">/* @autoreleasepool */</span> <span class="p">{</span> <span class="n">__AtAutoreleasePool</span> <span class="n">__autoreleasepool</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">stackBlock</span><span class="p">)()</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看出<code>globalBlock</code>的isa指向了<code>_NSConcreteGlobalBlock</code>，即在全局区域创建，编译时就已经确定了，位于上图中的代码段；<code>stackBlock</code>的isa指向了<code>_NSConcreteStackBlock</code>，即在栈区创建。<br></p>

<h6>NSConcreteMallocBlock</h6>

<p>接下来是在堆中的block，堆中的block无法直接创建，其需要由<code>_NSConcreteStackBlock</code>类型的block拷贝而来(也就是说<code>block需要执行copy之后才能存放到堆中</code>)。由于block的拷贝最终都会调用<code>_Block_copy_internal</code>函数，所以观察这个函数就可以知道堆中block是如何被创建的了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">_Block_copy_internal</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">Block_layout</span> <span class="o">*</span><span class="n">aBlock</span><span class="p">;</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>    <span class="n">aBlock</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Block_layout</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>    <span class="c1">// Its a stack block.  Make a copy.</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isGC</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// 申请block的堆内存</span>
</span><span class='line'>        <span class="k">struct</span> <span class="n">Block_layout</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span> <span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="c1">// 拷贝栈中block到刚申请的堆内存中</span>
</span><span class='line'>        <span class="n">memmove</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">aBlock</span><span class="p">,</span> <span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span> <span class="c1">// bitcopy first</span>
</span><span class='line'>        <span class="c1">// reset refcount</span>
</span><span class='line'>        <span class="n">result</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">BLOCK_REFCOUNT_MASK</span><span class="p">);</span>    <span class="c1">// XXX not needed</span>
</span><span class='line'>        <span class="n">result</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BLOCK_NEEDS_FREE</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="c1">// 改变isa指向_NSConcreteMallocBlock，即堆block类型</span>
</span><span class='line'>        <span class="n">result</span><span class="o">-&gt;</span><span class="n">isa</span> <span class="o">=</span> <span class="n">_NSConcreteMallocBlock</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_HAS_COPY_DISPOSE</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">//printf(&quot;calling block copy helper %p(%p, %p)...\n&quot;, aBlock-&gt;descriptor-&gt;copy, result, aBlock);</span>
</span><span class='line'>            <span class="p">(</span><span class="o">*</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="k">copy</span><span class="p">)(</span><span class="n">result</span><span class="p">,</span> <span class="n">aBlock</span><span class="p">);</span> <span class="c1">// do fixup</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">...</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从以上代码以及注释可以很清楚的看出，函数通过<code>memmove</code>将栈中的block的内容拷贝到了堆中，并使isa指向了<code>_NSConcreteMallocBlock</code>。<br>
block主要的一些学问就出在栈中block向堆中block的转移过程中了。</p>

<h2>捕捉变量对block结构的影响</h2>

<p>接下来会编译转换捕捉不同变量类型的block，以对比它们的区别。</p>

<h6>局部变量</h6>

<p>前：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">test</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>    <span class="o">^</span><span class="p">{</span><span class="n">a</span><span class="p">;};</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>后：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__Person__test_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// a(_a)是构造函数的参数列表初始化形式，相当于a = _a。从_I_Person_test看，传入的就是a</span>
</span><span class='line'>  <span class="n">__Person__test_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__Person__test_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">_a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">a</span><span class="p">(</span><span class="n">_a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__Person__test_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span> <span class="c1">// bound by copy</span>
</span><span class='line'><span class="n">a</span><span class="p">;}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="k">struct</span> <span class="n">__Person__test_block_desc_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="n">__Person__test_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span><span class="p">)};</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">_I_Person_test</span><span class="p">(</span><span class="n">Person</span> <span class="o">*</span> <span class="nb">self</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">_cmd</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>    <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__Person__test_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__Person__test_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__Person__test_block_desc_0_DATA</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，block相对于文章开头增加了一个int类型的成员变量，他就是用来存储外部变量a的。可以看出，这次拷贝只是一次<code>值传递</code>。并且当我们想在block中进行以下操作时，将会发生错误</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="o">^</span><span class="p">{</span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;};</span>
</span></code></pre></td></tr></table></div></figure>


<p>编译器会提示<img src="./image/Snip20150720_1.png" alt="" />。因为_I_Person_test函数中的a和<strong>Person</strong>test_block_func_0函数中的a并没有在同一个作用域，所以在block对a进行赋值是没有意义的，所以编译器给出了错误。我们可以通过地址传递来消除以上错误：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">test</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// 利用指针p存储a的地址</span>
</span><span class='line'>    <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="c1">// 通过a的地址设置a的值</span>
</span><span class='line'>        <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是变量a的生命周期是和方法test的栈相关联的，当test运行结束，栈随之销毁，那么变量a就会被销毁，p也就成为了野指针。如果block是作为参数或者返回值，这些类型都是跨栈的，也就是说再次调用会造成野指针错误。</p>

<h6>全局变量</h6>

<p>前：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 全局静态</span>
</span><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 全局</span>
</span><span class='line'><span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">test</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>        <span class="n">b</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>后：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__Person__test_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
</span><span class='line'>  <span class="n">__Person__test_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__Person__test_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__Person__test_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>        <span class="n">b</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="k">struct</span> <span class="n">__Person__test_block_desc_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="n">__Person__test_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span><span class="p">)};</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">_I_Person_test</span><span class="p">(</span><span class="n">Person</span> <span class="o">*</span> <span class="nb">self</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">_cmd</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__Person__test_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__Person__test_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__Person__test_block_desc_0_DATA</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看出，因为全局变量都是在<code>静态数据存储区</code>，在程序结束前不会被销毁，所以block直接访问了对应的变量，而没有在<strong>Person</strong>test_block_impl_0结构体中给变量预留位置。</p>

<h6>局部静态变量</h6>

<p>前</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">test</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>    <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>后：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__Person__test_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
</span><span class='line'>  <span class="n">__Person__test_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__Person__test_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">_a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">a</span><span class="p">(</span><span class="n">_a</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__Person__test_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span> <span class="c1">// bound by copy</span>
</span><span class='line'>      <span class="c1">// 这里通过局部静态变量a的地址来对其进行修改</span>
</span><span class='line'>        <span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="k">struct</span> <span class="n">__Person__test_block_desc_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="n">__Person__test_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span><span class="p">)};</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">_I_Person_test</span><span class="p">(</span><span class="n">Person</span> <span class="o">*</span> <span class="nb">self</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">_cmd</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">static</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// 传入a的地址</span>
</span><span class='line'>    <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__Person__test_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__Person__test_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__Person__test_block_desc_0_DATA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意一点的是静态局部变量是存储在静态数据存储区域的，也就是和程序拥有一样的<code>生命周期</code>，也就是说在程序运行时，都能够保证block访问到一个有效的变量。但是其<code>作用范围</code>还是局限于定义它的函数中，所以只能在block通过静态局部变量的<code>地址</code>来进行访问。<br>
关于变量的存储我原来的这篇博客有提及：<a href="http://blog.csdn.net/triplecc/article/details/24808417">c语言臆想&ndash;全局&mdash;局部变量</a></p>

<h6>__block修饰的变量</h6>

<p>前：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">test</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="k">__block</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>    <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>后：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">__Block_byref_a_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">__isa</span><span class="p">;</span>
</span><span class='line'><span class="n">__Block_byref_a_0</span> <span class="o">*</span><span class="n">__forwarding</span><span class="p">;</span>
</span><span class='line'> <span class="kt">int</span> <span class="n">__flags</span><span class="p">;</span>
</span><span class='line'> <span class="kt">int</span> <span class="n">__size</span><span class="p">;</span>
</span><span class='line'> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__Person__test_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
</span><span class='line'>  <span class="n">__Block_byref_a_0</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span> <span class="c1">// by ref</span>
</span><span class='line'>  <span class="n">__Person__test_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__Person__test_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">__Block_byref_a_0</span> <span class="o">*</span><span class="n">_a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">a</span><span class="p">(</span><span class="n">_a</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__Person__test_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">__Block_byref_a_0</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span> <span class="c1">// bound by ref</span>
</span><span class='line'>      <span class="c1">// 注意，这里的_forwarding用来保证操作的始终是堆中的拷贝a，而不是栈中的a</span>
</span><span class='line'>        <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">)</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__Person__test_block_copy_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span><span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span><span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="mi">8</span><span class="cm">/*BLOCK_FIELD_IS_BYREF*/</span><span class="p">);}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__Person__test_block_dispose_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span><span class="n">_Block_object_dispose</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="mi">8</span><span class="cm">/*BLOCK_FIELD_IS_BYREF*/</span><span class="p">);}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="k">struct</span> <span class="n">__Person__test_block_desc_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="k">copy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span><span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dispose</span><span class="p">)(</span><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span> <span class="n">__Person__test_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span><span class="p">),</span> <span class="n">__Person__test_block_copy_0</span><span class="p">,</span> <span class="n">__Person__test_block_dispose_0</span><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">_I_Person_test</span><span class="p">(</span><span class="n">Person</span> <span class="o">*</span> <span class="nb">self</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">_cmd</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// __block将a包装成了一个对象</span>
</span><span class='line'>   <span class="n">__attribute__</span><span class="p">((</span><span class="n">__blocks__</span><span class="p">(</span><span class="n">byref</span><span class="p">)))</span> <span class="n">__Block_byref_a_0</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,(</span><span class="n">__Block_byref_a_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__Block_byref_a_0</span><span class="p">)};</span>
</span><span class='line'><span class="p">;</span>
</span><span class='line'>    <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__Person__test_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__Person__test_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__Person__test_block_desc_0_DATA</span><span class="p">,</span> <span class="p">(</span><span class="n">__Block_byref_a_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">570425344</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，对比上面的结果，明显多了<code>__Block_byref_a_0</code>结构体，这个结构体中含有<code>isa</code>指针，所以也是一个对象，它是用来包装局部变量a的。当block被copy到堆中时，<code>__Person__test_block_impl_0</code>的拷贝辅助函数<code>__Person__test_block_copy_0</code>会将<code>__Block_byref_a_0</code>拷贝至堆中，所以即使局部变量所在堆被销毁，block依然能对堆中的局部变量进行操作。其中<code>__Block_byref_a_0</code>成员指针<code>__forwarding</code>用来指向它在堆中的拷贝，其依据源码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">_Block_byref_assign_copy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">**</span><span class="n">destp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">**</span><span class="p">)</span><span class="n">dest</span><span class="p">;</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="c1">// 堆中拷贝的forwarding指向它自己</span>
</span><span class='line'>    <span class="k">copy</span><span class="o">-&gt;</span><span class="n">forwarding</span> <span class="o">=</span> <span class="k">copy</span><span class="p">;</span> <span class="c1">// patch heap copy to point to itself (skip write-barrier)</span>
</span><span class='line'>    <span class="c1">// 栈中的forwarding指向堆中的拷贝</span>
</span><span class='line'>    <span class="n">src</span><span class="o">-&gt;</span><span class="n">forwarding</span> <span class="o">=</span> <span class="k">copy</span><span class="p">;</span>  <span class="c1">// patch stack to point to heap copy</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样做是为了保证操作的值始终是堆中的拷贝，而不是栈中的值。（处理在局部变量所在栈还没销毁，就调用block来改变局部变量值的情况，如果没有__forwarding指针，则修改无效）<br>
至于block如何实现对局部变量的拷贝，下面会详细说明。</p>

<h6>self隐式循环引用</h6>

<p>前：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">Person</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">_a</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">_block</span><span class="p">)();</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">test</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">_block</span><span class="p">)()</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">_a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>后：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__Person__test_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// 可以看到，block强引用了self</span>
</span><span class='line'>  <span class="n">Person</span> <span class="o">*</span><span class="nb">self</span><span class="p">;</span>
</span><span class='line'>  <span class="n">__Person__test_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__Person__test_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">Person</span> <span class="o">*</span><span class="n">_self</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="nb">self</span><span class="p">(</span><span class="n">_self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__Person__test_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">Person</span> <span class="o">*</span><span class="nb">self</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="nb">self</span><span class="p">;</span> <span class="c1">// bound by copy</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="nb">self</span> <span class="o">+</span> <span class="n">OBJC_IVAR_</span><span class="err">$</span><span class="n">_Person</span><span class="err">$</span><span class="n">_a</span><span class="p">))</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__Person__test_block_copy_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span><span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span><span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="nb">self</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="nb">self</span><span class="p">,</span> <span class="mi">3</span><span class="cm">/*BLOCK_FIELD_IS_OBJECT*/</span><span class="p">);}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__Person__test_block_dispose_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span><span class="n">_Block_object_dispose</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="nb">self</span><span class="p">,</span> <span class="mi">3</span><span class="cm">/*BLOCK_FIELD_IS_OBJECT*/</span><span class="p">);}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="k">struct</span> <span class="n">__Person__test_block_desc_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="k">copy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span><span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dispose</span><span class="p">)(</span><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span> <span class="n">__Person__test_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span><span class="p">),</span> <span class="n">__Person__test_block_copy_0</span><span class="p">,</span> <span class="n">__Person__test_block_dispose_0</span><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">_I_Person_test</span><span class="p">(</span><span class="n">Person</span> <span class="o">*</span> <span class="nb">self</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">_cmd</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">_block</span><span class="p">)()</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__Person__test_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__Person__test_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__Person__test_block_desc_0_DATA</span><span class="p">,</span> <span class="nb">self</span><span class="p">,</span> <span class="mi">570425344</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果在编译转换前，将<code>_a</code>改成<code>self.a</code>，能很明显地看出是产生了循环引用(self强引用block，block强引用self)。那么使用<code>_a</code>呢？经过编译转换后，依然可以在<code>__Person__test_block_impl_0</code>看见<code>self</code>的身影。且在函数<code>_I_Person_test</code>中，传入的参数也是<code>self</code>。通过以下语句，可以看出，不管是用什么形式访问实例变量，最终都会转换成<code>self+变量内存偏移的形式</code>。所以在上面例子中使用<code>_a</code>也会造成循环引用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__Person__test_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__Person__test_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">Person</span> <span class="o">*</span><span class="nb">self</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="nb">self</span><span class="p">;</span> <span class="c1">// bound by copy</span>
</span><span class='line'>      <span class="c1">// self＋实例变量a的偏移值</span>
</span><span class='line'>        <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="nb">self</span> <span class="o">+</span> <span class="n">OBJC_IVAR_</span><span class="err">$</span><span class="n">_Person</span><span class="err">$</span><span class="n">_a</span><span class="p">))</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>不同类型block的复制</h2>

<p><code>block</code>的复制代码在<code>_Block_copy_internal</code>函数中。</p>

<h6>栈block</h6>

<p>从以下代码可以看出，栈block的复制不仅仅复制了其内容，还添加了一些额外的东西</p>

<ul>
<li> 1、往flags中并入了<code>BLOCK_NEEDS_FREE</code>（这个标志表明block需要释放，在<code>release</code>以及<code>再次拷贝</code>时会用到）</li>
<li>2、如果有辅助copy函数（<code>BLOCK_HAS_COPY_DISPOSE</code>），那么就调用（这个辅助copy函数是用来<code>拷贝block捕获的变量</code>的）</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">Block_layout</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span> <span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
</span><span class='line'>        <span class="n">memmove</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">aBlock</span><span class="p">,</span> <span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span> <span class="c1">// bitcopy first</span>
</span><span class='line'>        <span class="c1">// reset refcount</span>
</span><span class='line'>        <span class="n">result</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">BLOCK_REFCOUNT_MASK</span><span class="p">);</span>    <span class="c1">// XXX not needed</span>
</span><span class='line'>        <span class="n">result</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BLOCK_NEEDS_FREE</span> <span class="o">|</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>        <span class="n">result</span><span class="o">-&gt;</span><span class="n">isa</span> <span class="o">=</span> <span class="n">_NSConcreteMallocBlock</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_HAS_COPY_DISPOSE</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">//printf(&quot;calling block copy helper %p(%p, %p)...\n&quot;, aBlock-&gt;descriptor-&gt;copy, result, aBlock);</span>
</span><span class='line'>            <span class="p">(</span><span class="o">*</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">descriptor</span><span class="o">-&gt;</span><span class="k">copy</span><span class="p">)(</span><span class="n">result</span><span class="p">,</span> <span class="n">aBlock</span><span class="p">);</span> <span class="c1">// do fixup</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'>  <span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<h6>堆block</h6>

<p>从以下代码看出，如果block的flags中有<code>BLOCK_NEEDS_FREE</code>标志（block从栈中拷贝到堆时添加的标志），就执行<code>latching_incr_int</code>操作，其功能就是让block的引用计数加1。所以堆中block的拷贝只是单纯地改变了引用计数</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_NEEDS_FREE</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// latches on high</span>
</span><span class='line'>        <span class="n">latching_incr_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">aBlock</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<h6>全局block</h6>

<p>从以下代码看出，对于全局block，函数没有做任何操作，直接返回了传入的block</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="p">...</span>
</span><span class='line'>  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">aBlock</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_IS_GLOBAL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">aBlock</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<h2>block辅助函数</h2>

<p>上文提及到了block辅助copy与dispose处理函数，这里分析下这两个函数的内部实现。在捕获变量为<code>__block</code>修饰的<code>基本类型</code>，或者为<code>对象</code>时，block才会有这两个辅助函数。<br>
block<code>捕捉变量</code>拷贝函数为<code>_Block_object_assign</code>。在调用复制block的函数_Block_copy_internal时，会根据block有无辅助函数来对<code>捕捉变量</code>拷贝函数<code>_Block_object_assign</code>进行调用。而在<code>_Block_object_assign</code>函数中，也会判断<code>捕捉变量</code>包装而成的对象(Block_byref结构体)是否有辅助函数，来进行调用。</p>

<h6><code>__block</code>修饰的基本类型的辅助函数</h6>

<p>编写以下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span><span class="o">^</span><span class="n">Block</span><span class="p">)();</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">__block</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'>        <span class="n">Block</span> <span class="n">block</span> <span class="o">=</span> <span class="o">^</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">a</span><span class="p">;</span>
</span><span class='line'>        <span class="p">};</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>转换成C++代码后：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span><span class="o">*</span><span class="n">Block</span><span class="p">)();</span>
</span><span class='line'><span class="c1">// __block int a</span>
</span><span class='line'><span class="k">struct</span> <span class="n">__Block_byref_a_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">__isa</span><span class="p">;</span>
</span><span class='line'><span class="n">__Block_byref_a_0</span> <span class="o">*</span><span class="n">__forwarding</span><span class="p">;</span>
</span><span class='line'> <span class="kt">int</span> <span class="n">__flags</span><span class="p">;</span>
</span><span class='line'> <span class="kt">int</span> <span class="n">__size</span><span class="p">;</span>
</span><span class='line'> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// block</span>
</span><span class='line'><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__block_impl</span> <span class="n">impl</span><span class="p">;</span>
</span><span class='line'>  <span class="k">struct</span> <span class="n">__main_block_desc_0</span><span class="o">*</span> <span class="n">Desc</span><span class="p">;</span>
</span><span class='line'>  <span class="n">__Block_byref_a_0</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span> <span class="c1">// by ref</span>
</span><span class='line'>  <span class="n">__main_block_impl_0</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="n">__Block_byref_a_0</span> <span class="o">*</span><span class="n">_a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">:</span> <span class="n">a</span><span class="p">(</span><span class="n">_a</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">isa</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">_NSConcreteStackBlock</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">Flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>    <span class="n">impl</span><span class="p">.</span><span class="n">FuncPtr</span> <span class="o">=</span> <span class="n">fp</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Desc</span> <span class="o">=</span> <span class="n">desc</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// block函数体</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">__Block_byref_a_0</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span> <span class="c1">// bound by ref</span>
</span><span class='line'>
</span><span class='line'>            <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">__forwarding</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="c1">// 辅助copy函数</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_copy_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span><span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="mi">8</span><span class="cm">/*BLOCK_FIELD_IS_BYREF*/</span><span class="p">);}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 辅助dispose函数</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_dispose_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span><span class="n">_Block_object_dispose</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="mi">8</span><span class="cm">/*BLOCK_FIELD_IS_BYREF*/</span><span class="p">);}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="k">copy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dispose</span><span class="p">)(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span> <span class="n">__main_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="p">),</span> <span class="n">__main_block_copy_0</span><span class="p">,</span> <span class="n">__main_block_dispose_0</span><span class="p">};</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="cm">/* @autoreleasepool */</span> <span class="p">{</span> <span class="n">__AtAutoreleasePool</span> <span class="n">__autoreleasepool</span><span class="p">;</span>
</span><span class='line'>      <span class="c1">// 这里创建了，并将a的flags设置为0</span>
</span><span class='line'>        <span class="n">__attribute__</span><span class="p">((</span><span class="n">__blocks__</span><span class="p">(</span><span class="n">byref</span><span class="p">)))</span> <span class="n">__Block_byref_a_0</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,(</span><span class="n">__Block_byref_a_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__Block_byref_a_0</span><span class="p">)};</span>
</span><span class='line'><span class="p">;</span>
</span><span class='line'>        <span class="n">Block</span> <span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">,</span> <span class="p">(</span><span class="n">__Block_byref_a_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">570425344</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从上面代码中，被<code>__block</code>修饰的a变量变为了<code>__Block_byref_a_0</code>类型，根据这个格式，从源码中查看得到相似的定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">Block_byref</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">void</span> <span class="o">*</span><span class="n">isa</span><span class="p">;</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="n">forwarding</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* refcount; */</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">byref_keep</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="n">src</span><span class="p">);</span>
</span><span class='line'>    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">byref_destroy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="p">);</span>
</span><span class='line'>    <span class="cm">/* long shared[0]; */</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 做下对比</span>
</span><span class='line'><span class="k">struct</span> <span class="n">__Block_byref_a_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">__isa</span><span class="p">;</span>
</span><span class='line'><span class="n">__Block_byref_a_0</span> <span class="o">*</span><span class="n">__forwarding</span><span class="p">;</span>
</span><span class='line'> <span class="kt">int</span> <span class="n">__flags</span><span class="p">;</span>
</span><span class='line'> <span class="kt">int</span> <span class="n">__size</span><span class="p">;</span>
</span><span class='line'> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// flags/_flags类型</span>
</span><span class='line'><span class="k">enum</span> <span class="p">{</span>
</span><span class='line'>        <span class="cm">/* See function implementation for a more complete description of these fields and combinations */</span>
</span><span class='line'>        <span class="c1">// 是一个对象</span>
</span><span class='line'>        <span class="n">BLOCK_FIELD_IS_OBJECT</span>   <span class="o">=</span>  <span class="mi">3</span><span class="p">,</span>  <span class="cm">/* id, NSObject, __attribute__((NSObject)), block, ... */</span>
</span><span class='line'>        <span class="c1">// 是一个block</span>
</span><span class='line'>        <span class="n">BLOCK_FIELD_IS_BLOCK</span>    <span class="o">=</span>  <span class="mi">7</span><span class="p">,</span>  <span class="cm">/* a block variable */</span>
</span><span class='line'>        <span class="c1">// 被__block修饰的变量</span>
</span><span class='line'>        <span class="n">BLOCK_FIELD_IS_BYREF</span>    <span class="o">=</span>  <span class="mi">8</span><span class="p">,</span>  <span class="cm">/* the on stack structure holding the __block variable */</span>
</span><span class='line'>        <span class="c1">// 被__weak修饰的变量，只能被辅助copy函数使用</span>
</span><span class='line'>        <span class="n">BLOCK_FIELD_IS_WEAK</span>     <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>  <span class="cm">/* declared __weak, only used in byref copy helpers */</span>
</span><span class='line'>        <span class="c1">// block辅助函数调用（告诉内部实现不要进行retain或者copy）</span>
</span><span class='line'>        <span class="n">BLOCK_BYREF_CALLER</span>      <span class="o">=</span> <span class="mi">128</span>  <span class="cm">/* called from __block (byref) copy/dispose support routines. */</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 设置不同属性对应的flags/_flags值</span>
</span><span class='line'>  <span class="k">__block</span> <span class="kt">id</span>                   <span class="mi">128</span><span class="o">+</span><span class="mi">3</span>
</span><span class='line'>    <span class="k">__weak</span> <span class="n">block</span> <span class="kt">id</span>              <span class="mi">128</span><span class="o">+</span><span class="mi">3</span><span class="o">+</span><span class="mi">16</span>
</span><span class='line'>  <span class="k">__block</span> <span class="p">(</span><span class="o">^</span><span class="n">Block</span><span class="p">)</span>             <span class="mi">128</span><span class="o">+</span><span class="mi">7</span>
</span><span class='line'>  <span class="k">__weak</span> <span class="k">__block</span> <span class="p">(</span><span class="o">^</span><span class="n">Block</span><span class="p">)</span>      <span class="mi">128</span><span class="o">+</span><span class="mi">7</span><span class="o">+</span><span class="mi">16</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看出，<code>__block</code>将原来的基本类型包装成了<code>对象</code>。因为以上两个结构体的前4个成员的类型都是一样的，内存空间排列一致，所以可以进行以下操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 转换成C++代码</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_copy_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span><span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="mi">8</span><span class="cm">/*BLOCK_FIELD_IS_BYREF*/</span><span class="p">);}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// _Block_object_assign源码</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">_Block_object_assign</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">destAddr</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'>    <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_FIELD_IS_BYREF</span><span class="p">)</span> <span class="o">==</span> <span class="n">BLOCK_FIELD_IS_BYREF</span><span class="p">)</span>  <span class="p">{</span>
</span><span class='line'>        <span class="c1">// copying a __block reference from the stack Block to the heap</span>
</span><span class='line'>        <span class="c1">// flags will indicate if it holds a __weak reference and needs a special isa</span>
</span><span class='line'>        <span class="n">_Block_byref_assign_copy</span><span class="p">(</span><span class="n">destAddr</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// _Block_byref_assign_copy源码</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">_Block_byref_assign_copy</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 这里因为前面4个成员的内存分布一样，所以直接转换后，使用Block_byref的成员变量名，能访问到__Block_byref_a_0的前面4个成员</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">**</span><span class="n">destp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">**</span><span class="p">)</span><span class="n">dest</span><span class="p">;</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Block_byref</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'>    <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">forwarding</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_REFCOUNT_MASK</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// 从main函数对__Block_byref_a_0的初始化，可以看到初始化时将flags赋值为0</span>
</span><span class='line'>      <span class="c1">// 这里表示第一次拷贝，会进行复制操作，并修改原来flags的值</span>
</span><span class='line'>      <span class="c1">// static int _Byref_flag_initial_value = BLOCK_NEEDS_FREE | 2;</span>
</span><span class='line'>      <span class="c1">// 可以看出，复制后，会并入BLOCK_NEEDS_FREE，后面的2是block的初始引用计数</span>
</span><span class='line'>      <span class="p">...</span>
</span><span class='line'>        <span class="k">copy</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|</span> <span class="n">_Byref_flag_initial_value</span><span class="p">;</span>
</span><span class='line'>        <span class="p">...</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">// 已经拷贝到堆了，只增加引用计数</span>
</span><span class='line'>    <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">forwarding</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_NEEDS_FREE</span><span class="p">)</span> <span class="o">==</span> <span class="n">BLOCK_NEEDS_FREE</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">latching_incr_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">forwarding</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">// 普通的赋值，里面最底层就*destptr = value;这句表达式</span>
</span><span class='line'>    <span class="n">_Block_assign</span><span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">forwarding</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="n">destp</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>主要操作都在代码注释中了，总体来说，<code>__block</code>修饰的基本类型会被包装为对象，并且只在最初block拷贝时复制一次，后面的拷贝只会增加这个捕获变量的引用计数。</p>

<h6>对象的辅助函数</h6>

<ul>
<li>没有<code>__block</code>修饰</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span><span class="o">^</span><span class="n">Block</span><span class="p">)();</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="bp">NSObject</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>        <span class="n">Block</span> <span class="n">block</span> <span class="o">=</span> <span class="o">^</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">a</span><span class="p">;</span>
</span><span class='line'>        <span class="p">};</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>首先，在没有<code>__block</code>修饰时，对象编译转换的结果如下，删除了一些变化不大的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_func_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span> <span class="o">*</span><span class="n">__cself</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="bp">NSObject</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">__cself</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">;</span> <span class="c1">// bound by copy</span>
</span><span class='line'>            <span class="n">a</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_copy_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span><span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dst</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="cm">/*BLOCK_FIELD_IS_OBJECT*/</span><span class="p">);}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">__main_block_dispose_0</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span><span class="n">_Block_object_dispose</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">a</span><span class="p">,</span> <span class="mi">3</span><span class="cm">/*BLOCK_FIELD_IS_OBJECT*/</span><span class="p">);}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="k">struct</span> <span class="n">__main_block_desc_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">reserved</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">size_t</span> <span class="n">Block_size</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="k">copy</span><span class="p">)(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'>  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dispose</span><span class="p">)(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span> <span class="n">__main_block_desc_0_DATA</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">__main_block_impl_0</span><span class="p">),</span>
</span></code></pre></td></tr></table></div></figure>


<p>对象在没有<code>__block</code>修饰时，并没有产生<code>__Block_byref_a_0</code>结构体，只是将标志位修改为<code>BLOCK_FIELD_IS_OBJECT</code>。而在<code>_Block_object_assign</code>中对应的判断分支代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">...</span>
</span><span class='line'><span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_FIELD_IS_OBJECT</span><span class="p">)</span> <span class="o">==</span> <span class="n">BLOCK_FIELD_IS_OBJECT</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">_Block_retain_object</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
</span><span class='line'>    <span class="n">_Block_assign</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="p">,</span> <span class="n">destAddr</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，block复制时，会retain捕捉对象，以增加其引用计数。</p>

<ul>
<li>有<code>__block</code>修饰</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span><span class="o">^</span><span class="n">Block</span><span class="p">)();</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">__block</span> <span class="bp">NSObject</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSObject</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>        <span class="n">Block</span> <span class="n">block</span> <span class="o">=</span> <span class="o">^</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">a</span><span class="p">;</span>
</span><span class='line'>        <span class="p">};</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这种情况下，编译转换的部分结果如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">__Block_byref_a_0</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span><span class="n">__isa</span><span class="p">;</span>
</span><span class='line'><span class="n">__Block_byref_a_0</span> <span class="o">*</span><span class="n">__forwarding</span><span class="p">;</span>
</span><span class='line'> <span class="kt">int</span> <span class="n">__flags</span><span class="p">;</span>
</span><span class='line'> <span class="kt">int</span> <span class="n">__size</span><span class="p">;</span>
</span><span class='line'> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">__Block_byref_id_object_copy</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">__Block_byref_id_object_dispose</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
</span><span class='line'> <span class="bp">NSObject</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="cm">/* @autoreleasepool */</span> <span class="p">{</span> <span class="n">__AtAutoreleasePool</span> <span class="n">__autoreleasepool</span><span class="p">;</span>
</span><span class='line'><span class="n">attribute__</span><span class="p">((</span><span class="n">__blocks__</span><span class="p">(</span><span class="n">byref</span><span class="p">)))</span> <span class="n">__Block_byref_a_0</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,(</span><span class="n">__Block_byref_a_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">33554432</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__Block_byref_a_0</span><span class="p">),</span> <span class="n">__Block_byref_id_object_copy_131</span><span class="p">,</span> <span class="n">__Block_byref_id_object_dispose_131</span><span class="p">,....};</span>
</span><span class='line'><span class="n">Block</span> <span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="o">&amp;</span><span class="n">__main_block_impl_0</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">__main_block_func_0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">__main_block_desc_0_DATA</span><span class="p">,</span> <span class="p">(</span><span class="n">__Block_byref_a_0</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">570425344</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 以下的40表示__Block_byref_a_0对象a的位移（4个指针(32字节)＋2个int变量(8字节)＝40字节）</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="n">__Block_byref_id_object_copy_131</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'> <span class="n">_Block_object_assign</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">dst</span> <span class="o">+</span> <span class="mi">40</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">src</span> <span class="o">+</span> <span class="mi">40</span><span class="p">),</span> <span class="mi">131</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="n">__Block_byref_id_object_dispose_131</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'> <span class="n">_Block_object_dispose</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">src</span> <span class="o">+</span> <span class="mi">40</span><span class="p">),</span> <span class="mi">131</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，对于对象，<code>__Block_byref_a_0</code>另外增加了两个辅助函数<code>__Block_byref_id_object_copy</code>、<code>__Block_byref_id_object_dispose</code>,以实现对对象内存的管理。其中两者的最后一个参数<code>131</code>表示<code>BLOCK_BYREF_CALLER</code>|<code>BLOCK_FIELD_IS_OBJECT</code>，BLOCK_BYREF_CALLER表示在内部实现中不对__block修饰的a对象进行retain或copy；以下为相关源码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_BYREF_CALLER</span><span class="p">)</span> <span class="o">==</span> <span class="n">BLOCK_BYREF_CALLER</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'>    <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// do *not* retain or *copy* __block variables whatever they are</span>
</span><span class='line'>        <span class="n">_Block_assign</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">object</span><span class="p">,</span> <span class="n">destAddr</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>_Block_byref_assign_copy</code>函数的以下代码会对上面的辅助函数（__Block_byref_id_object_copy_131）进行调用；<code>570425344</code>表示<code>BLOCK_HAS_COPY_DISPOSE</code>|<code>BLOCK_HAS_DESCRIPTOR</code>，所以会执行以下相关源码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BLOCK_HAS_COPY_DISPOSE</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Trust copy helper to copy everything of interest</span>
</span><span class='line'>    <span class="c1">// If more than one field shows up in a byref block this is wrong XXX</span>
</span><span class='line'>    <span class="k">copy</span><span class="o">-&gt;</span><span class="n">byref_keep</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">byref_keep</span><span class="p">;</span>
</span><span class='line'>    <span class="k">copy</span><span class="o">-&gt;</span><span class="n">byref_destroy</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">byref_destroy</span><span class="p">;</span>
</span><span class='line'>    <span class="p">(</span><span class="o">*</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">byref_keep</span><span class="p">)(</span><span class="k">copy</span><span class="p">,</span> <span class="n">src</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>ARC中block的工作</h2>

<p><img src="./image/Snip20150720_4.png" alt="" /><br>
苹果文档提及，在ARC模式下，在栈间传递block时，不需要手动copy栈中的block，即可让block正常工作。主要原因是ARC对栈中的block自动执行了copy，将<code>_NSConcreteStackBlock</code>类型的block转换成了<code>_NSConcreteMallocBlock</code>的block。<br></p>

<h6>block试验</h6>

<p>下面对block做点实验：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">block</span><span class="p">)()</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span><span class="n">i</span><span class="p">;};</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">__weak</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">weakBlock</span><span class="p">)()</span> <span class="o">=</span> <span class="o">^</span><span class="p">{</span><span class="n">i</span><span class="p">;};</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">stackBlock</span><span class="p">)()</span> <span class="o">=</span> <span class="o">^</span><span class="p">{};</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// ARC情况下</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 创建时，都会在栈中</span>
</span><span class='line'>        <span class="c1">// &lt;__NSStackBlock__: 0x7fff5fbff730&gt;</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span><span class="n">i</span><span class="p">;});</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 因为stackBlock为strong类型，且捕获了外部变量，所以赋值时，自动进行了copy</span>
</span><span class='line'>        <span class="c1">// &lt;__NSMallocBlock__: 0x100206920&gt;</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 如果是weak类型的block，依然不会自动进行copy</span>
</span><span class='line'>        <span class="c1">// &lt;__NSStackBlock__: 0x7fff5fbff728&gt;</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">weakBlock</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 如果block是strong类型，并且没有捕获外部变量，那么就会转换成__NSGlobalBlock__</span>
</span><span class='line'>        <span class="c1">// &lt;__NSGlobalBlock__: 0x100001110&gt;</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">stackBlock</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 在非ARC情况下，产生以下输出</span>
</span><span class='line'>        <span class="c1">// &lt;__NSStackBlock__: 0x7fff5fbff6d0&gt;</span>
</span><span class='line'>        <span class="c1">// &lt;__NSStackBlock__: 0x7fff5fbff730&gt;</span>
</span><span class='line'>        <span class="c1">// &lt;__NSStackBlock__: 0x7fff5fbff700&gt;</span>
</span><span class='line'>        <span class="c1">// &lt;__NSGlobalBlock__: 0x1000010d0&gt;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看出，ARC对<code>类型为strong</code>且<code>捕获了外部变量</code>的block进行了copy。并且当block<code>类型为strong</code>，但是创建时<code>没有捕获外部变量</code>，block最终会变成<code>__NSGlobalBlock__</code>类型（这里可能因为block中的代码没有捕获外部变量，所以不需要在栈中开辟变量，也就是说，在<code>编译</code>时，这个block的<code>所有内容已经在代码段中生成了</code>，所以就把block的类型转换为全局类型）<br></p>

<h6>block作为参数传递</h6>

<p>再来看下使用在栈中的block需要注意的情况：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">NSMutableArray</span> <span class="o">*</span><span class="n">arrayM</span><span class="p">;</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">myBlock</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Block</span> <span class="n">block</span> <span class="o">=</span> <span class="o">^</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%d&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">[</span><span class="n">arrayM</span> <span class="nl">addObject</span><span class="p">:</span><span class="n">block</span><span class="p">];</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">arrayM</span> <span class="o">=</span> <span class="l">@[]</span><span class="p">.</span><span class="n">mutableCopy</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">myBlock</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">Block</span> <span class="n">block</span> <span class="o">=</span> <span class="p">[</span><span class="n">arrayM</span> <span class="n">firstObject</span><span class="p">];</span>
</span><span class='line'>        <span class="c1">// 非ARC这里崩溃</span>
</span><span class='line'>        <span class="n">block</span><span class="p">();</span>
</span><span class='line'> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// ARC情况下输出</span>
</span><span class='line'><span class="c1">// &lt;__NSMallocBlock__: 0x100214480&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 非ARC情况下输出</span>
</span><span class='line'><span class="c1">// &lt;__NSStackBlock__: 0x7fff5fbff738&gt;</span>
</span><span class='line'><span class="c1">// 崩溃，野指针错误</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，ARC情况下因为自动执行了copy，所以返回类型为<code>__NSMallocBlock__</code>，在函数结束后依然可以访问；而非ARC情况下，需要我们手动调用<code>[block copy]</code>来将block拷贝到堆中，否则因为栈中的block生命周期和函数中的栈生命周期关联，当函数退出后，相应的堆被销毁，block也就不存在了。<br>
如果把block的以下代码删除：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%d&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么block就会变成全局类型，在main中访问也不会出崩溃。<br></p>

<h6>block作为返回值</h6>

<p>在非ARC情况下，如果返回值是block，则一般这样操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">return</span> <span class="p">[[</span><span class="n">block</span> <span class="k">copy</span><span class="p">]</span> <span class="n">autorelease</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于外部要使用的block，更趋向于把它拷贝到堆中，使其脱离栈生命周期的约束。</p>

<h6>block属性</h6>

<p>这里还有一点关于block类型的ARC属性。上文也说明了，ARC会自动帮<code>strong类型</code>且<code>捕获外部变量</code>的block进行copy，所以在定义block类型的属性时也可以使用strong，不一定使用copy。也就是以下代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cm">/** 假如有栈block赋给以下两个属性 **/</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 这里因为ARC，当栈block中会捕获外部变量时，这个block会被copy进堆中</span>
</span><span class='line'><span class="c1">// 如果没有捕获外部变量，这个block会变为全局类型</span>
</span><span class='line'><span class="c1">// 不管怎么样，它都脱离了栈生命周期的约束</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="n">Block</span> <span class="o">*</span><span class="n">strongBlock</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 这里都会被copy进堆中</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">copy</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="n">Block</span> <span class="o">*</span><span class="n">copyBlock</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>参考博文</h2>

<p><a href="http://blog.devtang.com/blog/2013/07/28/a-look-inside-blocks/">谈Objective-C Block的实现</a><br>
<a href="http://blog.csdn.net/jasonblog/article/details/7756763">iOS中block实现的探究</a><br>
<a href="http://www.galloway.me.uk/2013/05/a-look-inside-blocks-episode-3-block-copy/">A look inside blocks: Episode 3</a><br>
<a href="http://llvm.org/svn/llvm-project/compiler-rt/trunk/lib/BlocksRuntime/runtime.c">runtime.c</a><br>
<a href="http://llvm.org/svn/llvm-project/compiler-rt/trunk/lib/BlocksRuntime/Block_private.h">Block_private.h</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UITextFiled文字抖动效果]]></title>
    <link href="http://triplecc.github.io/blog/2015-01-27-uitextfiledwen-zi-dou-dong-xiao-guo/"/>
    <updated>2015-01-27T20:17:49+08:00</updated>
    <id>http://triplecc.github.io/blog/uitextfiledwen-zi-dou-dong-xiao-guo</id>
    <content type="html"><![CDATA[<p>最终设置UITextField的placeholder效果：<br></p>

<p><img src="./images/2015-07-28%2016_46_41.gif" alt="" /><br></p>

<p>有需求1如下：</p>

<ul>
<li>未点击时UITextField的placeholder为浅灰色</li>
<li>点击后，还未进行输入时，UITextField的placeholder变为深灰色</li>
</ul>


<p>这个实现并不难：
- 通过通知或者重写UITextField的响应者处理方法，都可以实现捕获点击时间
- UITextField设置placeholder可以使用以下属性：
  - 通过设置这个富文本属性，可以得到丰富多彩的placeholder<br></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="p">@</span><span class="bp">NSCopying</span> <span class="k">var</span> <span class="nl">attributedPlaceholder</span><span class="p">:</span> <span class="bp">NSAttributedString</span><span class="o">?</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 附带光标颜色属性</span>
</span><span class='line'><span class="k">var</span> <span class="nl">tintColor</span><span class="p">:</span> <span class="bp">UIColor</span><span class="o">!</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是需求2加了点东西：</p>

<ul>
<li>点击后，还未进行输入时，UITextField的placeholder文字左右进行小幅度抖动<br></li>
</ul>


<p>可以看到通过设置attributedPlaceholder，可以改变一些静态的属性，如颜色和文字大小。<br>
但是如果需要里面的文字做一些简单的抖动效果貌似就不行了，UITextField没有提供相关属性，我们也不知道placeholder是在何种控件中显示的。<br>
既然不知道laceholder是在何种控件中显示，那就通过以下代码打印出UITextField中所有的成员变量（函数参考<a href="http://triplecc.github.io/blog/2015-01-10-runtimeji-chu/">runtime基础元素解析</a>），看看是否会有什么发现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">Ivar</span> <span class="o">*</span><span class="n">ivars</span> <span class="o">=</span> <span class="n">class_copyIvarList</span><span class="p">([</span><span class="bp">UITextField</span> <span class="k">class</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">outCount</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">outCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Ivar</span> <span class="n">ivar</span> <span class="o">=</span> <span class="n">ivars</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%s&quot;</span><span class="p">,</span> <span class="n">ivar_getName</span><span class="p">(</span><span class="n">ivar</span><span class="p">));</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">free</span><span class="p">(</span><span class="n">ivars</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>截取关键部分如下：<br></p>

<p><img src="./images/Snip20150728_2.png" alt="" /><br></p>

<p>从字面上看，上面的<code>_placeholderLabel</code>是否就是显示placeholder的控件？<br>
测试实际结果的确是显示placeholder的控件。<br>
只要有了这个控件，那要做一些小抖动的动画那就没什么问题了，先获取这个UILabel:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">private</span> <span class="k">var</span> <span class="nl">tpcPlaceholderLabel</span><span class="p">:</span><span class="bp">UILabel</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">get</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">self</span><span class="p">.</span><span class="n">valueForKey</span><span class="p">(</span><span class="s">&quot;_placeholderLabel&quot;</span><span class="p">)</span> <span class="kt">as</span><span class="o">?</span> <span class="bp">UILabel</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后重写UITextField的响应者处理函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">// 成为第一响应者</span>
</span><span class='line'><span class="kr">override</span> <span class="k">func</span> <span class="n">becomeFirstResponder</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 存储正常颜色</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">normalColor</span> <span class="o">==</span> <span class="nb">nil</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">normalColor</span> <span class="o">=</span> <span class="n">tpcPlaceholderLabel</span><span class="o">?</span><span class="p">.</span><span class="n">textColor</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">// 存储选中颜色</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">selectedColor</span> <span class="o">==</span> <span class="nb">nil</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">selectedColor</span> <span class="o">=</span> <span class="n">tpcPlaceholderLabel</span><span class="o">?</span><span class="p">.</span><span class="n">textColor</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">tpcPlaceholderLabel</span><span class="o">?</span><span class="p">.</span><span class="n">textColor</span> <span class="o">=</span> <span class="n">selectedColor</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 执行placeholder动画函数</span>
</span><span class='line'>    <span class="n">placeholderLabelDoAnimationWithType</span><span class="p">(</span><span class="n">animationType</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="nb">super</span><span class="p">.</span><span class="n">becomeFirstResponder</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 放弃第一响应者</span>
</span><span class='line'><span class="kr">override</span> <span class="k">func</span> <span class="n">resignFirstResponder</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">switch</span> <span class="n">animationType</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">.</span><span class="nl">TPCAnimationTypeUpDown</span> <span class="p">:</span>
</span><span class='line'>        <span class="k">fallthrough</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">.</span><span class="nl">TPCAnimationTypeBlowUp</span> <span class="p">:</span>
</span><span class='line'>        <span class="k">fallthrough</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">.</span><span class="nl">TPCAnimationTypeLeftRight</span> <span class="p">:</span>
</span><span class='line'>        <span class="n">tpcPlaceholderLabel</span><span class="o">?</span><span class="p">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">CGAffineTransformIdentity</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">.</span><span class="nl">TPCAnimationTypeEasyInOut</span> <span class="p">:</span>
</span><span class='line'>        <span class="bp">UIView</span><span class="p">.</span><span class="n">animateWithDuration</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="nl">animations</span><span class="p">:</span> <span class="p">{</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Void</span> <span class="k">in</span>
</span><span class='line'>            <span class="n">tpcPlaceholderLabel</span><span class="o">?</span><span class="p">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="mf">1.0</span>
</span><span class='line'>        <span class="p">})</span>
</span><span class='line'>    <span class="k">case</span> <span class="p">.</span><span class="nl">TPCAnimationTypeNone</span> <span class="p">:</span>
</span><span class='line'>        <span class="k">break</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="k">let</span> <span class="n">operate</span> <span class="o">=</span> <span class="n">operateWhenResignFirstResponder</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">operate</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 设置为初始颜色</span>
</span><span class='line'>    <span class="n">tpcPlaceholderLabel</span><span class="o">?</span><span class="p">.</span><span class="n">textColor</span> <span class="o">=</span> <span class="n">normalColor</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="nb">super</span><span class="p">.</span><span class="n">resignFirstResponder</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后通过以下函数，传入相应的动作就可以得到抖动的效果了</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="n">private</span> <span class="k">func</span> <span class="nf">doAnimation</span><span class="p">(</span><span class="nl">action</span><span class="p">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">UIView</span><span class="p">.</span><span class="n">animateWithDuration</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="nl">delay</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nl">usingSpringWithDamping</span><span class="p">:</span> <span class="mf">0.1</span><span class="p">,</span> <span class="nl">initialSpringVelocity</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="nl">options</span><span class="p">:</span> <span class="n">UIViewAnimationOptions</span><span class="p">.</span><span class="n">CurveEaseInOut</span><span class="p">,</span> <span class="nl">animations</span><span class="p">:</span> <span class="p">{</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Void</span> <span class="k">in</span>
</span><span class='line'>        <span class="n">action</span><span class="p">()</span>
</span><span class='line'>        <span class="p">},</span> <span class="nl">completion</span><span class="p">:</span> <span class="nb">nil</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>还有一点，根据上面打印的UITextField成员变量，看到了<code>_displayLabel</code>，这个就是在键盘输入后显示文字的UILabel了。这个属性可以用来干嘛？<br>
我想，<code>可能会有这么一种需求（不过可能没有），就是用户输入错误时，UITextField中已经输入的文字做左右抖动，以间接的形式，辅助提醒用户，这一栏输错了，而不是弹出一个HUB</code>。<br>
由于UITextField内部做了某些处理，所以无法在成为第一响应者时做一些动作，那么，就在放弃第一响应者函数中。<br></p>

<p>相关代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='swift'><span class='line'><span class="c1">// 设置一个在放弃第一响应者的闭包属性</span>
</span><span class='line'><span class="k">var</span> <span class="nl">operateWhenResignFirstResponder</span><span class="p">:</span> <span class="p">(()</span> <span class="o">-&gt;</span> <span class="p">())</span><span class="o">?</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 在func resignFirstResponder() -&gt; Bool函数中调用</span>
</span><span class='line'><span class="k">if</span> <span class="k">let</span> <span class="n">operate</span> <span class="o">=</span> <span class="n">operateWhenResignFirstResponder</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">operate</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>代码地址</h4>

<p><a href="https://github.com/tripleCC/TPCDynamicTextFiled/blob/master/README.md">UITextFiled文字抖动效果</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常用runtime函数]]></title>
    <link href="http://triplecc.github.io/blog/2015-01-22-chang-yong-runtimehan-shu/"/>
    <updated>2015-01-22T11:28:20+08:00</updated>
    <id>http://triplecc.github.io/blog/chang-yong-runtimehan-shu</id>
    <content type="html"><![CDATA[<p>这里主要纪录一些常用的函数：</p>

<h2>类</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 根据类，获取类名</span>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">class_getName</span><span class="p">(</span><span class="kt">Class</span> <span class="n">cls</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 根据类名获取类</span>
</span><span class='line'><span class="kt">Class</span> <span class="n">objc_getClass</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>注意，以下有获取<code>列表</code>的函数需要手动<code>free</code>获取的列表</li>
<li>成员变量</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 获取成员变量列表</span>
</span><span class='line'><span class="n">Ivar</span> <span class="o">*</span> <span class="n">class_copyIvarList</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">outCount</span> <span class="p">)</span>
</span><span class='line'><span class="c1">// 获取类成员变量的信息</span>
</span><span class='line'><span class="n">Ivar</span> <span class="n">class_getClassVariable</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="p">)</span>
</span><span class='line'><span class="c1">// 根据实例变量名，获取类中实例变量</span>
</span><span class='line'><span class="n">Ivar</span> <span class="n">class_getInstanceVariable</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="p">)</span>
</span><span class='line'><span class="c1">// 往运行时创建的类添加成员变量</span>
</span><span class='line'><span class="kt">BOOL</span> <span class="n">class_addIvar</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">alignment</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">types</span> <span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>属性</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 获取属性列表</span>
</span><span class='line'><span class="kt">objc_property_t</span> <span class="o">*</span> <span class="n">class_copyPropertyList</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">outCount</span> <span class="p">)</span>
</span><span class='line'><span class="c1">// 获取指定的属性</span>
</span><span class='line'><span class="kt">objc_property_t</span> <span class="n">class_getProperty</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="p">)</span>
</span><span class='line'><span class="c1">// 获取属性列表</span>
</span><span class='line'><span class="kt">objc_property_t</span> <span class="o">*</span> <span class="n">class_copyPropertyList</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">outCount</span> <span class="p">)</span>
</span><span class='line'><span class="c1">// 为类添加属性</span>
</span><span class='line'><span class="kt">BOOL</span> <span class="n">class_addProperty</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">objc_property_attribute_t</span> <span class="o">*</span><span class="n">attributes</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">attributeCount</span> <span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>方法</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 获取方法列表</span>
</span><span class='line'><span class="n">Method</span> <span class="o">*</span> <span class="n">class_copyMethodList</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">outCount</span> <span class="p">)</span>
</span><span class='line'><span class="c1">// 添加方法</span>
</span><span class='line'><span class="kt">BOOL</span> <span class="n">class_addMethod</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">name</span><span class="p">,</span> <span class="kt">IMP</span> <span class="n">imp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">types</span> <span class="p">)</span>
</span><span class='line'><span class="c1">// 获取实例方法</span>
</span><span class='line'><span class="n">Method</span> <span class="n">class_getInstanceMethod</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">name</span> <span class="p">)</span>
</span><span class='line'><span class="c1">// 获取类方法</span>
</span><span class='line'><span class="n">Method</span> <span class="n">class_getClassMethod</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">name</span> <span class="p">)</span>
</span><span class='line'><span class="c1">// 替代方法的实现</span>
</span><span class='line'><span class="kt">IMP</span> <span class="n">class_replaceMethod</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">name</span><span class="p">,</span> <span class="kt">IMP</span> <span class="n">imp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">types</span> <span class="p">)</span>
</span><span class='line'><span class="c1">// 返回方法的具体实现</span>
</span><span class='line'><span class="kt">IMP</span> <span class="n">class_getMethodImplementation</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">name</span> <span class="p">)</span>
</span><span class='line'><span class="kt">IMP</span> <span class="n">class_getMethodImplementation_stret</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">name</span> <span class="p">)</span>
</span><span class='line'><span class="c1">// 类实例是否响应指定的selector</span>
</span><span class='line'><span class="kt">BOOL</span> <span class="n">class_respondsToSelector</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">sel</span> <span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>协议</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 获取协议列表</span>
</span><span class='line'><span class="n">Protocol</span> <span class="o">*</span> <span class="n">class_copyProtocolList</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">outCount</span> <span class="p">)</span>
</span><span class='line'><span class="c1">// 添加协议</span>
</span><span class='line'><span class="kt">BOOL</span> <span class="n">class_addProtocol</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="n">Protocol</span> <span class="o">*</span><span class="n">protocol</span> <span class="p">)</span>
</span><span class='line'><span class="c1">// 返回类是否实现指定的协议</span>
</span><span class='line'><span class="kt">BOOL</span> <span class="n">class_conformsToProtocol</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="n">Protocol</span> <span class="o">*</span><span class="n">protocol</span> <span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>动态创建</h2>

<ul>
<li>类</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 创建一个新类和元类</span>
</span><span class='line'><span class="kt">Class</span> <span class="nf">objc_allocateClassPair</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">superclass</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">extraBytes</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 销毁一个类及其相关联的类</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">objc_disposeClassPair</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 在应用中注册由objc_allocateClassPair创建的类</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">objc_registerClassPair</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>对象</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="c1">// 创建类实例</span>
</span><span class='line'>  <span class="kt">id</span> <span class="nf">class_createInstance</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">extraBytes</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 在指定位置创建类实例</span>
</span><span class='line'>  <span class="kt">id</span> <span class="nf">objc_constructInstance</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">bytes</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 销毁类实例</span>
</span><span class='line'>  <span class="kt">void</span> <span class="o">*</span> <span class="nf">objc_destructInstance</span> <span class="p">(</span> <span class="kt">id</span> <span class="n">obj</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>实例对象操作</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 返回指定对象的一份拷贝</span>
</span><span class='line'><span class="kt">id</span> <span class="nf">object_copy</span> <span class="p">(</span> <span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 释放指定对象占用的内存</span>
</span><span class='line'><span class="kt">id</span> <span class="nf">object_dispose</span> <span class="p">(</span> <span class="kt">id</span> <span class="n">obj</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 修改类实例的实例变量的值</span>
</span><span class='line'><span class="n">Ivar</span> <span class="nf">object_setInstanceVariable</span> <span class="p">(</span> <span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 获取对象实例变量的值</span>
</span><span class='line'><span class="n">Ivar</span> <span class="nf">object_getInstanceVariable</span> <span class="p">(</span> <span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">outValue</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 返回指向给定对象分配的任何额外字节的指针</span>
</span><span class='line'><span class="kt">void</span> <span class="o">*</span> <span class="nf">object_getIndexedIvars</span> <span class="p">(</span> <span class="kt">id</span> <span class="n">obj</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 返回对象中实例变量的值</span>
</span><span class='line'><span class="kt">id</span> <span class="nf">object_getIvar</span> <span class="p">(</span> <span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="n">Ivar</span> <span class="n">ivar</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 设置对象中实例变量的值</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">object_setIvar</span> <span class="p">(</span> <span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="n">Ivar</span> <span class="n">ivar</span><span class="p">,</span> <span class="kt">id</span> <span class="n">value</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 返回给定对象的类名</span>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="nf">object_getClassName</span> <span class="p">(</span> <span class="kt">id</span> <span class="n">obj</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 返回对象的类</span>
</span><span class='line'><span class="kt">Class</span> <span class="nf">object_getClass</span> <span class="p">(</span> <span class="kt">id</span> <span class="n">obj</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 设置对象的类</span>
</span><span class='line'><span class="kt">Class</span> <span class="nf">object_setClass</span> <span class="p">(</span> <span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">Class</span> <span class="n">cls</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>获取类定义</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 获取已注册的类定义的列表</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">objc_getClassList</span> <span class="p">(</span> <span class="kt">Class</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bufferCount</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 创建并返回一个指向所有已注册类的指针列表</span>
</span><span class='line'><span class="kt">Class</span> <span class="o">*</span> <span class="nf">objc_copyClassList</span> <span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">outCount</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 返回指定类的类定义</span>
</span><span class='line'><span class="kt">Class</span> <span class="nf">objc_lookUpClass</span> <span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="p">);</span>
</span><span class='line'><span class="kt">Class</span> <span class="nf">objc_getClass</span> <span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="p">);</span>
</span><span class='line'><span class="kt">Class</span> <span class="nf">objc_getRequiredClass</span> <span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 返回指定类的元类</span>
</span><span class='line'><span class="kt">Class</span> <span class="nf">objc_getMetaClass</span> <span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>成员变量、属性</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 获取成员变量名</span>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="nf">ivar_getName</span> <span class="p">(</span> <span class="n">Ivar</span> <span class="n">v</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 获取成员变量类型编码</span>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="nf">ivar_getTypeEncoding</span> <span class="p">(</span> <span class="n">Ivar</span> <span class="n">v</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 获取成员变量的偏移量</span>
</span><span class='line'><span class="kt">ptrdiff_t</span> <span class="nf">ivar_getOffset</span> <span class="p">(</span> <span class="n">Ivar</span> <span class="n">v</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 设置关联对象</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">objc_setAssociatedObject</span> <span class="p">(</span> <span class="kt">id</span> <span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">id</span> <span class="n">value</span><span class="p">,</span> <span class="n">objc_AssociationPolicy</span> <span class="n">policy</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 获取关联对象</span>
</span><span class='line'><span class="kt">id</span> <span class="nf">objc_getAssociatedObject</span> <span class="p">(</span> <span class="kt">id</span> <span class="n">object</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 移除关联对象</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">objc_removeAssociatedObjects</span> <span class="p">(</span> <span class="kt">id</span> <span class="n">object</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 获取属性名</span>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="nf">property_getName</span> <span class="p">(</span> <span class="kt">objc_property_t</span> <span class="n">property</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 获取属性特性描述字符串</span>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="nf">property_getAttributes</span> <span class="p">(</span> <span class="kt">objc_property_t</span> <span class="n">property</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 获取属性中指定的特性</span>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span> <span class="nf">property_copyAttributeValue</span> <span class="p">(</span> <span class="kt">objc_property_t</span> <span class="n">property</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">attributeName</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 获取属性的特性列表</span>
</span><span class='line'><span class="kt">objc_property_attribute_t</span> <span class="o">*</span> <span class="nf">property_copyAttributeList</span> <span class="p">(</span> <span class="kt">objc_property_t</span> <span class="n">property</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">outCount</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>方法</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 调用指定方法的实现</span>
</span><span class='line'><span class="kt">id</span> <span class="nf">method_invoke</span> <span class="p">(</span> <span class="kt">id</span> <span class="n">receiver</span><span class="p">,</span> <span class="n">Method</span> <span class="n">m</span><span class="p">,</span> <span class="p">...</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 调用返回一个数据结构的方法的实现</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">method_invoke_stret</span> <span class="p">(</span> <span class="kt">id</span> <span class="n">receiver</span><span class="p">,</span> <span class="n">Method</span> <span class="n">m</span><span class="p">,</span> <span class="p">...</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 获取方法名</span>
</span><span class='line'><span class="kt">SEL</span> <span class="nf">method_getName</span> <span class="p">(</span> <span class="n">Method</span> <span class="n">m</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 返回方法的实现</span>
</span><span class='line'><span class="kt">IMP</span> <span class="nf">method_getImplementation</span> <span class="p">(</span> <span class="n">Method</span> <span class="n">m</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 获取描述方法参数和返回值类型的字符串</span>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="nf">method_getTypeEncoding</span> <span class="p">(</span> <span class="n">Method</span> <span class="n">m</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 获取方法的返回值类型的字符串</span>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span> <span class="nf">method_copyReturnType</span> <span class="p">(</span> <span class="n">Method</span> <span class="n">m</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 获取方法的指定位置参数的类型字符串</span>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span> <span class="nf">method_copyArgumentType</span> <span class="p">(</span> <span class="n">Method</span> <span class="n">m</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 通过引用返回方法的返回值类型字符串</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">method_getReturnType</span> <span class="p">(</span> <span class="n">Method</span> <span class="n">m</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">dst_len</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 返回方法的参数的个数</span>
</span><span class='line'><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">method_getNumberOfArguments</span> <span class="p">(</span> <span class="n">Method</span> <span class="n">m</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 通过引用返回方法指定位置参数的类型字符串</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">method_getArgumentType</span> <span class="p">(</span> <span class="n">Method</span> <span class="n">m</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">dst_len</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 返回指定方法的方法描述结构体</span>
</span><span class='line'><span class="k">struct</span> <span class="n">objc_method_description</span> <span class="o">*</span> <span class="nf">method_getDescription</span> <span class="p">(</span> <span class="n">Method</span> <span class="n">m</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 设置方法的实现</span>
</span><span class='line'><span class="kt">IMP</span> <span class="nf">method_setImplementation</span> <span class="p">(</span> <span class="n">Method</span> <span class="n">m</span><span class="p">,</span> <span class="kt">IMP</span> <span class="n">imp</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 交换两个方法的实现</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">method_exchangeImplementations</span> <span class="p">(</span> <span class="n">Method</span> <span class="n">m1</span><span class="p">,</span> <span class="n">Method</span> <span class="n">m2</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>方法选择器</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 返回给定选择器指定的方法的名称</span>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="nf">sel_getName</span> <span class="p">(</span> <span class="kt">SEL</span> <span class="n">sel</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器</span>
</span><span class='line'><span class="kt">SEL</span> <span class="nf">sel_registerName</span> <span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 在Objective-C Runtime系统中注册一个方法</span>
</span><span class='line'><span class="kt">SEL</span> <span class="nf">sel_getUid</span> <span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 比较两个选择器</span>
</span><span class='line'><span class="kt">BOOL</span> <span class="nf">sel_isEqual</span> <span class="p">(</span> <span class="kt">SEL</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">rhs</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>库相关</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 获取所有加载的Objective-C框架和动态库的名称</span>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span> <span class="o">**</span> <span class="nf">objc_copyImageNames</span> <span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">outCount</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 获取指定类所在动态库</span>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="nf">class_getImageName</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 获取指定库或框架中所有类的类名</span>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span> <span class="o">**</span> <span class="nf">objc_copyClassNamesForImage</span> <span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">image</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">outCount</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[runtime应用之KVC]]></title>
    <link href="http://triplecc.github.io/blog/2015-01-21-runtimeying-yong-zhi-kvc/"/>
    <updated>2015-01-21T20:16:13+08:00</updated>
    <id>http://triplecc.github.io/blog/runtimeying-yong-zhi-kvc</id>
    <content type="html"><![CDATA[<p>runtime可以以底层的角度来对一些实现方式进行更改，比如说KVC<br>
首先，先来了解下KVC的底层原理:<br>
key : value</p>

<ul>
<li>1.去模型中查找有没有setValue:，直接调用这个对象setValue:赋值</li>
<li>2.如果没有setValue:，就在模型中查找_value属性</li>
<li>3.如果没有_value属性，就查找value属性</li>
<li>4.如果还没有就报错</li>
</ul>


<p>在和后台通信的JSON数据中，可能会看到这种JSON数据：<br></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="s">&quot;id&quot;</span> <span class="o">:</span> <span class="s">&quot;tripleCC&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s">&quot;age&quot;</span> <span class="o">:</span> <span class="s">&quot;30&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s">&quot;address&quot;</span> <span class="o">:</span> <span class="s">&quot;杭州&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="s">&quot;schooll&quot;</span> <span class="o">:</span> <span class="s">&quot;HDU&quot;</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中的id是什么？是Objective-C关键字，也就是说我不能定义以下属性：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="kt">id</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>由于数据模型名称没有和JSON的键值一一对应，我们不能使用以下方法，对模型中的成员变量进行统一设置：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setValuesForKeysWithDictionary:</span><span class="p">(</span><span class="bp">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">keyedValues</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>既然这样，可以选择手动一个个去实现。但是这样在数据少的时候可以试试，在数据比较多时就不太现实了，程序的可扩展性也不好。<br>
现在来了解下相对比较简单的两种解决方法：</p>

<h2>方式1.重写setValue:forKey:</h2>

<p>setValuesForKeysWithDictionary:的底层是调用setValue:forKey:的，所以可以考虑重写这个方法，并且判断其key是id时，手动转换成模型的成员变量名，这里假设把id对应成以下属性：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">nonatomic</span><span class="p">,</span> <span class="k">strong</span><span class="p">)</span> <span class="bp">NSString</span> <span class="o">*</span><span class="n">ID</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>有了对应的属性名后，就可以重写底层方法了：
  - 如下所示，当判断到key的值为id时，我手动将key转换成了模型属性名，即ID</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setValue:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">value</span> <span class="nf">forKey:</span><span class="p">(</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">key</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">([</span><span class="n">key</span> <span class="nl">isEqualToString</span><span class="p">:</span><span class="s">@&quot;id&quot;</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">value</span> <span class="nl">forKeyPath</span><span class="p">:</span><span class="s">@&quot;ID&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">super</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">value</span> <span class="nl">forKey</span><span class="p">:</span><span class="n">key</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样，当使用setValuesForKeysWithDictionary:就不会出现模型中找不到对应的成员变量的错误了。</p>

<h2>方式2.使用runtime</h2>

<p>考虑到runtime和KVC的实现原理，可以使用另一种实现思路，就是<code>先在模型中找到对应的成员变量，然后从JSON字典中找到对应的数据进行赋值</code>。<br>
这里先要了解runtime的两个实例变量操作方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 获取成员变量列表</span>
</span><span class='line'><span class="n">Ivar</span> <span class="o">*</span> <span class="nf">class_copyIvarList</span> <span class="p">(</span> <span class="kt">Class</span> <span class="n">cls</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">outCount</span> <span class="p">);</span>
</span><span class='line'><span class="c1">// 获取成员变量名</span>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="nf">ivar_getName</span> <span class="p">(</span> <span class="n">Ivar</span> <span class="n">v</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>详细实现步骤：<br></p>

<ul>
<li>1.获取模型中的所有实例变量</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">outCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">Ivar</span> <span class="o">*</span><span class="n">ivars</span> <span class="o">=</span> <span class="n">class_copyIvarList</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">outCount</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>2.将获取出来以'<em>&lsquo;开头的实例变量名去处&rsquo;</em>&lsquo;符号</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>   <span class="bp">NSString</span> <span class="o">*</span><span class="n">ivarName</span> <span class="o">=</span> <span class="l">@(</span><span class="n">ivar_getName</span><span class="p">(</span><span class="n">ivar</span><span class="p">)</span><span class="l">)</span><span class="p">;</span>
</span><span class='line'>   <span class="n">ivarName</span> <span class="o">=</span> <span class="p">[</span><span class="n">ivarName</span> <span class="nl">substringFromIndex</span><span class="p">:</span><span class="mi">1</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>3.获取JOSN字典中对应的value，如果没有，手动设置我们传入的字典映射，以指定对应的模型变量名，最后调用setValue:forKeyPath:设置模型实例变量值</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="n">value</span> <span class="o">=</span> <span class="n">dict</span><span class="p">[</span><span class="n">ivarName</span><span class="p">];</span>
</span><span class='line'><span class="c1">// 由外界通知内部，模型中成员变量名对应字典里面的哪个key</span>
</span><span class='line'><span class="c1">// 这里是ID -&gt; id</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 这里的mapDict就是外界传入的映射字典</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">mapDict</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="bp">NSString</span> <span class="o">*</span><span class="n">keyName</span> <span class="o">=</span> <span class="n">mapDict</span><span class="p">[</span><span class="n">ivarName</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">value</span> <span class="o">=</span> <span class="n">dict</span><span class="p">[</span><span class="n">keyName</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">[</span><span class="n">objc</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">value</span> <span class="nl">forKeyPath</span><span class="p">:</span><span class="n">ivarName</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>由于需要针对所有模型使用，可以将其设置为NSObject分类。以上步骤的完整代码为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// dict  -&gt; 资源文件提供的字典</span>
</span><span class='line'><span class="c1">// mapDict  -&gt; 提供的key映射（实际变量名:资源文件key）</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">objcWithDict:</span><span class="p">(</span><span class="bp">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">dict</span> <span class="nf">mapDict:</span><span class="p">(</span><span class="bp">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">mapDict</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">id</span> <span class="n">objc</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 遍历模型中成员变量</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">outCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="n">Ivar</span> <span class="o">*</span><span class="n">ivars</span> <span class="o">=</span> <span class="n">class_copyIvarList</span><span class="p">(</span><span class="nb">self</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">outCount</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Ivar</span> <span class="n">ivar</span> <span class="o">=</span> <span class="n">ivars</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 成员变量名称</span>
</span><span class='line'>        <span class="bp">NSString</span> <span class="o">*</span><span class="n">ivarName</span> <span class="o">=</span> <span class="l">@(</span><span class="n">ivar_getName</span><span class="p">(</span><span class="n">ivar</span><span class="p">)</span><span class="l">)</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 获取出来的是`_`开头的成员变量名，需要截取`_`之后的字符串</span>
</span><span class='line'>        <span class="n">ivarName</span> <span class="o">=</span> <span class="p">[</span><span class="n">ivarName</span> <span class="nl">substringFromIndex</span><span class="p">:</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">id</span> <span class="n">value</span> <span class="o">=</span> <span class="n">dict</span><span class="p">[</span><span class="n">ivarName</span><span class="p">];</span>
</span><span class='line'>        <span class="c1">// 由外界通知内部，模型中成员变量名对应字典里面的哪个key</span>
</span><span class='line'>        <span class="c1">// ID -&gt; id</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">mapDict</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="bp">NSString</span> <span class="o">*</span><span class="n">keyName</span> <span class="o">=</span> <span class="n">mapDict</span><span class="p">[</span><span class="n">ivarName</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>                <span class="n">value</span> <span class="o">=</span> <span class="n">dict</span><span class="p">[</span><span class="n">keyName</span><span class="p">];</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="p">[</span><span class="n">objc</span> <span class="nl">setValue</span><span class="p">:</span><span class="n">value</span> <span class="nl">forKeyPath</span><span class="p">:</span><span class="n">ivarName</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">objc</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">itemWithDict:</span><span class="p">(</span><span class="bp">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">dict</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 传入key和实例变量名的映射字典@{@&quot;ID&quot;:@&quot;id&quot;}</span>
</span><span class='line'>    <span class="n">TPCItem</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="p">[</span><span class="n">TPCItem</span> <span class="nl">objcWithDict</span><span class="p">:</span><span class="n">dict</span> <span class="nl">mapDict</span><span class="p">:</span><span class="l">@{</span><span class="s">@&quot;ID&quot;</span><span class="o">:</span><span class="s">@&quot;id&quot;</span><span class="l">}</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">item</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Runtime基础]]></title>
    <link href="http://triplecc.github.io/blog/2015-01-10-runtimeji-chu/"/>
    <updated>2015-01-10T20:14:17+08:00</updated>
    <id>http://triplecc.github.io/blog/runtimeji-chu</id>
    <content type="html"><![CDATA[<p>Objective-C的runtime语言使它具备了动态语言的特性，也就是平时所说的“运行时”。在runtime的基础上，可以做很多平时难以想到事，或者化简原先 较为繁杂的解决方案。<br>
相对于静态语言，比如C的以下程序</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">run</span><span class="p">()</span>
</span><span class='line'><span class="p">{}</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>执行<code>clang -c</code>进行编译后，获取符号表<code>nm run.o</code>，可以得到全局唯一的符号<code>_run</code>，对函数run的调用直接参考链接后_run符号在代码段的地址</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="mo">0000000000000010</span> <span class="n">T</span> <span class="n">_main</span>
</span><span class='line'><span class="mo">0000000000000000</span> <span class="n">T</span> <span class="n">_run</span>
</span></code></pre></td></tr></table></div></figure>


<p>对比Objective-C的以下函数<br></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">Dog</span> : <span class="bp">NSObject</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">run</span>
</span><span class='line'><span class="p">{}</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Dog</span> <span class="o">*</span><span class="n">dog</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Dog</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">dog</span> <span class="n">run</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>执行<code>clang -rewrite-objc main.m</code>将其转换成底层C++文件后可以得到</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="cm">/* @autoreleasepool */</span> <span class="p">{</span> <span class="n">__AtAutoreleasePool</span> <span class="n">__autoreleasepool</span><span class="p">;</span>
</span><span class='line'>        <span class="n">Dog</span> <span class="o">*</span><span class="n">dog</span> <span class="o">=</span> <span class="p">((</span><span class="n">Dog</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="kt">id</span><span class="p">)((</span><span class="n">Dog</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="kt">id</span><span class="p">)</span><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&quot;Dog&quot;</span><span class="p">),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;alloc&quot;</span><span class="p">)),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;init&quot;</span><span class="p">));</span>
</span><span class='line'>        <span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="kt">id</span><span class="p">)</span><span class="n">dog</span><span class="p">,</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;run&quot;</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到，对Objective-C编译前期，会将内部的方法调用，转换成调用<code>objc_msgSend</code>。也就是说，编译完成后，方法地址是不能确定的，需要在运行时，通过Selector进行查找，而这正是runtime的关键，也就是发送消息机制。</p>

<h2>runtime的基本要素</h2>

<p>如上面例子所示，在编译后<code>[dog run]</code>被编译器转化成了</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">((</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="kt">id</span><span class="p">)</span><span class="n">dog</span><span class="p">,</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;run&quot;</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 假设能省略(void (*)(id, SEL))(void *)和id指针强转[实际上还是需要的]</span>
</span><span class='line'><span class="c1">// sel_registerName表示注册一个selector</span>
</span><span class='line'><span class="n">objc_msgSend</span><span class="p">(</span><span class="n">dog</span><span class="p">,</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;run&quot;</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>将上面的情况抽取成统一的说法就是，在编译器编译后<code>[receiver message]</code>会被转化成以下形式</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">objc_msgSend</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">selector</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>objc_msgSend</code>是一个消息发送函数，它以消息接收者和方法名作为基础参数。<br>
在有参数的情况下，则会被转换为</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">objc_msgSend</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">selector</span><span class="p">,</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="p">...)</span>
</span></code></pre></td></tr></table></div></figure>


<p>消息的接收者receiver在接受到消息后，查找对应selector的实现，根据查找的结果可以进行若干种种不同的处理。<br>
更深层的了解，需要了解下对应的数据结构</p>

<h3>id</h3>

<p>上文中<code>objc_msgSend</code>的第一个参数有个强转类型，即id。id是可以指向对象的万能指针，查看runtime源码，得知其定义如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">objc_object</span> <span class="o">*</span><span class="kt">id</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// objc_object</span>
</span><span class='line'><span class="k">struct</span> <span class="n">objc_object</span> <span class="p">{</span>
</span><span class='line'><span class="nl">private</span><span class="p">:</span>
</span><span class='line'>    <span class="kt">isa_t</span> <span class="n">isa</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// isa_t</span>
</span><span class='line'><span class="k">union</span> <span class="kt">isa_t</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">Class</span> <span class="n">cls</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">uintptr_t</span> <span class="n">bits</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>根据<code>union</code>联合的存储空间以大成员的存储空间计算性质，可以猜测<code>isa_t</code>的作用只是真不同位数处理器的优化，我们可以直接这样表示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="n">objc_object</span> <span class="p">{</span>
</span><span class='line'><span class="nl">private</span><span class="p">:</span>
</span><span class='line'>    <span class="kt">Class</span> <span class="n">isa</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看出，<code>id</code>是一个指向<code>objc_object</code>结构体的指针（注意，在runtime中对象可以用结构体进行表示）。<br>
<code>objc_object</code>结构体包含了<code>Class isa</code>成员，而<code>isa</code>就是我们常说的创建一个对象时，用来指向所属类的<code>指针</code>。因此根据<code>isa</code>就可以获取对应的类。
- 注：C++中结构的作用被拓宽了，也表示定义一个类的类型，struct和class的区别就在默认类型上一个是public,一个是private，这里就直接描述为结构体了</p>

<h3>Class</h3>

<p>上文中，<code>isa</code>为<code>Class</code>类型，而<code>Class</code>则是<code>objc_class</code>指针类型的别名：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">objc_class</span> <span class="o">*</span><span class="kt">Class</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>而<code>objc_class</code>具体的定义如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="nl">objc_class</span> <span class="p">:</span> <span class="n">objc_object</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Class ISA;</span>
</span><span class='line'>    <span class="kt">Class</span> <span class="n">superclass</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">cache_t</span> <span class="n">cache</span><span class="p">;</span>             <span class="c1">// formerly cache pointer and vtable</span>
</span><span class='line'>    <span class="kt">class_data_bits_t</span> <span class="n">bits</span><span class="p">;</span>    <span class="c1">// class_rw_t * plus custom rr/alloc flags</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// class_data_bits_t</span>
</span><span class='line'><span class="k">struct</span> <span class="kt">class_data_bits_t</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="nl">public</span><span class="p">:</span>
</span><span class='line'>    <span class="kt">class_rw_t</span><span class="o">*</span> <span class="n">data</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">(</span><span class="kt">class_rw_t</span> <span class="o">*</span><span class="p">)(</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="n">FAST_DATA_MASK</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// class_rw_t</span>
</span><span class='line'><span class="k">struct</span> <span class="kt">class_rw_t</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">uint32_t</span> <span class="n">version</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="kt">class_ro_t</span> <span class="o">*</span><span class="n">ro</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">union</span> <span class="p">{</span>
</span><span class='line'>        <span class="kt">method_list_t</span> <span class="o">**</span><span class="n">method_lists</span><span class="p">;</span>  <span class="c1">// RW_METHOD_ARRAY == 1</span>
</span><span class='line'>        <span class="kt">method_list_t</span> <span class="o">*</span><span class="n">method_list</span><span class="p">;</span>    <span class="c1">// RW_METHOD_ARRAY == 0</span>
</span><span class='line'>    <span class="p">};</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">chained_property_list</span> <span class="o">*</span><span class="n">properties</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">protocol_list_t</span> <span class="o">**</span> <span class="n">protocols</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">Class</span> <span class="n">firstSubclass</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">Class</span> <span class="n">nextSiblingClass</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">char</span> <span class="o">*</span><span class="n">demangledName</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// class_ro_t</span>
</span><span class='line'><span class="k">struct</span> <span class="kt">class_ro_t</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">uint32_t</span> <span class="n">instanceStart</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">uint32_t</span> <span class="n">instanceSize</span><span class="p">;</span>
</span><span class='line'><span class="cp">#ifdef __LP64__</span>
</span><span class='line'>    <span class="kt">uint32_t</span> <span class="n">reserved</span><span class="p">;</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span> <span class="n">ivarLayout</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">name</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">method_list_t</span> <span class="o">*</span> <span class="n">baseMethods</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">protocol_list_t</span> <span class="o">*</span> <span class="n">baseProtocols</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">ivar_list_t</span> <span class="o">*</span> <span class="n">ivars</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span> <span class="n">weakIvarLayout</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">property_list_t</span> <span class="o">*</span><span class="n">baseProperties</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上文中已经介绍过<code>objc_object</code>结构体，<code>objc_class</code>继承自结构体<code>objc_object</code>。可以看出<code>objc_object</code>的<code>isa</code>为<code>private</code>类型成员变量，<code>objc_class</code>继承后无法访问，所以<code>objc_object</code>提供了以下两个成员函数:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">Class</span> <span class="nf">ISA</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// getIsa内部调用ISA返回isa_t联合中cls成员</span>
</span><span class='line'><span class="kt">Class</span> <span class="nf">getIsa</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>所以，对<code>objc_class</code>重要的成员变量进行下解释:</p>

<ul>
<li><code>isa</code>为指向对象对应类的指针（这里注意一点，由于类也是一个对象（单例），所以这个单例中也有一个<code>isa</code>指针指向类对象所属的类-><code>metaClass</code>，即元类）</li>
<li><code>superclass</code>为指向父类的指针</li>
<li><code>cache</code>用于对调用方法的缓存，类似CPU先访问L1、L2、L3缓存的目的相似，它也是推断<code>最近调用的方法极有可能被二次调用</code>，并将其存入<code>cache</code>，在二次调用时先在<code>cache</code>查找方法，而不是直接在类的方法列表中查找</li>
<li><code>properties</code>为属性列表</li>
<li><code>protocols</code>为协议列表</li>
<li><code>method_lists</code>/<code>method_list</code>为方法列表</li>
<li><code>ivars</code>为成员变量列表</li>
<li><code>class_ro_t</code>结构体中存储的都是类基本的东西，比如获取<code>'load'</code>方法时，是从<code>baseMethods</code>获取相应的IMP函数实现的：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">IMP</span> <span class="n">objc_class</span><span class="o">::</span><span class="n">getLoadMethod</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">rwlock_assert_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">runtimeLock</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">const</span> <span class="kt">method_list_t</span> <span class="o">*</span><span class="n">mlist</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">uint32_t</span> <span class="n">i</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="n">isRealized</span><span class="p">());</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="n">ISA</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isRealized</span><span class="p">());</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">isMetaClass</span><span class="p">());</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="n">ISA</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isMetaClass</span><span class="p">());</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">mlist</span> <span class="o">=</span> <span class="n">ISA</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">ro</span><span class="o">-&gt;</span><span class="n">baseMethods</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">mlist</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">mlist</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="kt">method_t</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">method_list_nth</span><span class="p">(</span><span class="n">mlist</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span><span class='line'>            <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">sel_cname</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;load&quot;</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">imp</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中先了解下<code>ivar_list_t</code>、<code>method_list_t</code>、<code>cache_t</code>的结构定义：<br></p>

<p><code>ivar_list_t</code>的结构为：</p>

<ul>
<li><code>ivar_t</code>就是对应的成员变量</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="kt">ivar_list_t</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">uint32_t</span> <span class="n">entsize</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">uint32_t</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">ivar_t</span> <span class="n">first</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>method_list_t</code>为：</p>

<ul>
<li>其中<code>method_iterator</code>为结构体自己构造的一个迭代器，用来访问方法，可以看到，构造的迭代器结构体中包含了<code>method</code>成员变量</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="kt">method_list_t</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">uint32_t</span> <span class="n">entsize_NEVER_USE</span><span class="p">;</span>  <span class="c1">// high bits used for fixup markers</span>
</span><span class='line'>    <span class="kt">uint32_t</span> <span class="n">count</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">method_t</span> <span class="n">first</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// iterate methods, taking entsize into account</span>
</span><span class='line'>    <span class="c1">// fixme need a proper const_iterator</span>
</span><span class='line'>    <span class="k">struct</span> <span class="n">method_iterator</span> <span class="p">{</span>
</span><span class='line'>      <span class="kt">uint32_t</span> <span class="n">entsize</span><span class="p">;</span>
</span><span class='line'>        <span class="kt">uint32_t</span> <span class="n">index</span><span class="p">;</span>  <span class="c1">// keeping track of this saves a divide in operator-</span>
</span><span class='line'>        <span class="kt">method_t</span><span class="o">*</span> <span class="n">method</span><span class="p">;</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>cache_t</code>为：</p>

<ul>
<li>可以看出<code>bucket_t</code>包含了一个<code>IMP</code>类型的私有成员，供查找后调用实现</li>
<li><code>_occupied</code>和<code>_mask</code>分别表示<code>实际占用</code>的缓存<em>buckets总数和<code>分配</code>的缓存</em>buckets总数</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">struct</span> <span class="kt">cache_t</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">struct</span> <span class="kt">bucket_t</span> <span class="o">*</span><span class="n">_buckets</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">mask_t</span> <span class="n">_mask</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">mask_t</span> <span class="n">_occupied</span><span class="p">;</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// bucket_t</span>
</span><span class='line'><span class="k">struct</span> <span class="kt">bucket_t</span> <span class="p">{</span>
</span><span class='line'><span class="nl">private</span><span class="p">:</span>
</span><span class='line'>    <span class="kt">cache_key_t</span> <span class="n">_key</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">IMP</span> <span class="n">_imp</span><span class="p">;</span>
</span><span class='line'><span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上文还涉及到了一个概念<code>metaClass</code>元类，元类为类对象所属的类，以实例解释：<br>
当我们调用类方法时，消息的接收者即为类，如文中一开始的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">Dog</span> <span class="o">*</span><span class="n">dog</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Dog</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的<code>alloc</code>消息即发送给了<code>Dog</code>类，编译转换后的代码为:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">Dog</span> <span class="o">*</span><span class="n">dog</span> <span class="o">=</span> <span class="p">((</span><span class="n">Dog</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="kt">id</span><span class="p">)((</span><span class="n">Dog</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="kt">id</span><span class="p">)</span><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&quot;Dog&quot;</span><span class="p">),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;alloc&quot;</span><span class="p">)),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;init&quot;</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们只需要关注这一行：</p>

<ul>
<li>这里获取到的是类对象，只要再获取一次就得到了元类</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// objc_getClass表示根据对象名获取对应的类</span>
</span><span class='line'><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&quot;Dog&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 获取元类</span>
</span><span class='line'><span class="n">objc_getClass</span><span class="p">(</span><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&quot;Dog&quot;</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>关于元类，苹果提供了这么一张表：<br>
<img src="./image/Snip20150711_1.png" alt="" /><br>
图中的实线是<code>superclass</code>指针，虚线是<code>isa</code>指针。可以看到，根元类的超类<code>NSObject</code>(Root class)并没有对应的超类，并且，它的<code>isa</code>指针指向了自己。
总结一下：</p>

<ul>
<li>每个实例对象的<code>isa</code>都指向了所属的<code>类</code></li>
<li>每个类对象的<code>isa</code>都指向了所属的类，即<code>元类</code>，其<code>superclass</code>指针指向继承的<code>父类</code></li>
<li>每个元类的<code>isa</code>都指向了<code>超类</code>，即<code>NSObject</code></li>
</ul>


<h3>Ivar</h3>

<p><code>Ivar</code>，我把它理解成<code>instance variable</code>，也就是实例变量，可以观察它的定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="kt">ivar_t</span> <span class="o">*</span><span class="n">Ivar</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// ivar_t</span>
</span><span class='line'><span class="k">struct</span> <span class="kt">ivar_t</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int32_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// alignment is sometimes -1; use alignment() instead</span>
</span><span class='line'>    <span class="kt">uint32_t</span> <span class="n">alignment_raw</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// 内存中数据对齐（如字对齐、半字对齐等）</span>
</span><span class='line'>    <span class="kt">uint32_t</span> <span class="nf">alignment</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">alignment_raw</span> <span class="o">==</span> <span class="o">~</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1U</span> <span class="o">&lt;&lt;</span> <span class="n">WORD_SHIFT</span><span class="p">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">alignment_raw</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>Ivar</code>其实是指向<code>ivar_t</code>结构体的指针，它包含了实例变量名（name）、类型（type）、相对对象地址偏移（offset）以及内存数据对齐等信息。<br>
跟多关于实例变量的剖析可以查看<a href="http://quotation.github.io/objc/2015/05/21/objc-runtime-ivar-access.html">Objective-C类成员变量深度剖析</a></p>

<h3>Method</h3>

<p>从以下定义的结构体可以看出，<code>Method</code>主要住用为关联了方法名<code>SEL</code>和方法的实现<code>IMP</code>，当遍通过<code>Method</code>自己的定义的迭代器查找方法名<code>SEL</code>时，就可以找到对应的方法实现<code>IMP</code>，从而调用方法的实现执行相关的操作。<code>types</code>表示方法实现的参数以及返回值类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="kt">method_t</span> <span class="o">*</span><span class="n">Method</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// method_t</span>
</span><span class='line'><span class="k">struct</span> <span class="kt">method_t</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">SEL</span> <span class="n">name</span><span class="p">;</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">types</span><span class="p">;</span>
</span><span class='line'>    <span class="kt">IMP</span> <span class="n">imp</span><span class="p">;</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>SEL</h3>

<p><code>SEL</code>为方法选择器，观察下它的定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">objc_selector</span> <span class="o">*</span><span class="kt">SEL</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看出<code>SEL</code>实际是<code>objc_selector</code>指针类型的别名，它用于表示运行时方法的名字，以便进行方法实现的查找。因为要对应方法实现，所以每一个方法对应的<code>SEL</code>都是唯一的。因此它不具备C++可以进行函数重载的特性，当两个方法名一样时，会发生编译错误，即使参数不一样。</p>

<h3>IMP</h3>

<p><code>IMP</code>的定义如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#if !OBJC_OLD_DISPATCH_PROTOTYPES</span>
</span><span class='line'><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="kt">IMP</span><span class="p">)(</span><span class="kt">void</span> <span class="cm">/* id, SEL, ... */</span> <span class="p">);</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'><span class="k">typedef</span> <span class="nf">id</span> <span class="p">(</span><span class="o">*</span><span class="kt">IMP</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">,</span> <span class="p">...);</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看出<code>IMP</code>其实就是一个函数指针的别名，也可以把它理解为函数名。它有两个必须的参数：<br></p>

<ul>
<li><code>id</code>，为<code>self</code>指针，表示消息接收者</li>
<li><code>SEL</code>，方法选择器，表示一个方法的<code>selector</code>指针</li>
<li>后面的为传送消息的一些参数<br></li>
</ul>


<p>在某些情况下，通过获取<code>IMP</code>而直接调用方法实现，可以直接跳过消息传递机制，像C语言调用函数那样，在一定程度上，可以提供程序的性能。</p>

<h3>消息传递</h3>

<p>了解完runtime中一些必要的元素，继续回到文章开头的代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">Dog</span> : <span class="bp">NSObject</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">run</span>
</span><span class='line'><span class="p">{}</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Dog</span> <span class="o">*</span><span class="n">dog</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Dog</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>        <span class="p">[</span><span class="n">dog</span> <span class="n">run</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>编译器将其转换成了：
  - 为了看起来简洁点，我把一些强制转换变为别名</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="p">(</span><span class="n">Dog</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="n">MyImp</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="cm">/* @autoreleasepool */</span> <span class="p">{</span> <span class="n">__AtAutoreleasePool</span> <span class="n">__autoreleasepool</span><span class="p">;</span>
</span><span class='line'>        <span class="n">Dog</span> <span class="o">*</span><span class="n">dog</span> <span class="o">=</span> <span class="p">((</span><span class="n">MyImp</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="kt">id</span><span class="p">)((</span><span class="n">MyImp</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="kt">id</span><span class="p">)</span><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&quot;Dog&quot;</span><span class="p">),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;alloc&quot;</span><span class="p">)),</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;init&quot;</span><span class="p">));</span>
</span><span class='line'>        <span class="p">((</span><span class="n">MyImp</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="kt">id</span><span class="p">)</span><span class="n">dog</span><span class="p">,</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;run&quot;</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从上面的代码可以看出，第二个<code>objc_msgSend</code>返回值是作为第一个<code>objc_msgSend</code>的首个参数的。<br>
上文已经说过，<code>[receiver message]</code>会被转化成以下形式</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">objc_msgSend</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">selector</span><span class="p">,</span> <span class="p">...)</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来看看它主要做了哪几件事情：</p>

<ul>
<li>根据<code>receiver</code>的<code>isa</code>指针，获取到所属类，先在类的<code>cache</code>即缓存中查找<code>selector</code>，如果没有找到，再在类的<code>method_lists</code>即方法列表中查找</li>
<li>如果没有找到<code>selector</code>，则会沿着下图类的联系路径一直查找，直到<code>NSObject</code>类</li>
<li>如果找到了<code>selector</code>，则获取实现方法并调用，并传入接收者对象以及方法的所有参数；没有找到时走方法解析和消息转发流程。</li>
<li>将实现的返回值作为它自己的返回值<br>
<img src="./image/Snip20150711_2.png" alt="" /></li>
</ul>


<p>除此之外，<code>objc_msgSend</code>还会传递两个隐藏参数：</p>

<ul>
<li>消息接收对象（<code>self</code>引用的对象）</li>
<li>方法选择器（<code>_cmd</code>，调用的方法）</li>
</ul>


<p><code>objc_msgSend</code>找到方法实现后，会在调用该实现时，传入这两个隐藏参数，这样就能够在方法实现里面里面获取消息接受对象，即方法调用者了。<br>
<code>隐藏参数</code>表示这两个参数在源代码方法的定义中并没有声明这两个参数，这两个参数是在<code>代码编译期间</code>，被<code>插入</code>到实现中的。</p>

<h3>self和super的联系</h3>

<p>根据上文对<code>objc_msgSend</code>的了解，可以解决以下代码输出一致问题</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">Dog</span> : <span class="bp">NSObject</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">run</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nb">self</span> <span class="k">class</span><span class="p">]);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nb">super</span> <span class="k">class</span><span class="p">]);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">@autoreleasepool</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Dog</span> <span class="o">*</span><span class="n">dog</span> <span class="o">=</span> <span class="p">[[</span><span class="n">Dog</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">[</span><span class="n">dog</span> <span class="n">run</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="mi">5491</span><span class="o">:</span><span class="mi">173185</span><span class="p">]</span> <span class="n">Dog</span>
</span><span class='line'><span class="p">[</span><span class="mi">5491</span><span class="o">:</span><span class="mi">173185</span><span class="p">]</span> <span class="n">Dog</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是为什么呢？先来看看编译后的<code>-run</code>方法的情况:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">_I_Dog_run</span><span class="p">(</span><span class="n">Dog</span> <span class="o">*</span> <span class="nb">self</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">_cmd</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">((</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_50_3f5nr6h10h1csn8byghy30q80000gn_T_main_d06ff4_mi_0</span><span class="p">,</span> <span class="p">((</span><span class="kt">Class</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="kt">id</span><span class="p">)</span><span class="nb">self</span><span class="p">,</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;class&quot;</span><span class="p">)));</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">((</span><span class="bp">NSString</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">__NSConstantStringImpl__var_folders_50_3f5nr6h10h1csn8byghy30q80000gn_T_main_d06ff4_mi_1</span><span class="p">,</span> <span class="p">((</span><span class="kt">Class</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">__rw_objc_super</span> <span class="o">*</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSendSuper</span><span class="p">)((</span><span class="n">__rw_objc_super</span><span class="p">){</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nb">self</span><span class="p">,</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">class_getSuperclass</span><span class="p">(</span><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&quot;Dog&quot;</span><span class="p">))</span> <span class="p">},</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;class&quot;</span><span class="p">)));</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里面只要关注两句：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// [self class]</span>
</span><span class='line'><span class="p">((</span><span class="kt">Class</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSend</span><span class="p">)((</span><span class="kt">id</span><span class="p">)</span><span class="nb">self</span><span class="p">,</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;class&quot;</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// [super class]</span>
</span><span class='line'><span class="p">((</span><span class="kt">Class</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">__rw_objc_super</span> <span class="o">*</span><span class="p">,</span> <span class="kt">SEL</span><span class="p">))(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">objc_msgSendSuper</span><span class="p">)((</span><span class="n">__rw_objc_super</span><span class="p">){</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nb">self</span><span class="p">,</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">class_getSuperclass</span><span class="p">(</span><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&quot;Dog&quot;</span><span class="p">))</span> <span class="p">},</span> <span class="n">sel_registerName</span><span class="p">(</span><span class="s">&quot;class&quot;</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>首先我们需要了解<code>self</code>和<code>super</code>的差异：</p>

<ul>
<li><code>super</code>：<code>编译标识符</code>，告诉编译器，调用方法时，去调用父类的方法，而不是本类的方法</li>
<li><code>self</code>：<code>隐藏参数</code>，每个方法的实现第一个参数就是<code>self</code></li>
</ul>


<p>这里可以看出，编译后，经过<code>super</code>标识符修饰的方法调用，会调用<code>objc_msgSendSuper</code>函数来进行消息的发送，而不是<code>objc_msgSend</code>。先来了解下<code>objc_msgSendSuper</code>的声明：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="nf">objc_msgSendSuper</span> <span class="p">(</span> <span class="k">struct</span> <span class="n">objc_super</span> <span class="o">*</span><span class="nb">super</span><span class="p">,</span> <span class="kt">SEL</span> <span class="n">op</span><span class="p">,</span> <span class="p">...</span> <span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中<code>objc_super</code>的定义为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// receiver   消息实际接收者</span>
</span><span class='line'><span class="c1">// class      指向当前类的父类</span>
</span><span class='line'><span class="k">struct</span> <span class="n">objc_super</span> <span class="p">{</span> <span class="kt">id</span> <span class="n">receiver</span><span class="p">;</span> <span class="kt">Class</span> <span class="k">class</span><span class="p">;</span> <span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>结合以上信息，我们可以知道：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">(</span><span class="n">__rw_objc_super</span><span class="p">){</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nb">self</span><span class="p">,</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="n">class_getSuperclass</span><span class="p">(</span><span class="n">objc_getClass</span><span class="p">(</span><span class="s">&quot;Dog&quot;</span><span class="p">))</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>就是对结构体<code>objc_super</code>的赋值，也就是说<code>objc_super-&gt;receiver=self</code>。到这里可能就有点明了了，<code>super</code>只是告诉编译器，去查找父类中的<code>class</code>方法，当找到之后，使用<code>objc_super-&gt;receiver</code>即<code>self</code>进行调用。用流程表示就是：<br>
<code>[super class]-&gt;objc_msgSendSuper(objc_super{self, superclass)}, sel_registerName("class"))-&gt;objc_msgSend(objc_super-&gt;self, sel_registerName("class"))＝[self class]</code>。<br>
可以看出两者输出结果一致的关键就是，<code>[self class]</code>的消息接收者和<code>[super class]</code>的消息接收者一样，都是调用方法的实例对象。</p>

<h3>方法解析和消息转发</h3>

<p>当上文<code>objc_msgSend</code>处理流程中，<code>selector</code>没有找到时，会触发三个阶段，在这三个阶段都可以进行相关处理使程序不抛出异常：
- Method Resolution  (动态方法解析)
- Fast Forwarding    (备用接收者)
- Normal Forwarding  (完整转发)<br></p>

<p>由于实际代码中很少有看到这种操作，所以这里不做详细解释，参考这个资料即可<a href="http://southpeak.github.io/blog/2014/11/03/objective-c-runtime-yun-xing-shi-zhi-san-:fang-fa-yu-xiao-xi-zhuan-fa/">Objective-C Runtime 运行时之三：方法与消息</a></p>

<h3>参考</h3>

<p>1.<a href="http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/">Objective-C Runtime 运行时之一：类与对象</a><br>
2.<a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/">Objective-C Runtime</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Autorezing的应用]]></title>
    <link href="http://triplecc.github.io/blog/2013-08-04-autorezingde-ying-yong/"/>
    <updated>2013-08-04T21:34:02+08:00</updated>
    <id>http://triplecc.github.io/blog/autorezingde-ying-yong</id>
    <content type="html"><![CDATA[<h2>Autoresizing的使用［前提是关闭Autolayout功能］</h2>

<ol>
<li><p>在xib/storyboard中使用：</p></li>
</ol>


<p><img src="./images/Snip20150531_2.png" alt="" /></p>

<p>如图，在左边剪头中表示控件的左边和上边相对父控件固定，并且长度和高度可变，在右边箭头中可以实时查看具体的效果。</p>

<p>原图：
<img src="./images/Snip20150531_8.png" alt="" /></p>

<p>在Preview界面中的效果如图：</p>

<p><img src="./images/Snip20150531_3.png" alt="" /></p>

<p>可以看出对于不同屏幕大小或者横竖屏情况，控件始终在右下角，不会被覆盖。</p>

<ol>
<li><p>Autoresizing代码使用：</p></li>
</ol>


<p>UIViewAutoresizing提供以下枚举类型来对视图进行限制：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'> <span class="n">UIViewAutoresizingNone</span>                 <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 这里主要注意如左边可伸缩，则表示右边为固定值</span>
</span><span class='line'> <span class="n">UIViewAutoresizingFlexibleLeftMargin</span>   <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="err">距离父控件左边的间距是伸缩的（不固定的）</span>
</span><span class='line'> <span class="n">UIViewAutoresizingFlexibleRightMargin</span>  <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="err">距离父控件右边的间距是伸缩的（不固定的）</span>
</span><span class='line'> <span class="n">UIViewAutoresizingFlexibleTopMargin</span>    <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span> <span class="err">距离父控件顶部的间距是伸缩的（不固定的）</span>
</span><span class='line'> <span class="n">UIViewAutoresizingFlexibleBottomMargin</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">5</span><span class="p">,</span> <span class="err">距离父控件底部的间距是伸缩的（不固定的）</span>
</span><span class='line'>
</span><span class='line'> <span class="n">UIViewAutoresizingFlexibleWidth</span>        <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="err">宽度跟随父控件的宽度进行自动伸缩</span>
</span><span class='line'> <span class="n">UIViewAutoresizingFlexibleHeight</span>       <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">,</span> <span class="err">高度跟随父控件的高度进行自动伸缩</span>
</span></code></pre></td></tr></table></div></figure>


<p>将对应的autoresizingMask属性赋上面值即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 固定与父控件的flet、top间距，并让宽度可变</span>
</span><span class='line'><span class="nb">self</span><span class="p">.</span><span class="n">myView</span><span class="p">.</span><span class="n">autoresizingMask</span> <span class="o">=</span> <span class="n">UIViewAutoresizingFlexibleRightMargin</span> <span class="o">|</span> <span class="n">UIViewAutoresizingFlexibleBottomMargin</span> <span class="o">|</span> <span class="n">UIViewAutoresizingFlexibleWidth</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>原图：
<img src="./images/Snip20150531_5.png" alt="" /></p>

<p>翻转图：
<img src="./images/Snip20150531_6.png" alt="" /></p>

<h2>Autoresizing的特点：</h2>

<ul>
<li>子控件可以跟随父控件的行为自动发生相应的变化</li>
<li>前提是：<strong>关闭Autolaout功能</strong></li>
<li>局限性

<ul>
<li><strong>只能</strong>解决<strong>子控件跟父控件</strong>的相对关系问题</li>
<li><strong>不能</strong>解决<strong>兄弟控</strong>件的相对关系</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UNIX系统信号]]></title>
    <link href="http://triplecc.github.io/blog/2013-05-15-unixxi-tong-xin-hao/"/>
    <updated>2013-05-15T11:46:30+08:00</updated>
    <id>http://triplecc.github.io/blog/unixxi-tong-xin-hao</id>
    <content type="html"><![CDATA[<h3>pag233</h3>

<p>信号都被定义为正整数。<br>
不存在编号为0的信号。<br>
不能捕捉SIGKILL和SIGSTOP信号。<br>
信号的处理：</p>

<ul>
<li>1，忽略信号</li>
<li>2，捕捉信号</li>
<li>3，执行系统默认动作（大多数信号默认动作时终止进程）</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">signal</span> <span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">fun</span><span class="p">)(</span><span class="kt">int</span><span class="p">)))(</span><span class="kt">int</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>fun：</p>

<ul>
<li>1、SIG_IGN  忽略信号</li>
<li>2、SIG_DFL 默认（通常时关闭）</li>
<li>3、调用函数地址</li>
<li>缺点：不改变信号的处理方式就不能确定信号的当前处理方式。</li>
</ul>


<p>exec将原先设置为<code>要捕捉的信号</code>都更改为他们的<code>默认动作</code>，<code>其他信号</code>的状态则<code>不变</code>（对于一个进程原先要捕捉的信号，当其执行一个新程序后，就自然不能捕捉他了，因为信号捕捉函数的地址很可能在所执行的新程序文件中已无意义）</p>

<h3>pag244</h3>

<p>当捕捉到某个信号时被中断的是内核中执行的系统调用。
不可重入函数特征：</p>

<ul>
<li>1，使用静态数据结构</li>
<li>2，调用malloc或free</li>
<li>3，标准IO函数</li>
</ul>


<p>信号的阻塞就是让系统暂时保留信号留待以后发送</p>

<p><code>sigaction可设置SA_NOCLDWAIT标志以避免子进程僵死</code>（这样就不用执行信号处理函数再waitpid了）</p>

<h3>pag250</h3>

<h6>信号未决：</h6>

<p>在信号产生和递送之间的时间间隔内，称信号是未决的。</p>

<p>若同一种信号多次发生，通常并不将他们排队，所以如果在某种信号被阻塞时他发生了五次，那么对这种信号解除阻塞后，其信号处理函数通常只会被调用一次。</p>

<p><code>当执行信号处理程序时，若新信号（相同信号）抵达，signal默认将该信号加入进程的信号队列中，直至信号处理程序执行结束。（多次抵达只取第一次）（现在在ubuntu上实测signal是这样的，APUE上面是不自动阻塞,执行信号默认操作）</code></p>

<h6>发送信号：</h6>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="n">kill</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
</span><span class='line'><span class="kt">int</span> <span class="n">raise</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span> <span class="c1">//给自身发送信号</span>
</span><span class='line'><span class="err">调用</span><span class="n">kill</span><span class="err">为调用进程产生信号，而且此信号是不被阻塞的，那么在</span><span class="n">kill</span><span class="err">返回之前，就会将</span><span class="n">signo</span><span class="err">或者某个其他未决的非阻塞信号传送至该进程。</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">alarm</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="n">intseconds</span> <span class="p">)</span> <span class="c1">//每个进程只能有一个闹钟时钟</span>
</span><span class='line'><span class="kt">int</span> <span class="n">pause</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span><span class="c1">//使调用进程挂起直至捕捉到一个信号并从信号处理程序返回</span>
</span></code></pre></td></tr></table></div></figure>


<h3>pag256</h3>

<p><code>所有应用程序在使用信号集前，要对该信号集调用sigemptyset或sigfillset一次.(因c编译器把未赋初值的外部和静态变量都初始化为0)</code></p>

<h6>信号集：</h6>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="n">sigemptyset</span><span class="p">(</span> <span class="kt">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">)</span>  <span class="c1">//清除信号集所有信号</span>
</span><span class='line'><span class="kt">int</span> <span class="n">sigfillset</span><span class="p">(</span> <span class="kt">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">)</span>     <span class="c1">//设置所有信号</span>
</span><span class='line'><span class="kt">int</span> <span class="n">sigaddset</span><span class="p">(</span> <span class="kt">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="n">intsigno</span> <span class="p">)</span> <span class="c1">//向信号集中添加信号（要阻塞的）</span>
</span><span class='line'><span class="kt">int</span> <span class="n">sigdelset</span><span class="p">(</span> <span class="kt">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span> <span class="n">intsigno</span> <span class="p">)</span>   <span class="c1">//从信号集中移除信号</span>
</span><span class='line'><span class="kt">int</span> <span class="n">sigismember</span><span class="p">(</span> <span class="k">const</span> <span class="kt">sigset_t</span> <span class="o">*</span><span class="n">set</span><span class="p">,</span><span class="kt">int</span> <span class="n">signo</span> <span class="p">)</span>  <span class="c1">//测试信号是否在信号集中</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="n">sigprocmask</span><span class="p">(</span> <span class="kt">int</span> <span class="n">how</span><span class="p">,</span> <span class="kt">constsigset_t</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">set</span><span class="p">,</span> <span class="kt">sigset_t</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">oset</span><span class="p">)</span><span class="c1">//oset返回当前屏蔽字（处理单线程）</span>
</span></code></pre></td></tr></table></div></figure>


<p>how：</p>

<ul>
<li>1、SIG_BLOCK 将当前信号屏蔽字和set指向信号集的相并</li>
<li>2、SIG_UNBLOCK 将当前信号屏蔽字和set指向信号集补集的相交</li>
<li>3、SIG_SETMASK 进程新的信号屏蔽字被set指向的信号集代替
sigprocmask仅为<code>单线程的进程</code>定义。pthread_sigmask为多线程进程定义</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">sigpending</span> <span class="p">(</span> <span class="kt">sigset_t</span> <span class="o">*</span><span class="n">set</span> <span class="p">)</span>
</span><span class='line'><span class="err">返回信号集，其中各个信号对于调用进程时阻塞的而不能递送，因而也一定是当前未决的。</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">sigaction</span><span class="p">(</span> <span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="k">const</span> <span class="n">structsigaction</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">act</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sigaction</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">oact</span> <span class="p">)</span>
</span><span class='line'><span class="n">oact</span> <span class="err">非空时返回该信号的上一次动作（包括信号屏蔽字）</span>
</span><span class='line'><span class="k">struct</span> <span class="n">sigaction</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">sa_handler</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>  <span class="c1">//信号捕捉函数地址</span>
</span><span class='line'>    <span class="n">sigset_tsa_mask</span><span class="p">;</span>       <span class="c1">//信号集。调用信号捕捉函数之前，此信号集加到进程信号集中，捕捉函数返回时恢复为原值（这里的捕捉信号函数之前这个说法要注意，下说明）</span>
</span><span class='line'>   <span class="kt">int</span>         <span class="n">sa_flags</span><span class="p">;</span>   <span class="c1">//指定对信号处理的各个选项</span>
</span><span class='line'>    <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="n">sa_sigaction</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">siginfo_t</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span><span class="p">);</span>   <span class="c1">//替代的信号处理程序（2个处理函数只能选其一）</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在信号处理程序被调用时，操作系统建立的新信号屏蔽字包括正在被递送的信号，因此保证了在处理一个给定信号时，如果这种信号再次发生，那么他会被阻塞到对前一个信号的处理结束为止。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#include &lt;signal.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;stdio.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;stdlib.h&gt;  </span>
</span><span class='line'>
</span><span class='line'><span class="kt">sigset_t</span>    <span class="n">sigmask</span><span class="p">;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">sigaction</span>    <span class="n">act</span><span class="p">,</span> <span class="n">oact</span><span class="p">;</span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span>
</span><span class='line'><span class="nf">sig_handler</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">signo</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">sigprocmask</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigmask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;sigprocmask error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">sigismember</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigmask</span><span class="p">,</span> <span class="n">SIGALRM</span><span class="p">))</span>
</span><span class='line'>        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">SIGALRM have been masked in handle function</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">sigismember</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigmask</span><span class="p">,</span> <span class="n">SIGINT</span><span class="p">))</span>
</span><span class='line'>        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;SIGINT has been masked in handle function</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;handle signal</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigmask</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">act</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">);</span>
</span><span class='line'>    <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">act</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">,</span> <span class="n">SIGALRM</span><span class="p">);</span>
</span><span class='line'>    <span class="n">act</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">sig_handler</span><span class="p">;</span>
</span><span class='line'>    <span class="n">act</span><span class="p">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">sigaction</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">act</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oact</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;sigaction error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">sigismember</span><span class="p">(</span><span class="o">&amp;</span><span class="n">oact</span><span class="p">.</span><span class="n">sa_mask</span><span class="p">,</span> <span class="n">SIGALRM</span><span class="p">))</span>
</span><span class='line'>        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;SIGALRM has already been masked</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">sigprocmask</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigmask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;sigprocmask error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">sigismember</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigmask</span><span class="p">,</span> <span class="n">SIGALRM</span><span class="p">))</span>
</span><span class='line'>        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;SIGALRM has been masked in main process</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">sigismember</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sigmask</span><span class="p">,</span> <span class="n">SIGINT</span><span class="p">))</span>
</span><span class='line'>        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;SIGINT has been masked in main process</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">pause</span><span class="p">();</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>程序输出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="o">^</span><span class="n">C</span>
</span><span class='line'><span class="n">SIGALRM</span> <span class="n">have</span> <span class="n">been</span> <span class="n">masked</span> <span class="k">in</span> <span class="n">handle</span> <span class="n">function</span>    <span class="c1">//1</span>
</span><span class='line'><span class="n">SIGINT</span> <span class="n">has</span> <span class="n">been</span> <span class="n">masked</span> <span class="k">in</span> <span class="n">handle</span> <span class="n">function</span>           <span class="c1">//2</span>
</span><span class='line'><span class="n">done</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>1：（说明sigaction在处理信号时才将sa_mask信号集添加进进程信号屏蔽字，书上的在“调用捕捉函数之前加入”这句让我理解错误了，以为调用sigaction以后就加入信号屏蔽字，捕捉信号，并从信号处理函数返回以前都是阻塞sa_mask中的信号的，实际上只有在信号处理函数中才阻塞sa_mask中的信号，和2中的差不多，只不过一个是系统自动添加，一个是人为设定信号集通过sigaction添加到进程信号屏蔽字），可能书中“在调用该信号的捕捉函数之前”的意思是：已经捕捉到信号了，但是还没且将要执行信号处理函数，这样就和输出结果一致了。。</code></li>
<li>2：<code>（说明系统在处理信号时会将正在处理的信号加入进程信号屏蔽字）</code></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="n">sigsuspend</span><span class="p">(</span><span class="k">const</span> <span class="kt">sigset_t</span> <span class="o">*</span><span class="n">sigmask</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h6>原子操作：</h6>

<p>先恢复成sigmask指定的信号屏蔽字，再使进程休眠<br>
在捕捉到一个信号或发生了一个会终止该进程的信号之前，该进程被挂起。如果捕捉到一个信号而且从该信号处理程序返回，则sigsuspend返回，并将信号屏蔽字设置为调用sigsuspend之前的值（<code>设定----捕捉----处理----恢复</code>）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sleep</span><span class="err">（</span><span class="kt">unsigned</span> <span class="n">intseconds</span><span class="err">）</span>
</span></code></pre></td></tr></table></div></figure>


<p>挂起恢复条件：</p>

<ul>
<li>1、过了seconds</li>
<li>2、调用进程捕捉到信号并从信号处理程序返回</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">psignal</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="n">msg</span><span class="p">);</span><span class="c1">//；类似perror</span>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="nf">strsignal</span><span class="p">(</span><span class="n">intsigno</span><span class="p">);</span><span class="c1">//类似strerror</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">sig2str</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span><span class="n">str</span><span class="p">);</span><span class="c1">//将信号编号翻译成字符串</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">str2sig</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span><span class="n">signop</span><span class="p">);</span><span class="c1">//将给出的名字翻译为字符串</span>
</span></code></pre></td></tr></table></div></figure>


<h3>例子：</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#include &lt;signal.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;stdio.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;stdlib.h&gt;  </span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span>
</span><span class='line'><span class="nf">sig_print</span><span class="p">(</span><span class="kt">int</span> <span class="n">signo</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="n">printf</span><span class="p">(</span><span class="s">&quot;signal is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">getpid</span><span class="p">());</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="kt">pid_t</span>      <span class="n">pid</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>   <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">sig_print</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span><span class="n">fork</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>       <span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'>       <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>   <span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'>   <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">signal</span> <span class="n">is</span> <span class="mi">3489</span>
</span><span class='line'><span class="n">signal</span> <span class="n">is</span> <span class="mi">3490</span>
</span></code></pre></td></tr></table></div></figure>


<p>SIGINT信号传送给前台进程组里的所有进程</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UNIX系统信号的自我理解（不知对错）]]></title>
    <link href="http://triplecc.github.io/blog/2013-05-12-unixxi-tong-xin-hao-de-zi-wo-li-jie-(bu-zhi-dui-cuo-)/"/>
    <updated>2013-05-12T11:33:23+08:00</updated>
    <id>http://triplecc.github.io/blog/unixxi-tong-xin-hao-de-zi-wo-li-jie-(bu-zhi-dui-cuo-)</id>
    <content type="html"><![CDATA[<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#include &lt;signal.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;stdio.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;sys/types.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;stdlib.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;fcntl.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;string.h&gt;   </span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span>
</span><span class='line'><span class="nf">sig_handler</span><span class="p">(</span> <span class="kt">int</span> <span class="n">signo</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;getsignal</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="nf">main</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">sigset_t</span>    <span class="n">newmask</span><span class="p">,</span><span class="n">zeromask</span><span class="p">;</span>
</span><span class='line'>   <span class="kt">pid_t</span>      <span class="n">pid</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zeromask</span> <span class="p">);</span>
</span><span class='line'>    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span> <span class="p">);</span>
</span><span class='line'>    <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="n">SIGUSR1</span> <span class="p">);</span>
</span><span class='line'>    <span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_BLOCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>      <span class="c1">//1  </span>
</span><span class='line'>    <span class="n">signal</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">sig_handler</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">pid</span> <span class="o">=</span><span class="n">fork</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>      <span class="n">sleep</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;child</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
</span><span class='line'>      <span class="n">sigsuspend</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">zeromask</span> <span class="p">);</span>
</span><span class='line'>      <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;child done</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
</span><span class='line'>      <span class="n">exit</span><span class="p">(</span> <span class="mi">0</span> <span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pid</span> <span class="p">);</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;father</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
</span><span class='line'>    <span class="n">kill</span><span class="p">(</span> <span class="n">pid</span><span class="p">,</span><span class="n">SIGUSR1</span> <span class="p">);</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;father done</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果省略1，则输出中子进程无child done。<br>
添加上则有。<br>
进程间的信号传递要用sigprocmask来阻塞（保留）信号，不然可能在sigsuspend之前传递的信号就已捕获，sigsuspend就无法返回。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#include &lt;signal.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;stdio.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;sys/types.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;stdlib.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;fcntl.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;string.h&gt;  </span>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span>
</span><span class='line'><span class="nf">sig_handler</span><span class="p">(</span> <span class="kt">int</span> <span class="n">signo</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span> <span class="s">&quot;getsignal</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="nf">main</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">sigset_t</span>    <span class="n">newmask</span><span class="p">,</span><span class="n">zeromask</span><span class="p">;</span>
</span><span class='line'>   <span class="kt">pid_t</span>       <span class="n">pid</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zeromask</span> <span class="p">);</span>
</span><span class='line'>    <span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span> <span class="p">);</span>
</span><span class='line'>    <span class="n">sigaddset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newmask</span><span class="p">,</span> <span class="n">SIGUSR1</span> <span class="p">);</span>
</span><span class='line'>    <span class="n">signal</span><span class="p">(</span><span class="n">SIGUSR1</span><span class="p">,</span> <span class="n">sig_handler</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span> <span class="p">(</span><span class="n">pid</span> <span class="o">=</span><span class="n">fork</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>       <span class="n">printf</span><span class="p">(</span><span class="s">&quot;child</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
</span><span class='line'>       <span class="n">sigsuspend</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zeromask</span> <span class="p">);</span>
</span><span class='line'>       <span class="n">printf</span><span class="p">(</span><span class="s">&quot;child done</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
</span><span class='line'>       <span class="n">exit</span><span class="p">(</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">sleep</span><span class="p">(</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;father</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
</span><span class='line'>    <span class="n">kill</span><span class="p">(</span> <span class="n">pid</span><span class="p">,</span><span class="n">SIGUSR1</span> <span class="p">);</span>
</span><span class='line'>    <span class="n">sleep</span><span class="p">(</span> <span class="mi">2</span><span class="p">);</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;father done</span><span class="se">\n</span><span class="s">&quot;</span> <span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">exit</span><span class="p">(</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>虽然用sleep可能不太适合（负载重时可能超过sleep2的时间），但忽略子进程被阻塞等延迟情况。</p>

<p>以上程序的输出为</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">child</span>
</span><span class='line'><span class="n">father</span>
</span><span class='line'><span class="n">get</span> <span class="n">signal</span>
</span><span class='line'><span class="n">child</span> <span class="n">done</span>
</span><span class='line'><span class="n">father</span> <span class="n">done</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>1、程序执行，因主进程中sleep（2），执行进程切换至子进程</li>
<li>2、子进程输出child，并挂起，从而执行进程恢复为主进程</li>
<li>3、主进程如sleep(2)执行结束则输出father，并向子进程发送信号，然后子进程sleep(2)，执行切换至子进程</li>
<li>4、一进入子进程即捕获主进程发送的信号，输出getsignal，并从挂起退出输出 child done，子进程执行完毕</li>
<li>5、执行切换至主进程，sleep(2)执行结束后，输出father done，主进程执行结束。</li>
</ul>


<p>主进程未调用kill发送信号时，执行子进程过程时没有获取到信号。<br>
主进程在调用kill向子进程发送信号后，<code>相对于主进程kill发送后，执行第一条子进程中的某一语句时</code>，子进程<code>即</code>获取到信号。此时如子进程处在挂起状态，则退出挂起。<br>
如果主进程的kill执行前，子进程已经进入pause状态，则在下一次切换到子进程时，子进程捕捉到信号并退出pause状态。<br>
如果主进程的kill执行时，子进程还未进入pause状态，则在下一次切换到子进程时，子进程同样捕捉到信号，但是当执行到pause时，子进程便被挂起，如无信号再次传入，则无法退出挂起状态。</p>

<p>如果把上面程序的第一个sleep(2)去除，则程序可能会发生多种情况：<br>
其中一种：主进程的kill发送信号后，切换至子进程时，子进程可能还没执行到sigsuspend。但此时信号已被捕获，并且sigsuspend没有能捕捉的信号，程序无childdone。</p>

<p>所以进程间的信号传输一般用屏蔽字阻塞，这样只有当执行sigsuspend时，此函数去除相应屏蔽字才能捕捉相应信号！（函数捕捉到信号从挂起返回时，恢复屏蔽字原值）</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UNIX系统进程关系]]></title>
    <link href="http://triplecc.github.io/blog/2013-05-09-unixxi-tong-jin-cheng-guan-xi/"/>
    <updated>2013-05-09T11:25:53+08:00</updated>
    <id>http://triplecc.github.io/blog/unixxi-tong-jin-cheng-guan-xi</id>
    <content type="html"><![CDATA[<h3>pag214</h3>

<h6>登录简易流程：</h6>

<ul>
<li>init进程fork子进程exec执行getty</li>
<li>getty开启终端设备以便输入，显示Login：</li>
<li>用户输入用户名</li>
<li>getty程序exec执行login程序</li>
<li>login由用户名（getpwnam）获取pw结构，显示Password:</li>
<li>用户输入密码</li>
<li>login程序比对pw结构中pw_passwd</li>
</ul>


<h3>pag218</h3>

<p>进程组使一个或多个进程的集合，通常他们与同一作业相关联，可以接收来自统一终端的各种信号。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">pid_t</span> <span class="nf">getpgrp</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="c1">//返回调用进程的进程组ID</span>
</span><span class='line'><span class="kt">pid_t</span> <span class="nf">getpgid</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">);</span><span class="c1">//返回pid进程的进程组ID（getpgid(0) = getpgrp()）</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">setpgid</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">pid_t</span> <span class="n">pgid</span><span class="p">);</span><span class="c1">//加入现有组或创建一个新进程组</span>
</span><span class='line'><span class="n">pid</span><span class="o">=</span><span class="n">pgid</span><span class="p">,</span> <span class="n">pid</span><span class="err">指定进程变成进程组组长</span>
</span><span class='line'><span class="n">pid</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="err">使用调用者进程</span><span class="n">PID</span>
</span><span class='line'><span class="n">pgid</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pid</span><span class="err">指定进程</span><span class="n">ID</span><span class="err">作为进程组</span><span class="n">ID</span>
</span></code></pre></td></tr></table></div></figure>


<h6>进程组：</h6>

<p>每个进程组都可以有一个组长进程。<code>组长进程</code>的标识是，其<code>进程组ID等于其进程ID</code>。<br>
组长进程可以创建一个进程组，创建该组中的进程，然后终止。只要在<code>某个进程组中有一个进程</code>存在，则该<code>进程组就存在</code>，这<code>与其组长进程是否终止无关</code>。<br>
<code>一个进程只能为他自己或他的子进程设置进程组ID</code>。在他的<code>子进程调用了exec函数之一后，他就不能改变该子进程的进程组ID</code>。</p>

<h3>pag219</h3>

<p>会话是一个或多个进程组的集合。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">pid_t</span> <span class="nf">setsid</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="c1">//建立新会话</span>
</span></code></pre></td></tr></table></div></figure>


<h6>调用进程不是一个进程组的组长，此函数创建一个新会话：</h6>

<ul>
<li>该进程变成新会话首进程，并且是此时新会话中的唯一进程</li>
<li>该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID</li>
<li>该进程没有控制终端。如在调用之前有，则联系中断</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">pid_t</span> <span class="nf">getsid</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">);</span> <span class="c1">//返回会话首进程的进程组ID</span>
</span></code></pre></td></tr></table></div></figure>


<p>一个会话可以有一个控制终端。</p>

<p>建立与控制终端连接的会话首进程被称为控制进程。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">pid_t</span> <span class="nf">tcgetpgrp</span><span class="p">(</span><span class="kt">int</span> <span class="n">filedes</span><span class="p">);</span><span class="c1">//返回前台进程组的进程组ID，该前台进程组与在filedes上打开的终端相关联</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">tcsetpgrp</span><span class="p">(</span><span class="kt">int</span> <span class="n">filedes</span><span class="p">,</span> <span class="kt">pid_t</span> <span class="n">pgrpid</span><span class="p">);</span><span class="c1">//将前台进程组ID设置为pgrpid（同一会话中的进程组ID），filedes必须引用会话的控制终端</span>
</span><span class='line'><span class="kt">pid_t</span> <span class="nf">tcgetsid</span><span class="p">(</span><span class="kt">int</span> <span class="n">filedes</span><span class="p">);</span><span class="c1">//获得会话首进程的进程组ID</span>
</span></code></pre></td></tr></table></div></figure>


<h3>pag229</h3>

<h6>孤儿进程组：</h6>

<p>一个进程组不是孤儿进程组的条件是，该<code>组中有一个进程</code>，其<code>父进程在属于同一会话中的另一组</code>中。</p>

<p><code>父进程终止时，子进程被置入后台进程组中，shell所在进程组成为前台进程组</code>（程序9-1）</p>

<h3>习题9-2</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#include &lt;signal.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;stdio.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;sys/types.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;stdlib.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;fcntl.h&gt;  </span>
</span><span class='line'><span class="cp">#include &lt;string.h&gt;  </span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span>
</span><span class='line'><span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">pid_t</span>   <span class="n">pid</span><span class="p">,</span> <span class="n">sid</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;father</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;gid:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">getpgid</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;session fgid:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tcgetpgrp</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">));</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">((</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</span><span class='line'>        <span class="n">sid</span> <span class="o">=</span> <span class="n">setsid</span><span class="p">();</span>
</span><span class='line'>        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">child</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;gid:%d sid:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">getpgid</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">sid</span><span class="p">);</span>
</span><span class='line'>        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;session fgid:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tcgetsid</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">));</span>
</span><span class='line'>        <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">father</span>
</span><span class='line'><span class="nl">gid</span><span class="p">:</span><span class="mi">5761</span>
</span><span class='line'><span class="n">session</span> <span class="nl">fgid</span><span class="p">:</span><span class="mi">5761</span>
</span><span class='line'><span class="n">root</span><span class="p">@</span><span class="nl">ubuntu</span><span class="p">:</span><span class="o">~/</span><span class="n">other</span><span class="err">#</span>
</span><span class='line'><span class="n">child</span>
</span><span class='line'><span class="nl">gid</span><span class="p">:</span><span class="mi">5762</span> <span class="nl">sid</span><span class="p">:</span><span class="mi">5762</span>
</span><span class='line'><span class="n">session</span> <span class="nl">fgid</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span>        <span class="err">（可知新会话无控制终端）</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UNIX系统进程控制]]></title>
    <link href="http://triplecc.github.io/blog/2013-05-06-unixxi-tong-jin-cheng-kong-zhi/"/>
    <updated>2013-05-06T17:12:21+08:00</updated>
    <id>http://triplecc.github.io/blog/unixxi-tong-jin-cheng-kong-zhi</id>
    <content type="html"><![CDATA[<h3>pag171</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">ID</span><span class="o">-----</span><span class="mi">0</span>        <span class="err">通常为调度进程，常常被称为交换进程，不执行任何磁盘上的程序，也被称为系统进程。</span>
</span><span class='line'><span class="n">ID</span><span class="o">-----</span><span class="mi">1</span>        <span class="err">通常为</span><span class="n">init</span><span class="err">进程，通常读与系统有关的初始化文件，并将系统引导到一个状态，</span><span class="n">init</span><span class="err">进程绝不会终止。</span><span class="p">(</span><span class="err">普通用户进程（与交换进程不同，不是内核中的系统进程），但以超级用户特权运行</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">pid_t</span> <span class="nf">getpid</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="c1">//进程ID</span>
</span><span class='line'><span class="kt">pid_t</span> <span class="nf">getppid</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="c1">//父进程ID</span>
</span><span class='line'><span class="kt">uid_t</span> <span class="nf">getuid</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="c1">//进程实际用户ID</span>
</span><span class='line'><span class="kt">uid_t</span> <span class="nf">geteuid</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="c1">//进程有效用户ID</span>
</span><span class='line'><span class="kt">gid_t</span> <span class="nf">getgid</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="c1">//进程实际组ID</span>
</span><span class='line'><span class="kt">gid_t</span> <span class="nf">getegid</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="c1">//进程有效组ID</span>
</span></code></pre></td></tr></table></div></figure>


<h3>pag172</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">pid_t</span> <span class="n">fork</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="err">子进程返回</span><span class="mi">0</span>               <span class="err">（一个进程只有一个父进程，总可以调用</span><span class="n">getppid</span><span class="err">获得父进程</span><span class="n">ID</span><span class="err">）</span>
</span><span class='line'><span class="err">父进程返回新子进程</span><span class="n">ID</span><span class="err">（可能有多个子进程，且没有一个函数使一个进程获得其所有子进程的进程</span><span class="n">ID</span><span class="err">）</span>
</span></code></pre></td></tr></table></div></figure>


<h6>子进程是父进程的副本：</h6>

<ul>
<li>子进程获得父进程的<code>数据空间</code>，<code>堆</code>和<code>栈</code>的副本。父子进程并<code>不共享这些存储空间</code>部分，他们<code>共享正文段</code>（非存储空间）。

<h6>写时拷贝：</h6></li>
<li>并不执行父进程数据段，栈和堆的完全拷贝，这些区域由父子进程共享，内核将他们的访问权限改变为只读。当父子进程中任何一个<code>试图改变这些区域</code>时，<code>内核只为修改区域的那块内存制作一个副本</code>。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">strlen</span><span class="err">：包含终止</span><span class="n">null</span><span class="err">字节</span>
</span><span class='line'><span class="k">sizeof</span><span class="err">：不包含</span><span class="n">null</span><span class="err">字节</span>
</span></code></pre></td></tr></table></div></figure>


<h3>pag174</h3>

<p>在重定向父进程的标准输出时，子进程的标准输出也被重定向。（fork：父进程所有打开文件描述符都被复制到子进程中）</p>

<h6>子进程继承的属性</h6>

<ul>
<li>实际用户ID、实际组ID、有效用户ID、有效组ID（进程和用户）（关系到权限）</li>
<li>附加组ID</li>
<li>进程组ID（进程和进程）（不关系到权限）</li>
<li>会话ID</li>
<li>控制终端</li>
<li>设置用户ID标识和设置组ID标识</li>
<li>当前工作目录</li>
<li>根目录</li>
<li>文件模式创建屏蔽字（umask）</li>
<li>信号屏蔽和安排</li>
<li>针对任一文件描述符的在执行时关闭（close on exec）标识</li>
<li>环境</li>
<li>连接的共享存储段</li>
<li>存储映射</li>
<li>资源限制</li>
<li>文件描述符</li>
</ul>


<h6>父子进程间区别</h6>

<ul>
<li>fork返回值</li>
<li>进程ID</li>
<li>父进程ID</li>
<li>子进程tms_*部分设置为0</li>
<li>父进程设置的文件锁不会被子进程继承</li>
<li>子进程的未处理闹钟被清除</li>
<li>子进程的未处理信号集设置为空集</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="nl">vfork</span> <span class="p">:</span><span class="err">不将父进程地址空间完全复制到子进程中，在子进程调用</span><span class="n">exec</span><span class="err">或</span><span class="n">exit</span><span class="err">之前，他在父进程的空间中运行。</span>
</span><span class='line'><span class="n">vfork</span><span class="err">保证子进程先运行，在子进程调用</span><span class="n">exec</span><span class="err">或</span><span class="n">exit</span><span class="err">之前，内核会使父进程处于休眠状态。</span>
</span></code></pre></td></tr></table></div></figure>


<h3>pag178</h3>

<p>对于父进程已经终止的所有进程，他们的<code>父进程都改变为init</code>进程。<br>
一个已经终止，但是其<code>父进程尚未对其进行善后处理</code>（获取终止进程的有关信息，释放他仍占用的资源）的进程称为<code>僵尸进程</code>(调用wait、waitpid获取状态)<br>
<code>init</code>只要有一个子进程终止就会调用一个wait函数取得终止状态，所以<code>不会产生僵尸进程</code>。</p>

<h3>pag182</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">pid_t</span> <span class="nf">wait</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">statloc</span><span class="p">);</span>
</span><span class='line'><span class="kt">pid_t</span> <span class="nf">waitpid</span><span class="p">(</span><span class="kt">pid_t</span> <span class="n">pid</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">statloc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">options</span><span class="p">);</span><span class="c1">//WNOHANG可使调用者不阻塞</span>
</span><span class='line'><span class="nl">pid</span><span class="p">:</span>
</span><span class='line'><span class="o">-----</span><span class="n">pid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">-------</span><span class="err">等待任意子进程</span>
</span><span class='line'><span class="o">-----</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span>   <span class="o">-------</span><span class="err">等待其进程</span><span class="n">ID</span><span class="err">与</span><span class="n">pid</span><span class="err">相等的子进程</span>
</span><span class='line'><span class="o">-----</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="o">--------</span><span class="err">等待其组</span><span class="n">ID</span><span class="err">与等于调用进程组</span><span class="n">ID</span><span class="err">的任一子进程</span>
</span><span class='line'><span class="o">-----</span><span class="n">pid</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="o">--------</span><span class="err">等待其组</span><span class="n">ID</span><span class="err">等于</span><span class="n">pid</span><span class="err">绝对值的任一子进程</span>
</span><span class='line'><span class="kt">int</span> <span class="n">waitid</span><span class="p">(</span><span class="kt">idtype_t</span> <span class="n">idtype</span><span class="p">,</span> <span class="kt">id_t</span> <span class="kt">id</span><span class="p">,</span> <span class="kt">siginfo_t</span> <span class="o">*</span><span class="n">infop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">options</span><span class="p">);</span>
</span><span class='line'><span class="n">idtype</span><span class="err">：</span>
</span><span class='line'><span class="nl">P_PID</span><span class="p">:</span><span class="err">等待特定进程</span>
</span><span class='line'><span class="nl">P_PGID</span><span class="p">:</span><span class="err">等待特定进程组中任一子进程</span>
</span><span class='line'><span class="nl">P_ALL</span><span class="p">:</span><span class="err">等待任一子进程</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果一个进程fork一个子进程，但不要他等待子进程终止，也不希望子进程处于僵死状态知道父进程终止，可以调用fork两次，先让父进程wait第一个子进程终止，使第二个子进程被init领养。（init子进程不会成为僵死进程）</p>

<h3>pag188</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">execl</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arg0</span><span class="p">,</span> <span class="p">...);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">execv</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">argv</span><span class="p">[]);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">execle</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arg0</span><span class="p">,</span> <span class="p">...);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">execve</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">argv</span><span class="p">[],</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">envp</span><span class="p">[]);</span><span class="c1">//内核系统调用</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">execlp</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">arg0</span><span class="p">,</span> <span class="p">...);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">execvp</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">argv</span><span class="p">[]);</span>
</span></code></pre></td></tr></table></div></figure>


<h6>exec函数：</h6>

<ul>
<li>进程调用此函数时，该进程执行的程序完全替换为新程序，而新程序则从其main函数开始执行。</li>
<li>exec并不创建新进程，所以前后进程ID未改变。</li>
<li>exec函数用一个全新的程序替换了当前进程的正文、数据、堆、栈段。

<h6>6个exec函数中字符寓意：</h6></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="o">----</span><span class="n">p</span><span class="err">：该函数取</span><span class="n">filename</span><span class="err">作为参数，并且用</span><span class="n">PATH</span><span class="err">环境变量寻找可执行文件。</span>
</span><span class='line'><span class="o">----</span><span class="n">l</span><span class="err">：该函数取一个参数表，他与字母</span><span class="n">v</span><span class="err">互斥</span><span class="c1">//参数表以NULL指针结尾</span>
</span><span class='line'><span class="o">----</span><span class="n">v</span><span class="err">：该函数取一个</span><span class="n">argv</span><span class="p">[]</span><span class="err">矢量。</span>
</span><span class='line'><span class="o">----</span><span class="n">e</span><span class="err">：该函数取</span><span class="n">envp</span><span class="p">[]</span><span class="err">数组，而不使用当前环境</span>
</span></code></pre></td></tr></table></div></figure>


<h6>执行exec后保持的属性：</h6>

<ul>
<li>进程ID和父进程ID</li>
<li>实际用户ID和实际组ID</li>
<li>附加组ID</li>
<li>进程组ID</li>
<li>会话ID</li>
<li>控制终端</li>
<li>闹钟尚余留时间</li>
<li>当前工作目录</li>
<li>根文件</li>
<li>文件模式创建屏蔽子</li>
<li>文件锁</li>
<li>进程信号屏蔽字</li>
<li>未处理信号</li>
<li>资源限制</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">tms_</span><span class="o">*</span>
</span><span class='line'><span class="nl">FD_CLOEXEC</span><span class="p">:</span><span class="err">进程中每个打开的描述符都有一个执行时关闭标志。若此标志设置则在执行</span><span class="n">exec</span><span class="err">时关闭该描述符，否则该描述符打开。</span>
</span></code></pre></td></tr></table></div></figure>


<h3>pag193</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">setuid</span><span class="p">(</span><span class="kt">uid_t</span> <span class="n">uid</span><span class="p">);</span><span class="c1">//设置实际用户ID和有效用户ID</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">setgid</span><span class="p">(</span><span class="kt">gid_t</span> <span class="n">gid</span><span class="p">);</span><span class="c1">//设置实际组ID和有效组ID</span>
</span></code></pre></td></tr></table></div></figure>


<p>关于内核维护的三个用户ID，注意：
- 只有<code>超级用户进程</code>可以更改<code>实际用户ID</code>。（setuid设置全部三个用户ID）
- 仅当对程序文件设置了设置用户ID位时，exec函数才会设置有效用户ID。任何时候都可以调用setuid，将有效用户ID设置为实际用户ID或保存的设置用户ID。
- 保存的设置用户ID是由复制有效用户ID而得来的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">setreuid</span><span class="p">(</span><span class="kt">uid_t</span> <span class="n">ruid</span><span class="p">,</span> <span class="kt">uid_t</span> <span class="n">euid</span><span class="p">);</span><span class="c1">//交换实际用户ID和有效用户ID</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">setregid</span><span class="p">(</span><span class="kt">gid_t</span> <span class="n">rgid</span><span class="p">,</span> <span class="kt">gid_t</span> <span class="n">egid</span><span class="p">);</span><span class="c1">//交换实际组ID和有效组ID</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">seteuid</span><span class="p">(</span><span class="kt">uid_t</span> <span class="n">uid</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">setegid</span><span class="p">(</span><span class="kt">gid_t</span> <span class="n">gid</span><span class="p">);</span> <span class="c1">//pag196设置不同用户ID的各函数</span>
</span></code></pre></td></tr></table></div></figure>


<h3>pag200</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">system</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cmdstring</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>在其实现中调用了fork、exec和waitpid。</li>
<li>如果一个进程正以<code>特殊权限</code>（设置用户ID或设置组ID）运行，他又想<code>生成另一个进程执行另一个程序</code>，则他应当直接使用fork和exec，而且在fork之后，exec之前要改回到普通权限（exec会复制有效ID-》保存设置ID）。设置用户ID或设置组ID程序决不应调用system函数。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="nf">getlogin</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="c1">//获取登录名</span>
</span><span class='line'><span class="kt">clock_t</span> <span class="nf">time</span><span class="p">(</span><span class="k">struct</span> <span class="n">tms</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>不提供返回保存的设置用户ID（只是供setuid时做为一个参考，看要设置的有效id和保存的设置用户id相不相等）的函数，我们必须在进程开始时保存有效用户ID。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UNIX进程环境]]></title>
    <link href="http://triplecc.github.io/blog/2013-05-05-unixjin-cheng-huan-jing/"/>
    <updated>2013-05-05T11:04:16+08:00</updated>
    <id>http://triplecc.github.io/blog/unixjin-cheng-huan-jing</id>
    <content type="html"><![CDATA[<h3>pag147</h3>

<h4>main执行前：</h4>

<ul>
<li>调用一个特殊的启动例程</li>
<li>可执行程序文件将此启动例程指定为程序的起始地址</li>
<li>启动例程从内核取得命令行参数和环境变量值</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">exit</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">_Exit</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">_exit</span><span class="p">(</span><span class="kt">int</span> <span class="n">status</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p><em>exit和</em>Exit立刻进入内核，exit则先执行一些清理处理，然后进入内核。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">echo</span> <span class="err">$</span><span class="o">?</span> <span class="err">打印终止状态</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">atexit</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">void</span><span class="p">));</span><span class="c1">//终止处理程序，由exit调用，顺序与登记时相反</span>
</span></code></pre></td></tr></table></div></figure>


<p>内核使程序<strong>执行的唯一方法</strong>是调用一个<strong>exec</strong>函数。进程<strong>自愿终止</strong>的唯一方法是显式或隐式地（通过调用exit）调用<strong><em>exit或</em>Exit</strong></p>

<p>ISOC和POSIX.1都要求argv[argc]是一个空指针，则参数循环处理可写为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">for</span><span class="p">(</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="nf">calloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">nobj</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="nf">realloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">newsize</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>sbrk扩充（或缩小）进程的堆。<br></p>

<p>大多数malloc和free的实现都不减小进程的存储空间。释放的空间可供以后再分配，但通常将他们保持在malloc池中而不返回给内核。<br></p>

<p>alloca函数：在当前函数的栈帧上分配存储空间，而不是在堆中</p>

<ul>
<li>优点：自动释放</li>
<li>缺点：增加栈帧长度，某些函数可能不支持</li>
</ul>


<h4>环境变量：</h4>

<h6>字符串格式：</h6>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">name</span><span class="o">=</span><span class="n">value</span>
</span><span class='line'>
</span><span class='line'><span class="n">export</span> <span class="n">name</span><span class="o">=</span><span class="n">value</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们能影响的只是<strong>当前进程及调用进程</strong>的任何<strong>子进程的环境</strong>，但<strong>不能影响父进程的环境</strong>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="nf">getenv</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span><span class="c1">//返回指向name=value字符串中的value</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">putenv</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span><span class="c1">//采取形式为name=value的字符串，将其放到环境表中，已存在则先删除</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">setenv</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rewrite</span><span class="p">);</span><span class="c1">//已存在，rewrite非0删除，0不删除</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">unsetenv</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span><span class="c1">//删除name定义</span>
</span></code></pre></td></tr></table></div></figure>


<p>putenv传递的是字符串地址，将存放在栈中的字符串作为参数传给该函数就会发生错误。</p>

<h3>pag161</h3>

<p>在栈上跳过若干栈帧</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">setjmp</span><span class="p">(</span><span class="kt">jmp_buf</span> <span class="n">env</span><span class="p">);</span><span class="c1">//env变量定义为全局变量</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">longjmp</span><span class="p">(</span><span class="kt">jmp_buf</span> <span class="n">env</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">);</span><span class="c1">//val 从setjmp返回的值</span>
</span></code></pre></td></tr></table></div></figure>


<p>一个自动变量<strong>不想使其值回滚</strong>，则定义其为具有volatile属性，声明为全局变量或静态变量的值在执行longjmp时保持不变。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">getrlimit</span><span class="p">(</span><span class="kt">int</span> <span class="n">resource</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rlimit</span> <span class="o">*</span><span class="n">rlptr</span><span class="p">);</span><span class="c1">//查询进程限制</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">setrlimit</span><span class="p">(</span><span class="kt">int</span> <span class="n">resource</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">rlimit</span> <span class="o">*</span><span class="n">rlptr</span><span class="p">);</span><span class="c1">//更改进程限制</span>
</span></code></pre></td></tr></table></div></figure>


<p>进程的<strong>资源限制</strong>通常是在系统初始化时由<strong>进程0建立</strong>的，然后由<strong>每个后续进程继承</strong>。<br></p>

<p>资源限制<strong>影响</strong>到<strong>调用进程</strong>并由其<strong>子进程继承</strong>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UNIX系统标准IO]]></title>
    <link href="http://triplecc.github.io/blog/2013-05-01-unixxi-tong-biao-zhun-io/"/>
    <updated>2013-05-01T10:42:32+08:00</updated>
    <id>http://triplecc.github.io/blog/unixxi-tong-biao-zhun-io</id>
    <content type="html"><![CDATA[<h3>pag111</h3>

<p>流定向决定了所读、写的字符是单字节还是多字节的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">fwide</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span><span class="c1">//设置流定向</span>
</span></code></pre></td></tr></table></div></figure>


<h6>文件描述符</h6>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">STDIN_FILENO</span><span class="err">、</span><span class="n">STDOUT_FILENO</span><span class="err">、</span><span class="n">STDERR_FILENO</span>
</span></code></pre></td></tr></table></div></figure>


<h6>文件指针</h6>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">stdin</span><span class="err">、</span><span class="n">stdout</span><span class="err">、</span><span class="n">stderr</span>
</span></code></pre></td></tr></table></div></figure>


<h6>默认缓冲机制</h6>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="err">标准出错</span><span class="o">---------------------</span><span class="err">不带缓冲</span>
</span><span class='line'><span class="err">终端设备流</span><span class="o">------------------</span><span class="err">行缓冲</span>
</span><span class='line'><span class="err">其他流</span><span class="o">-----------------------</span><span class="err">全缓冲</span>
</span></code></pre></td></tr></table></div></figure>


<h6>行缓冲限制</h6>

<ul>
<li>1、只要填满了缓冲区，即使没有写一换行符，也进行IO操作。</li>
<li>2、任何时候只要通过标准IO库要求从（a）一个不带缓冲的流，或者（b）一个行缓冲的流（要求从内核得到数据）的到输入数据，那么会造成冲洗所有行缓冲输出流（fgets，gets等循环调用会冲洗输出流）</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">void</span> <span class="nf">setbuf</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">fp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">buf</span><span class="p">);</span><span class="c1">//更改缓冲类型</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">setvbuf</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">fp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span><span class="c1">//_IOFBF/_IOLBF/_IONBF</span>
</span><span class='line'><span class="err">如果要使用改变缓冲类型函数，则要在打开流后并且在对该流执行任何操作之前</span>
</span><span class='line'><span class="kt">int</span> <span class="n">fflush</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span><span class="c1">//强制冲洗一个流（fd=NULL，冲洗所有输出流）</span>
</span><span class='line'>
</span><span class='line'><span class="kt">FILE</span> <span class="o">*</span><span class="nf">fopen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">pathname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">type</span><span class="p">);</span><span class="c1">//打开标准IO流，指定文件</span>
</span><span class='line'><span class="kt">FILE</span> <span class="o">*</span><span class="nf">freopen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">pathname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">type</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">fd</span><span class="p">);</span><span class="c1">//在指定流上打开指定文件，此函数一般用于将一个指定的文件打开为一个预定义的流：标准输入、标准输出、标准出错</span>
</span><span class='line'><span class="kt">FILE</span> <span class="o">*</span><span class="nf">fdopen</span><span class="p">(</span><span class="kt">int</span> <span class="n">filedes</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">type</span><span class="p">);</span><span class="c1">//获取现有描述符与一个标准IO流结合（与fileno相对）（open,dup,dup2,fcntl,pipe,socket,socketpair,ept获得描述符），不能截断他为写而打开的任一文件</span>
</span></code></pre></td></tr></table></div></figure>


<h6>当以读和写类型打开一文件时（+）具有以下限制：（此限制不是很理解）</h6>

<ul>
<li>1、如果中间没有fflush、fseek、fsetpos、rewind，则在输出的后面不能直接跟随输入</li>
<li>2、如果中间没有fseek、fsetpos、rewind，或者一个输出操作没有到达文件尾端，则在输入操作之后不能直接跟随输出</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">fclose</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span><span class="c1">//关闭一个打开的流</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">getc</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span><span class="c1">//getchar 等价于getc(stdin)</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">fgetc</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">getchar</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">ferror</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span> <span class="c1">//出错检查</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">feof</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span> <span class="c1">//文件结束检查</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">ungetc</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span><span class="c1">//将字符压送回流中</span>
</span><span class='line'><span class="err">压送回流中的字符以后可以从流中读出，但读出字符的顺序与压送回的顺序相反。不能回送</span><span class="n">EOF</span><span class="err">。一次成功的</span><span class="n">ungetc</span><span class="err">调用会清除该流的文件结束标志。</span><span class="p">(</span><span class="err">有时需要先看下一个字符，以决定如何处理当前字符时有用</span><span class="p">)</span>
</span><span class='line'><span class="kt">int</span> <span class="n">putc</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">fputc</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">putchar</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">);</span>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="nf">fgets</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">fp</span><span class="p">);</span><span class="c1">//读取n-1个字符，自行添加NUL</span>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="nf">gets</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">fputs</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">str</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">fp</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">puts</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">gets</span><span class="o">----------</span><span class="err">不保留换行符</span>                            <span class="n">puts</span><span class="o">----------------</span><span class="err">添加换行符</span>
</span><span class='line'><span class="n">fgets</span><span class="o">----------</span><span class="err">保留换行符</span>                             <span class="n">fputs</span><span class="o">---------------</span><span class="err">不添加换行符</span>
</span><span class='line'>
</span><span class='line'><span class="n">getc</span><span class="o">---------</span><span class="err">可实现为宏</span>
</span><span class='line'><span class="n">so</span><span class="err">：</span><span class="n">getc</span><span class="err">的参数不应当时具有副作用的表达式。</span>
</span><span class='line'><span class="n">fgetc</span><span class="o">--------</span><span class="err">一定时个函数</span>
</span><span class='line'><span class="n">so</span><span class="err">：可得到其地址，</span><span class="n">fgetc</span><span class="err">的地址可做为参数。</span>
</span></code></pre></td></tr></table></div></figure>


<p>EOF类型为int，所以单字符获取函数的返回值为int型，定义变量时要注意定义为int型，否则可能无法检测出EOF错误。</p>

<h6>二进制IO（前提）</h6>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">size_t</span> <span class="nf">fread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nobj</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">fp</span><span class="p">);</span>
</span><span class='line'><span class="kt">size_t</span> <span class="nf">fwrite</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nobj</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">fp</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h6>定位流</h6>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">long</span> <span class="nf">ftell</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">fseek</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">whence</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">rewind</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">fgetpos</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">fp</span><span class="p">,</span> <span class="kt">fpos_t</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">pos</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">fsetpos</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">fpos_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>pag121</h3>

<h6>格式化IO</h6>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">fprintf</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">fp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">sprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="p">...);</span><span class="c1">//在尾端自动添加NUL，该字节不包括在返回值中</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">snprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
</span></code></pre></td></tr></table></div></figure>


<p>转换说明：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="o">%</span><span class="p">[</span><span class="n">flags</span><span class="p">][</span><span class="n">fldwidth</span><span class="p">][</span><span class="n">precision</span><span class="p">][</span><span class="n">lenmodifier</span><span class="p">]</span><span class="n">convtype</span>
</span><span class='line'><span class="n">fldwidth</span><span class="err">：转换的最小字段宽度。如少则用空格填充。</span>
</span><span class='line'><span class="nl">precision</span><span class="p">:</span><span class="err">说明整形转换后最少输出数字位数、浮点数转换后小数点后的最少位数、字符串转换后的最大字符数。精度是一个句点（</span><span class="p">.</span><span class="err">），后接一个可选非负十进制整数或一个星号。</span><span class="p">(</span><span class="err">字符是限制，其他类型是规定最小标准</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">vprintf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">arg</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">vfprintf</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">fp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">arg</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">vsprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">arg</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">vsnprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">arg</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">scanf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">fscanf</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">fp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">sscanf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
</span></code></pre></td></tr></table></div></figure>


<p>转换说明：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="o">%</span><span class="p">[</span><span class="o">*</span><span class="p">][</span><span class="n">fldwidth</span><span class="p">][</span><span class="n">lenmodifier</span><span class="p">]</span><span class="n">convtype</span>
</span><span class='line'><span class="n">fldwidth</span><span class="err">：最大宽度（最大字符数）</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">scanf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">arg</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">vfscanf</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">fp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">arg</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">vsscanf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">format</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">arg</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h3>pag125</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">fileno</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">);</span> <span class="c1">//获取与流相关连的文件描述符</span>
</span></code></pre></td></tr></table></div></figure>


<h6>临时文件</h6>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="nf">tmpnam</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">);</span><span class="c1">//产生一个与现有文件名不同的一个有效路径名字符串</span>
</span><span class='line'><span class="kt">FILE</span> <span class="o">*</span><span class="nf">tmpfile</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="c1">//创建临时二进制文件，在关闭文件或程序结束时自动删除该文件</span>
</span><span class='line'><span class="err">常用标准技术：先调用</span><span class="n">tmpnam</span><span class="err">产生一个唯一的路径名，然后用该路径名创建一个文件，并立即</span><span class="n">unlink</span><span class="err">它（链接计数为</span><span class="mi">0</span><span class="err">）（关闭时引用计数为</span><span class="mi">0</span><span class="err">，此时才删除其内容）</span>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="n">tempnam</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">directory</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">prefix</span><span class="p">);</span><span class="c1">//为产生的路径名指定目录和前缀，prefix最多包含5个字符的字符串</span>
</span></code></pre></td></tr></table></div></figure>


<p>按序判断：</p>

<ul>
<li>1、如果定义了环境变量TMPDIR,则用其作为目录</li>
<li>2、如果参数directory非NULL，则用其作为目录</li>
<li>3、将中的字符串P_tmpdir用作目录</li>
<li>4、将本地目录（通常是/tmp）用作目录</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">mkstemp</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">template</span><span class="p">);</span><span class="c1">//创建临时文件，返回打开的文件描述符（不会自动删除，要调用unlink）</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UNIX系统文件和目录]]></title>
    <link href="http://triplecc.github.io/blog/2013-04-28-unixxi-tong-wen-jian-he-mu-lu/"/>
    <updated>2013-04-28T10:20:09+08:00</updated>
    <id>http://triplecc.github.io/blog/unixxi-tong-wen-jian-he-mu-lu</id>
    <content type="html"><![CDATA[<h3>pag72</h3>

<h5>目录文件：包含其他文件的名字以及指向与这些文件有关信息的指针。（知道目录也时文件）</h5>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">stat</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">pathname</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">buf</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">fstat</span> <span class="p">(</span><span class="kt">int</span> <span class="n">filedes</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="n">buf</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">lstat</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">pathname</span><span class="p">,</span> <span class="k">struct</span> <span class="n">stat</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">buf</span><span class="p">);</span> <span class="err">（</span><span class="n">link</span> <span class="n">stat</span><span class="err">）</span>
</span></code></pre></td></tr></table></div></figure>


<p>lstat与stat类似，但是当命名的文件是一个符号链接时，lstat返回该符号链接的有关信息，而不是该符号链接引用文件的信息(stat)。</p>

<h5>文件类型：<br></h5>

<ul>
<li>1.普通文件<br>                                                                                                                                S_ISREG</li>
<li>2、目录文件。包含其他文件的名字以及指向这些文件有关信息的指针。<br>                                  S_ISDIR</li>
<li>3、块特殊文件。提供对设备带缓冲的访问。 <br>                                                                                 S_ISBLK</li>
<li>4、字符特殊文件。提供设备不带缓冲访问(系统中设备要么是 字符特殊文件，要么是块特殊文件)<br>  S_ISCHR</li>
<li>5、 FIFO。命名管 道   <br>                                                                                                                     S_ISFIFO</li>
<li>6、套接字  <br>                                                                                                                                   S_ISSOCK</li>
<li>7、符号链接。这种文件指向另一个文件   <br>                                                                                       S_ISLNK<br><br/>
所有类型文件都有访问权限</li>
</ul>


<h3>pag75</h3>

<ul>
<li><strong>主要先辨别ID针对的对象：进程还是文件（这个对理解各ID的差异与概念很重要）</strong><br></li>
<li><p><strong>两个所有者ID是文件的性质，两个有效ID和附加组ID是进程的性质。</strong></p></li>
<li><p>进程相关联ID：（执行文件时才说明这些ID）</p></li>
<li>实际用户ID、实际组ID：进程执行者，当前所在的用户。</li>
</ul>


<h6>有效用户ID、有效组ID、附加组ID</h6>

<p>决定访问权限。大多数情况下为实际用户ID、实际组ID（除了设置了设置用户ID位及设置组ID位这种情况）。当<code>设置-用户-ID（SUID）位</code>设置，则有效用户ID等于文件的所有者的uid(struct stat中的st_uid,st_gid)，而不是实际用户ID；<br>
同样，如果设置了<code>设置-用户组-ID（SGID）位</code>，则有效用户组ID等于文件所有者的gid，而不是实际用户组ID。（实际用户是root时可能有点不同）设置用户ID位及设置组ID位都包含在st_mode值中，可用常量S_ISUID和S_ISGID测试。</p>

<h6>保存的设置用户ID、保存的设置组ID</h6>

<p>有效用户ID、有效组ID的副本。<br>
例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">ls</span>
</span><span class='line'><span class="o">-</span><span class="n">rw</span><span class="o">-</span><span class="n">r</span><span class="o">--</span><span class="n">r</span><span class="o">--</span> <span class="mi">1</span> <span class="n">root</span>  <span class="n">ad</span> <span class="p">..................(</span><span class="err">这个</span><span class="n">root</span><span class="err">表示的是文件所有者，即最初创建此文件的进程的有效用户</span><span class="n">ID</span><span class="err">；</span><span class="n">ad</span><span class="err">表示当所属用户组</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">whoami</span>
</span><span class='line'><span class="n">ad</span>                                         <span class="p">(</span><span class="err">这个</span><span class="n">ad</span><span class="err">表示的是实际用户</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>pag76</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">st_mode</span><span class="err">屏蔽</span><span class="o">---------------------------------</span><span class="err">意义</span>
</span><span class='line'><span class="n">S_IRUSR</span>     <span class="o">---------------------------------</span><span class="err">用户</span><span class="o">-</span><span class="err">读</span>
</span><span class='line'><span class="n">S_IWUSR</span>    <span class="o">---------------------------------</span><span class="err">用户</span><span class="o">-</span><span class="err">写</span>
</span><span class='line'><span class="n">S_IXUSR</span>     <span class="o">---------------------------------</span><span class="err">用户</span><span class="o">-</span><span class="err">执行</span>
</span><span class='line'><span class="n">S_IRGRP</span>    <span class="o">---------------------------------</span><span class="err">组</span><span class="o">-</span><span class="err">读</span>
</span><span class='line'><span class="n">S_IWGRP</span>    <span class="o">---------------------------------</span><span class="err">组</span><span class="o">-</span><span class="err">写</span>
</span><span class='line'><span class="n">S_IXGRP</span>     <span class="o">---------------------------------</span><span class="err">组</span><span class="o">-</span><span class="err">执行</span>
</span><span class='line'><span class="n">S_IROTH</span>     <span class="o">---------------------------------</span><span class="err">其他</span><span class="o">-</span><span class="err">读</span>
</span><span class='line'><span class="n">S_IWOTH</span>    <span class="o">---------------------------------</span><span class="err">其他</span><span class="o">-</span><span class="err">写</span>
</span><span class='line'><span class="n">S_IXOTH</span>     <span class="o">---------------------------------</span><span class="err">其他</span><span class="o">-</span><span class="err">执行</span>
</span></code></pre></td></tr></table></div></figure>


<h6>目录读权限与执行权限的差异</h6>

<ul>
<li>读权限：允许我们读目录获得在该目录中所有文件名的列表。</li>
<li>执行权限：允许我们通过该目录，即搜索该目录，寻找一个特定的名字。</li>
</ul>


<p>为了<strong>删除</strong>一个现有文件，必须对<strong>包含该文件的目录</strong>具有写权限和<strong>执行权限</strong>，<strong>对该文件本身则不需要有读写权限</strong>。
在目录中创建文件也一样。对于目录通常至少要设置一个执行权限位，以允许访问该目录中的文件名。</p>

<h3>pag77</h3>

<p>新文件的用户ID（所有者ID）设置为进程的有效用户ID。<br>
新文件组ID：<br></p>

<ul>
<li>1、进程的有效组ID。</li>
<li>2、所在目录的组ID。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">access</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span><span class="c1">//按实际用户ID和实际组ID进行访问权限测试</span>
</span><span class='line'><span class="n">mode</span><span class="err">：</span>
</span><span class='line'><span class="n">R_OK</span>          <span class="err">读权限</span>
</span><span class='line'><span class="n">W_OK</span>          <span class="err">写权限</span>
</span><span class='line'><span class="n">X_OK</span>          <span class="err">执行权限</span>
</span><span class='line'><span class="n">F_OK</span>          <span class="err">文件是否存在</span>
</span></code></pre></td></tr></table></div></figure>


<h3>pag79</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">mode_t</span> <span class="n">umask</span><span class="p">(</span> <span class="kt">mode_t</span> <span class="n">cmask</span> <span class="p">)</span>
</span><span class='line'><span class="c1">// umask函数为进程设置文件模式创建屏蔽字并返回以前的值。当调用umask后，在此函数以下创建的文件都受umask屏蔽字的影响(设置1时关闭)，在函数以上的则保持原先的访问权限。pag80中例子必须不在root用户下执行才能得到与书中一致的结果。更改进程的文件模式创建屏蔽字并不影响其父进程（常常是shell）的屏蔽字。</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="n">chmod</span><span class="p">(</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">mode_t</span> <span class="n">mode</span> <span class="p">)</span>
</span><span class='line'><span class="kt">int</span> <span class="n">fchmod</span><span class="p">(</span> <span class="kt">int</span> <span class="n">filedes</span><span class="p">,</span> <span class="kt">mode_t</span> <span class="n">mode</span> <span class="p">)</span>
</span><span class='line'><span class="c1">// chmod函数在指定的文件上进行操作，fchmod对已打开的文件进行操作。</span>
</span><span class='line'><span class="err">为改变一个文件的权限位，进程的有效用户</span><span class="n">ID</span><span class="err">必须等于文件的所有者</span><span class="n">ID</span><span class="err">，或者该进程必须具有超级用户权限。</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">chown</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">uid_t</span> <span class="n">owner</span><span class="p">,</span> <span class="kt">gid_t</span> <span class="n">group</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">fchown</span> <span class="p">(</span><span class="kt">int</span> <span class="n">filedes</span><span class="p">,</span> <span class="kt">uid_t</span> <span class="n">owner</span><span class="p">,</span> <span class="kt">gid_t</span> <span class="n">group</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">lchown</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">uid_t</span> <span class="n">owner</span><span class="p">,</span> <span class="kt">gid_t</span> <span class="n">group</span><span class="p">);</span>
</span><span class='line'><span class="c1">// 更改文件的用户ID（文件所有者ID）和组ID。lchown更改符号链接本身的所有者，而不是该符号链接所指向的文件。如两个参数owner或group中的任意一个是-1，则对应的ID不变。</span>
</span><span class='line'><span class="err">如果这些函数由非超级用户进程调用，则在成功返回时，该文件的设置用户</span><span class="n">ID</span><span class="err">位和设置组</span><span class="n">ID</span><span class="err">位都会被清除。</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">truncate</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">length</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">ftruncate</span> <span class="p">(</span><span class="kt">int</span> <span class="n">filedes</span><span class="p">,</span> <span class="kt">off_t</span> <span class="n">length</span><span class="p">);</span>
</span><span class='line'><span class="c1">// 把文件长度截断为length字节。</span>
</span></code></pre></td></tr></table></div></figure>


<h3>pag87</h3>

<p>一个磁盘可以分成多个分区，每个分区可以包含一个文件系统。</p>

<ul>
<li>i节点是固定长度的记录项，他包含有关文件的大部分信息。

<h6>关于i节点的理解</h6></li>
<li>i节点包含了大多数与文件有关的信息：文件类型、文件访问权限位、文件长度、指向该文件所占用的数据块指针等。
<strong>要注意引用计数（进程）与链接计数（目录项）</strong></li>
</ul>


<h6>硬链接与符号链接</h6>

<ul>
<li><code>硬链接</code>：文件中为所指向文件的内容（直接指向文件的i节点）（多个文件名可指向同一索引节点）

<ul>
<li>每个i节点都有一个链接计数，其值是指向该i节点的目录项数，只有当链接计数减少至0时，才可删除文件。</li>
</ul>
</li>
<li><code>符号链接</code>：文件中包含所指向文件的名字（指向一个文件的间接指针）

<ul>
<li>ln -s () ()创建符号链接，ls -l 可看出符号链接所指向的文件</li>
<li>ln -P () ()创建硬链接，打开创建的硬链接，内容即为硬链接指向文件<br></li>
</ul>
</li>
</ul>


<p>硬链接限制：<br></p>

<ul>
<li>1.通常要求链接和文件位于同一文件系统中。</li>
<li>2.只有超级用户才能创建指向目录的硬链接。</li>
</ul>


<p>任何一个叶目录（不包含任何其他目录的目录）的链接计数<strong>总是2</strong>，数值2来自于命名该目录的目录项..和该目录中的.项。父目录中的每一个子目录都会使该父目录的链接计数增1.</p>

<h3>pag89</h3>

<p>任何一个文件可以有多个目录项指向其i节点。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">link</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">existingpath</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">newpath</span><span class="p">);</span><span class="c1">//创建一个指向现有文件的链接（硬链接)</span>
</span><span class='line'><span class="err">只创建</span><span class="n">newpath</span><span class="err">中最后一个分量，路径中的其他部分应当已经存在。</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">unlink</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">);</span><span class="c1">//删除现有目录项</span>
</span><span class='line'><span class="err">删除目录项，并将由</span><span class="n">pathname</span><span class="err">所引用文件的链接计数减</span><span class="mf">1.</span><span class="err">（当文件还是打开的时候，不会将其内容删除，只有当进程关闭该文件或终止时该文件内容才会被删除）</span><span class="n">open</span><span class="err">或</span><span class="n">create</span><span class="err">创建文件时，文件有</span><span class="mi">1</span><span class="err">个引用计数（进程指向</span><span class="n">i</span><span class="err">节点的文件描述符），一个链接计数（所创建文件名所在的目录项），当两者都为</span><span class="mi">0</span><span class="err">时才释放空间。</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">remove</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">);</span><span class="c1">//解除对一个文件或目录的链接</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">rename</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">oldname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">newname</span><span class="p">);</span><span class="c1">//文件或目录用rename函数更名（如为符号链接，则处理的是符号链接本身）</span>
</span><span class='line'><span class="err">给出符号链接名的情况下，没有一个函数能删除由该链接所引用的文件。</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">symlink</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">actualpath</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">sympath</span><span class="p">);</span><span class="c1">//创建一个符号链接</span>
</span><span class='line'><span class="kt">ssize_t</span> <span class="nf">readlink</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">pathname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="kr">restrict</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">bufsize</span><span class="p">);</span><span class="c1">//打开链接本身，并读链接中的名字（open跟随符号链接）</span>
</span><span class='line'>
</span><span class='line'><span class="err">目录是包含目录项（文件名和相关的</span><span class="n">i</span><span class="err">节点编号）的文件。</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">utime</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">utimbuf</span> <span class="o">*</span><span class="n">times</span><span class="p">);</span><span class="c1">//修改文件访问和修改时间</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">mkdir</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">,</span> <span class="kt">mode_t</span> <span class="n">mode</span><span class="p">);</span><span class="c1">//创建空目录（.和..目录自动创建）（对目录通常至少要设置1个文件执行权限位，以允许访问该目录中的文件名）</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">rmdir</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">);</span><span class="c1">//删除空目录（空目录是只包含.和..目录的目录）</span>
</span><span class='line'><span class="err">如果调用此函数后目录链接计数为</span><span class="mi">0</span><span class="err">，并且没有其他进程打开此目录，则释放此目录占用空间。（链接计数为</span><span class="mi">0</span><span class="err">不一定释放空间，还要看有无被进程打开（引用计数是否变为</span><span class="mi">0</span><span class="err">））</span>
</span></code></pre></td></tr></table></div></figure>


<h4>pag98</h4>

<p>为了防止文件系统产生混乱，只有内核才能写目录（一个目录的写、执行权限位决定了在该目录中能否创建新文件以及删除文件，并不表示能否写目录本身）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">DIR</span> <span class="o">*</span><span class="nf">opendir</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">);</span><span class="c1">//返回DIR指针由以下5个函数使用</span>
</span><span class='line'><span class="k">struct</span> <span class="n">dirent</span> <span class="o">*</span><span class="nf">readdir</span><span class="p">(</span><span class="kt">DIR</span> <span class="o">*</span><span class="n">dp</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">rewinddir</span><span class="p">(</span><span class="kt">DIR</span> <span class="o">*</span><span class="n">dp</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">closedir</span><span class="p">(</span><span class="kt">DIR</span> <span class="o">*</span><span class="n">dp</span><span class="p">);</span>
</span><span class='line'><span class="kt">long</span> <span class="nf">telldir</span><span class="p">(</span><span class="kt">DIR</span> <span class="o">*</span><span class="n">dp</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">seekdir</span><span class="p">(</span><span class="kt">DIR</span> <span class="o">*</span><span class="n">dp</span><span class="p">,</span> <span class="kt">long</span> <span class="n">loc</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>当前工作目录是进程的属性，起始目录是登录名的属性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">int</span> <span class="nf">chdir</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pathname</span><span class="p">);</span><span class="c1">//更改当前目录（影响进程本身）</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">fchdir</span><span class="p">(</span><span class="kt">int</span> <span class="n">filedes</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="kt">char</span> <span class="o">*</span><span class="n">getcwd</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span><span class="err">（</span><span class="n">get</span> <span class="n">current</span> <span class="n">working</span> <span class="n">directory</span><span class="err">）</span><span class="p">;</span><span class="c1">//从当前目录（.目录）开始，用..目录找到上一级目录，然后读其目录项，直到该目录项中的i节点编号和工作目录i节点编号相同，这样就找到了其对应的文件名。</span>
</span></code></pre></td></tr></table></div></figure>

]]></content>
  </entry>
  
</feed>

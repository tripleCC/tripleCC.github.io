<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  
    
      
    

    
  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Monda:300,300italic,400,400italic,700,700italic|Monda:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Interview,CocoaPods,GitLab CI,组件自动化发布,">










<meta name="description" content="在实施业务组件化后，大部分没有组件化工具链支撑的团队一般都会遇到组件发布效率问题，如果遇到多个特性一起上线时，发布的组件数量可能达到十几二十个，手动发布这些组件的话，费时费力，非常影响开发体验。同样的，这个问题也一直困扰着我们团队，虽然后期我们通过 CI 简化了单个组件的发布，组件负责人只需要根据 Podfile 中的版本提交相应 tag 即可触发发布动作，但是 CI 并没有解决多个关联组件发布的">
<meta name="keywords" content="Interview,CocoaPods,GitLab CI,组件自动化发布">
<meta property="og:type" content="article">
<meta property="og:title" content="CocoaPods，GitLab CI 与组件自动化发布">
<meta property="og:url" content="https://triplecc.github.io/2019/01/27/CocoaPods，GitLabCI与组件自动化发布/index.html">
<meta property="og:site_name" content="tripleCC&#39;s Blog">
<meta property="og:description" content="在实施业务组件化后，大部分没有组件化工具链支撑的团队一般都会遇到组件发布效率问题，如果遇到多个特性一起上线时，发布的组件数量可能达到十几二十个，手动发布这些组件的话，费时费力，非常影响开发体验。同样的，这个问题也一直困扰着我们团队，虽然后期我们通过 CI 简化了单个组件的发布，组件负责人只需要根据 Podfile 中的版本提交相应 tag 即可触发发布动作，但是 CI 并没有解决多个关联组件发布的">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/labor-组件依赖.png">
<meta property="og:image" content="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/Snip20190214_24.png">
<meta property="og:image" content="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/Snip20190214_17.png">
<meta property="og:image" content="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/Snip20190214_18.png">
<meta property="og:image" content="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/Snip20190214_20.png">
<meta property="og:image" content="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/Snip20190214_23.png">
<meta property="og:image" content="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/Snip20190214_22.png">
<meta property="og:image" content="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/Snip20190216_25.png">
<meta property="og:image" content="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/Snip20190722_15-1.png">
<meta property="og:image" content="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/labor-总览.png">
<meta property="og:image" content="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/labor-分析依赖.png">
<meta property="og:image" content="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/labor-发布组件.png">
<meta property="og:updated_time" content="2021-05-28T00:50:58.933Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CocoaPods，GitLab CI 与组件自动化发布">
<meta name="twitter:description" content="在实施业务组件化后，大部分没有组件化工具链支撑的团队一般都会遇到组件发布效率问题，如果遇到多个特性一起上线时，发布的组件数量可能达到十几二十个，手动发布这些组件的话，费时费力，非常影响开发体验。同样的，这个问题也一直困扰着我们团队，虽然后期我们通过 CI 简化了单个组件的发布，组件负责人只需要根据 Podfile 中的版本提交相应 tag 即可触发发布动作，但是 CI 并没有解决多个关联组件发布的">
<meta name="twitter:image" content="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/labor-组件依赖.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://triplecc.github.io/2019/01/27/CocoaPods，GitLabCI与组件自动化发布/">





  <title>CocoaPods，GitLab CI 与组件自动化发布 | tripleCC's Blog</title>
  








  <script type="text/javascript">
  // https://stackoverflow.com/questions/4723213/detect-http-or-https-then-force-https-in-javascript
    var host = "triplecc.github.io"
    console.log(window.location.host, window.location.protocol)
    if ((host == window.location.host) && (window.location.protocol != "https:")) {
      console.log('切到 https 站点...')
      window.location.protocol = "https:"
    }
    console.log('加载完毕.')
  </script>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">tripleCC's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://triplecc.github.io/2019/01/27/CocoaPods，GitLabCI与组件自动化发布/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tripleCC">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tripleCC's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">CocoaPods，GitLab CI 与组件自动化发布</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-27T15:47:21+00:00">
                2019-01-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/27/CocoaPods，GitLabCI与组件自动化发布/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2019/01/27/CocoaPods，GitLabCI与组件自动化发布/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>在实施业务组件化后，大部分没有组件化工具链支撑的团队一般都会遇到组件发布效率问题，如果遇到多个特性一起上线时，发布的组件数量可能达到十几二十个，手动发布这些组件的话，费时费力，非常影响开发体验。同样的，这个问题也一直困扰着我们团队，虽然后期我们通过 CI 简化了单个组件的发布，组件负责人只需要根据 Podfile 中的版本提交相应 tag 即可触发发布动作，但是 CI 并没有解决多个关联组件发布的前后顺序问题————如果下层组件还未发布就发布上层组件，此组件的 CI 很可能会因为缺少下层组件的某些接口而执行失败。</p>
<a id="more"></a>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们团队目前是基于 GitFlow 工作流进行日常项目的开发， 项目在进入预发阶段时，关联的组件都需要拉取 release 分支，当某次发版的所有关联项目都预发测试完毕时，此次发版的负责人（通常是其中某个项目的负责人）会通知团队内部成员对组件进行封板，然后组件的负责人会去合并 release 分支到 master &amp; develop ，并且发布一个新版本，等所有组件都发布完成后，发版负责人再去更新主工程 Podfile。</p>
<p>整个发版过程，组件负责人除了需要重复若干次以下操作，还需要知悉是否有下层组件还未发布：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;&gt; 查看组件应升级版本,更新 podspec 版本并 commit</span><br><span class="line">    &gt;&gt;&gt;&gt; 合并 release 分支 ，gitflow finish release</span><br><span class="line">        &gt;&gt;&gt;&gt; 打 tag 并 push </span><br><span class="line">            &gt;&gt;&gt;&gt; CI 执行完毕，组件发布完成，可能需要通知上层组件的负责人</span><br></pre></td></tr></table></figure>
<p>可以看到如果需要发布多个组件，其过程还是非常繁琐的。</p>
<p>我们再单独说下发布顺序的问题。假设当前有需要发布的组件 A、B、C、D ，其依赖关系如下：</p>
<p><img src="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/labor-组件依赖.png" width="400"></p>
<p>在遵守 CocoaPods 发布规则的前提下，发布先后顺序应依次为 A、B-C、D ，其中 B 和 C 组件可同时发布，D 则需要等 B、C 都发布完成后才可以发布，也就是说只有当前组件的依赖没有包含未发布组件，此组件才可发布。</p>
<p>我们以前的发布情况常常是这样的：下层组件 A 由于 lint 不通过，导致依赖 A 的 B、C 都 lint 失败，由于我们没有限制开发者对私有源仓库的 push 权限，B、C 组件的负责人这时候可能就会选择向私有源仓库强推 podspec ，导致出现 lint 失败的连锁反应，越来越多的组件本身代码没问题，却因为下层组件而 lint 失败，只能选择强推 podspec 。</p>
<p>遇到这种情况，除了强调发布规则，从根本上还是要减少发版操作给组件负责人带来的工作量。</p>
<p>labor 就是为了能在一定程度上解决以上问题而创建的。在 labor 上执行发版操作时，组件负责人只需要关注 lint 的错误信息即可，剩余发布操作，包括上下层组件的发布顺序都由 labor 进行管理。</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>还是以上诉的 A、B、C、D 组件为例，在 labor 上添加发布并分析依赖后，可以看到组件发布页：</p>
<p><img src="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/Snip20190214_24.png" alt="1"></p>
<p>在发布页中，使用者可以查看依赖发布的组件，也可以修改发布组件的版本，labor 会在组件发布时同步到仓库的 podspec 文件中。</p>
<p>执行自动发布后，labor 会和 GitLab 进行一系列交互。以组件 A 为例，labor 会先创建<strong>所有发布组件</strong>目标分支的 MR ：</p>
<p><img src="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/Snip20190214_17.png" alt="1"></p>
<p>然后触发对应 release 分支的 pipeline ：</p>
<p><img src="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/Snip20190214_18.png" alt="1"></p>
<p>这里我们省去的 code review 这一步骤，如果需要的话，可以在 web 上设置入口，组件负责人设置为 review 完成后，才触发 pipeline。</p>
<p>如果 pipeline 执行成功，那么 GitLab 会自动合并 MR，如果冲突的话，需要负责人在此 MR 下解决 ：</p>
<p><img src="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/Snip20190214_20.png" alt="1"></p>
<p>MR 合并成功后，组件会更新状态为发布中（假如组件还有依赖未发布，那么这里的状态为已合并，等待依赖发布完成，状态才为发布中） ：</p>
<p><img src="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/Snip20190214_23.png" alt="1"></p>
<p>然后 labor 会给组件打 tag ，并且触发 tag 的 pipeline ：</p>
<p><img src="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/Snip20190214_22.png" alt="1"></p>
<p>在 tag 的 pipeline 执行成功后，我们就视 A 组件发布成功了。A 发布成功后，labor 会查看 B、C 对应 MR 状态执行后续操作：</p>
<ol>
<li>MR pipeline 已经执行成功，并且对应的分支已经合并到 master （组件状态：已合并）</li>
<li>MR pipeline 由于 A 没发布，lint 失败了，分支没有合并到 master（组件状态：等待中）</li>
</ol>
<p>如果是 1 状态，则直接创建 tag 发布，如果是 2 状态，则触发 MR 对应分支的 pipeline，假如此 MR 是因为 A 组件未发布导致合并失败的，那么在 A 发布后，重新触发的 MR pipeline 一般都能执行成功，当 MR 合并成功后，后续步骤与 1 一致。受益于 GitLab 分布式的 runner ，我们可以通过 CI 同时发布多个组件。</p>
<p>当所有组件发布完成后，labor 会根据使用者输入的组件版本，更新发版工程的 Podfile：</p>
<p><img src="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/Snip20190216_25.png" alt="1"></p>
<p>以上就是 labor 的主要工作步骤，可以看到，使用 labor 发版后，组件负责人只需要确保 MR 能顺利合并即可，不需要等待下层组件负责人发布完成的通知，也省去了繁琐的发布操作。</p>
<p>截止到目前为止，labor 已经帮助掌柜团队执行了近 30 次自动发布，每次发布的组件个数平均在 15 个左右，节省了很多组员沟通与操作时间。</p>
<p><img src="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/Snip20190722_15-1.png" alt="1"></p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>labor 由如下几个服务构成 ：</p>
<p><img src="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/labor-总览.png" alt="labor-总览"></p>
<p>其中 web 端主要专注于发版交互与组件发布数据的展示，后端负责发版信息采集、组件发布任务调度以及和 GitLab 进行通信，websocket server 主要负责实时更新 web 中组件的发布状态。server 中很多操作都是与 GitLab 进行交互，耗时较多，所以 server 中的大部分 service 都是交给 sidekiq（后台任务处理系统）执行的。</p>
<p>接下来我会根据自身实践经历，说下主要流程的实现方式。</p>
<h2 id="发布类型"><a href="#发布类型" class="headerlink" title="发布类型"></a>发布类型</h2><p>依据发布性质，labor 把发布分为两种：</p>
<ul>
<li>主发布 (main deploy)</li>
<li>子发布 (pod deploy)</li>
</ul>
<p>这里主发布的主体是发版工程，子发布的主体是组件。其中主发布主要负责发版工程信息的获取和更新，比如依赖的分析、最后目标分支 Podfile 的更新等。 主发布经过分析后，会创建若干子发布，子发布则负责组件发布的所有流程，包括组件 MR 的创建，组件 tag 的创建，发布 CI 的触发等。</p>
<p>主发布和子发布涉及的所有状态如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">created:      <span class="string">'待分析'</span>,</span><br><span class="line">analyzing:    <span class="string">'分析中'</span>,</span><br><span class="line">preparing:    <span class="string">'准备中'</span>,</span><br><span class="line">pending:      <span class="string">'等待中'</span>,</span><br><span class="line">waiting:      <span class="string">'待发布'</span>,</span><br><span class="line">skipped:      <span class="string">'已忽略'</span>,</span><br><span class="line">merged:       <span class="string">'已合并'</span>,</span><br><span class="line">deploying:    <span class="string">'发布中'</span>,</span><br><span class="line">success:      <span class="string">'发布成功'</span>,</span><br><span class="line">failed:       <span class="string">'发布失败'</span>,</span><br><span class="line">canceled:     <span class="string">'已取消'</span>,</span><br></pre></td></tr></table></figure>
<p>我们使用 <a href="https://github.com/state-machines/state_machines-activerecord" target="_blank" rel="noopener">state_machines-activerecord</a> 以状态机的形式对发布状态进行管理，状态发生变更之后，都会通过 websocket 同步到 web 端。</p>
<h2 id="分析依赖"><a href="#分析依赖" class="headerlink" title="分析依赖"></a>分析依赖</h2><p>分析目标工程的组件依赖是发版的第一步，对应主发布的 analyzing 状态，下面是 labor 分析步骤的序列图：</p>
<p><img src="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/labor-分析依赖.png" alt="labor-分析依赖"></p>
<p>首先，web 向 server 端发起分析依赖请求，server 接收到请求后，使用 <a href="https://github.com/NARKOZ/gitlab.git" target="_blank" rel="noopener">gitlab</a>  向 GitLab 请求 Podfile 文件内容。由于 Podfile 可能在仓库的根目录或者 Example 文件夹下，这里我们使用了 5 层深度的递归查询来获取文件路径。</p>
<p>获取到 Podfile 路径后，再根据文件内容创建 Podfile 对象：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Labor::RemoteFile::Base</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_contents</span></span></span><br><span class="line">  @file_contents <span class="params">||</span>= gitlab.file_contents(@project_id, @path, @ref)</span><br><span class="line"><span class="keyword">rescue</span> Gitlab::Error::NotFound =&gt; error</span><br><span class="line">  <span class="comment"># self.class.name.demodulize</span></span><br><span class="line">  <span class="comment"># [2..-1]</span></span><br><span class="line">  raise Labor::Error::NotFound.new(<span class="string">"Can't find <span class="subst">#&#123;<span class="keyword">self</span>.<span class="keyword">class</span>.name.split(<span class="string">'::'</span>).drop(<span class="number">2</span>).join(<span class="string">''</span>)&#125;</span> with error <span class="subst">#&#123;error.message&#125;</span>"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Labor::RemoteFile::Podfile</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">podfile</span></span></span><br><span class="line">  @podfile <span class="params">||</span>= <span class="keyword">begin</span></span><br><span class="line">    content = file_contents</span><br><span class="line">    podfile = Pod::Podfile.from_ruby(Pathname.new(path), content)</span><br><span class="line">    podfile</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>生成 Podfile 对象后就可以分析发版信息了。我们会先过滤出需要发版的依赖：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">podfile.dependencies.select &#123; <span class="params">|dependency|</span> dependency.external? &amp;&amp; dependency.external_source[<span class="symbol">:tag</span>].<span class="literal">nil</span>?&#125;</span><br></pre></td></tr></table></figure>
<p>然后通过同样的方式循环获取这些依赖的 podspec 文件，并且构建 Specification 对象 ：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">untagged_specs = Parallel.map(untagged_git_dependencies, <span class="symbol">in_threads:</span> <span class="number">5</span>) <span class="keyword">do</span> <span class="params">|dep|</span>  </span><br><span class="line">  git = dep.external_source[<span class="symbol">:git</span>]</span><br><span class="line">  ref = dep.external_source[<span class="symbol">:branch</span>]</span><br><span class="line">  component_project = gitlab.project(git)</span><br><span class="line">  remote_file = Labor::RemoteFile::Specification.new(component_project.id, ref)</span><br><span class="line">  remote_file.specification</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这里可以利用多线程加快执行效率，不过线程数不要过多，不然容易造成 GitLab 返回数据失败。</p>
<p>获取到所有需要发布的 spec 后，我们会结合组件与其依赖、间接依赖创建发布结构，然后保存至数据库。同样以 A、B、C、D 组件为例，它们的 podspec 依赖如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># podspec</span><br><span class="line">A</span><br><span class="line"></span><br><span class="line">B</span><br><span class="line">&gt; A</span><br><span class="line"></span><br><span class="line">C</span><br><span class="line">&gt; A</span><br><span class="line"></span><br><span class="line">D</span><br><span class="line">&gt; B</span><br><span class="line">&gt; C</span><br></pre></td></tr></table></figure>
<p>最终生成的发布结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 发布结构</span><br><span class="line">A</span><br><span class="line"></span><br><span class="line">B</span><br><span class="line">&gt; A</span><br><span class="line"></span><br><span class="line">C</span><br><span class="line">&gt; A</span><br><span class="line"></span><br><span class="line">D</span><br><span class="line">&gt; A</span><br><span class="line">&gt; B</span><br><span class="line">&gt; C</span><br></pre></td></tr></table></figure>
<p>当 A 发布完成后，发布结构转变为 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 发布结构</span><br><span class="line">A</span><br><span class="line"></span><br><span class="line">B</span><br><span class="line"></span><br><span class="line">C</span><br><span class="line"></span><br><span class="line">D</span><br><span class="line">&gt; B</span><br><span class="line">&gt; C</span><br></pre></td></tr></table></figure>
<p>B、C 组件会在需要发布的依赖清空之后，继续执行组件发布的后续操作 。</p>
<h2 id="发布组件"><a href="#发布组件" class="headerlink" title="发布组件"></a>发布组件</h2><p>组件的发布是整个服务的核心功能，顺利发布单个组件时的序列图如下：</p>
<p><img src="https://github.com/tripleCC/tripleCC.github.io/raw/master/images/labor-发布组件.png" alt="labor-发布组件"></p>
<p>上图中省略了部分和 websocket server 相关的逻辑，实际上其右边的状态发生变更时，都会进行 12、13 步骤的消息流动。</p>
<p>如果是自动发布所有组件，而不是发布单个组件，labor 会对主发布分析出的所有组件执行发布操作，这样相关负责人就可以选择提前去 review MR 上需要合并的代码，而不是等依赖的组件发布完成。</p>
<p>对于已知 lint 不通过，短时间无法解决错误的组件，labor 提供了手动标志组件发布成功的功能，使用者需要手动发布组件，再设置发布成功。添加这个功能主要是考虑到发版工程会接入其他业务线的组件，而我们并不想让这些组件影响发版进程。</p>
<p>组件发布过程中，根据处理对象的不同，又可分为以下两个阶段，</p>
<ul>
<li>准备阶段 （preparing ～ pending）</li>
<li>正式发布阶段 （merged ～ success）</li>
</ul>
<p>下面会简略地进行说明。</p>
<h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><p>首先，server 会给还未配置过的组件工程添加 webhook ，GitLab 很多任务都是放到 sidekiq 的，要想获取任务的执行信息，只能通过 webhook 让 GitLab 主动发送，所以这一步是组件能自动发布的重要前提。</p>
<p>接着，server 会校验创建 MR 的必要条件：</p>
<ul>
<li>组件仓库必须要有 CI 配置文件，并且文件中包含发布 stage</li>
<li>组件仓库的 default 分支必须为 master</li>
</ul>
<p>如果满足以上条件，我们会继续处理目标组件的 podspec 版本。</p>
<p>labor 在分析依赖时，默认会使用 release 分支名中或者 podspec 中较高的版本号作为发布版本，如果实际发布时，组件发布版本比仓库中的 podspec 高，就需要更新 GitLab 仓库中 podspec 的 version 字段。</p>
<p>以下是我们更新 podspec 版本的代码：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update_podspec_content</span><span class="params">(podspec_content, version)</span></span></span><br><span class="line">  require_variable_prefix = <span class="literal">true</span></span><br><span class="line">  version_var_name = <span class="string">'version'</span></span><br><span class="line">  variable_prefix = require_variable_prefix ? <span class="regexp">/\w\./</span> : <span class="regexp">//</span></span><br><span class="line">  version_regex = <span class="regexp">/^(?&lt;begin&gt;[^#]*<span class="subst">#&#123;variable_prefix&#125;</span><span class="subst">#&#123;version_var_name&#125;</span>\s*=\s*['"])(?&lt;value&gt;(?&lt;major&gt;[0-9]+)(\.(?&lt;minor&gt;[0-9]+))?(\.(?&lt;patch&gt;[0-9]+))?(?&lt;appendix&gt;(\.[0-9]+)*)?(-(?&lt;prerelease&gt;(.+)))?)(?&lt;end&gt;['"])/i</span></span><br><span class="line"></span><br><span class="line">  version_match = version_regex.match(podspec_content)</span><br><span class="line">  updated_podspec_content = podspec_content.gsub(version_regex, <span class="string">"<span class="subst">#&#123;version_match[<span class="symbol">:begin</span>]&#125;</span><span class="subst">#&#123;version&#125;</span><span class="subst">#&#123;version_match[<span class="symbol">:end</span>]&#125;</span>"</span>)</span><br><span class="line">  updated_podspec_content</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>更新字符串后，同步至 GitLab：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab.edit_file(@project_id, @path, @ref, content, <span class="string">"更正 podspec 版本 <span class="subst">#&#123;version&#125;</span>"</span>.ci_skip)</span><br></pre></td></tr></table></figure>
<p>这里我们的 commit 信息以 [ci skip] 作为前缀，以减少触发不必要的 pipeline。</p>
<p>最后，我们会校验目标分支是否为 master 或者已经合并到 master ，如果是的话，server 会直接标记此发布为 merged ，等待正式发布，否则 server 会给组件仓库创建 MR ，发布进入 pending 状态，等依赖的组件都发布完成后，如果此 MR 还未合并，server 会重新触发 MR 关联的 pipeline ，pipeline 运行成功，目标分支合入 master 后，再执行正式发布。</p>
<h3 id="正式发布阶段"><a href="#正式发布阶段" class="headerlink" title="正式发布阶段"></a>正式发布阶段</h3><p>由于 tag 触发的 pipeline 包含二进制打包、源码及二进制版本发布的 stage ，所以在这个阶段我们只需要管理 tag 及关联的 pipeline 就可以实现发布功能了。</p>
<p>这时候如果 tag 版本已经存在，GitLab 会返回创建失败，虽然 GitLab 提供了删除 tag 的功能，但还是不建议这么做的，我们会在 web 端提示发布失败，并且注明 tag 已存在，让组件负责人修改版本后重试发布此组件。</p>
<p>GitLab 创建 tag 操作是异步的，所以我们会在 webhook 中监听 tag 创建结果，创建成功之后，就可以处理 pipeline 了。上文提到过 以 [ci skip] 开头 commit 不会触发 pipeline ，所以我们需要在这里做下判断，如果已经有 pipeline ，那么只更新对应数据库条目，否则就需要创建新的 pipeline 。</p>
<h2 id="更新依赖"><a href="#更新依赖" class="headerlink" title="更新依赖"></a>更新依赖</h2><p>在所有组件发布完成后，我们会把变更的组件版本，同步到发版工程对应分支的 Podfile 中。受限于目前的工作流程和有限的工具链，我们在开发时，还是避免不了手动修改 Podfile ，所以我们依旧使用 ruby 来编写 Podfile ，没有使用 YAML 或者 JSON 格式 （pod ipc podfile/podfile-json 可查看）。</p>
<p>过于灵活的编写方式，使得对其执行正则匹配需要以先推行编写规范为基础，所以这里我决定不使用正则，而是让开发者提供 Podfile 模版，比如正常的 Podfile 为：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一些 ruby 语法的配置</span></span><br><span class="line">target <span class="string">'E'</span> <span class="keyword">do</span></span><br><span class="line">  pod <span class="string">'A'</span>, <span class="symbol">git:</span> <span class="string">'xxxx'</span>, <span class="symbol">branch:</span> <span class="string">'release/0.1.0'</span></span><br><span class="line">  pod <span class="string">'J'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 一些 ruby 语法的配置</span></span><br></pre></td></tr></table></figure>
<p>那么开发者可以在同级目录下，添加 PodfileTemplate :</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一些 ruby 语法的配置</span></span><br><span class="line">target <span class="string">'E'</span> <span class="keyword">do</span></span><br><span class="line"><span class="symbol">:TRIPLECCREPLACEME</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 一些 ruby 语法的配置</span></span><br></pre></td></tr></table></figure>
<p>labor 会先获取原 Podfile，解析其依赖之后，再根据数据库中的组件及其发布版本号，更新这些依赖，然后将 PodfileTemplate 文件的 <code>:TRIPLECCREPLACEME</code> 替换成更新后的依赖，以生成新的 Podfile ：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一些 ruby 语法的配置</span></span><br><span class="line">target <span class="string">'E'</span> <span class="keyword">do</span></span><br><span class="line">  pod <span class="string">'A'</span>, <span class="string">'= 0.1.0'</span></span><br><span class="line">  pod <span class="string">'J'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 一些 ruby 语法的配置</span></span><br></pre></td></tr></table></figure>
<p>当然，在工具链成熟的情况下，使用 JSON 或者 YAML 格式编写的 Podfile ，更易于自动化处理，所以个人推荐前期最好不要在 Podfile 中添加过多 ruby 自定义代码，如果需要的话，可以以 cocoapods 插件的形式集成。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由于 labor 只是个人在开发维护，所以制定流程和细节处理上可能不是非常合理，但就目前成果来看，labor 还是初步实现了发版时的组件自动化发布。文章中更多的是展示了正常发布流程，实际上整个发布过程中，还是要处理挺多异常流程的。</p>
<p>不过在发版本时才统一对需要发布的组件进行验证，容易出现解决组件 lint 错误时间过长影响发版问题，所以可能还是需要添加组件准入规则，将这部分验证往前移，比如约束主工程的分支权限，在预发提测前让开发者预先打 rc 版本，确保 rc 版本验证成功之后，再以 web 操作的方式接入主工程，预发阶段修复组件 bug 后，重新走接入流程，这样应该就能保证发版时，需要发布组件的正确性了（关于 rc 版本的 lint ，可能还需要变更下 CocoaPods 查找版本的默认方式，毕竟 Semantic Versioning 优先采用正式版本）。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Interview/" rel="tag"># Interview</a>
          
            <a href="/tags/CocoaPods/" rel="tag"># CocoaPods</a>
          
            <a href="/tags/GitLab-CI/" rel="tag"># GitLab CI</a>
          
            <a href="/tags/组件自动化发布/" rel="tag"># 组件自动化发布</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/21/基于CocoaPods的组件二进制化实践/" rel="next" title="基于 CocoaPods 的组件二进制化实践">
                <i class="fa fa-chevron-left"></i> 基于 CocoaPods 的组件二进制化实践
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/20/objective-c-weak-implement/" rel="prev" title="Objective-C weak 弱引用实现">
                Objective-C weak 弱引用实现 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="tripleCC">
            
              <p class="site-author-name" itemprop="name">tripleCC</p>
              <p class="site-description motion-element" itemprop="description">ʕ•̫͡•ʔ-̫͡-ʕ•͓͡•ʔ-̫͡-ʕ•̫͡•ʔ-̫͡-ʕ•͓͡•ʔ-̫͡-ʔ</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">63</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/tripleCC" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/97e39e95c2cc" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-globe"></i>简书</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/tripleCCBrian" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://stackoverflow.com/users/5187957/triplecc" target="_blank" title="StackOverflow">
                      
                        <i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:triplec.linux@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#背景"><span class="nav-number">1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#效果"><span class="nav-number">2.</span> <span class="nav-text">效果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概览"><span class="nav-number">3.</span> <span class="nav-text">概览</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发布类型"><span class="nav-number">4.</span> <span class="nav-text">发布类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分析依赖"><span class="nav-number">5.</span> <span class="nav-text">分析依赖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发布组件"><span class="nav-number">6.</span> <span class="nav-text">发布组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#准备阶段"><span class="nav-number">6.1.</span> <span class="nav-text">准备阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正式发布阶段"><span class="nav-number">6.2.</span> <span class="nav-text">正式发布阶段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更新依赖"><span class="nav-number">7.</span> <span class="nav-text">更新依赖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#总结"><span class="nav-number">8.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tripleCC</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://tripleCC.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://triplecc.github.io/2019/01/27/CocoaPods，GitLabCI与组件自动化发布/';
          this.page.identifier = '2019/01/27/CocoaPods，GitLabCI与组件自动化发布/';
          this.page.title = 'CocoaPods，GitLab CI 与组件自动化发布';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://tripleCC.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>

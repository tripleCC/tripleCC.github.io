<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  
    
      
    

    
  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Monda:300,300italic,400,400italic,700,700italic|Monda:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Interview,objective-c,runtime,">










<meta name="description" content="Objective-C的runtime语言使它具备了动态语言的特性，也就是平时所说的“运行时”。在runtime的基础上，可以做很多平时难以想到事，或者化简原先 较为繁杂的解决方案。相对于静态语言，比如C以下程序 1234567#include &amp;lt;stdio.h&amp;gt;void run()&amp;#123;&amp;#125;int main()&amp;#123;	return 0;&amp;#125;">
<meta name="keywords" content="Interview,objective-c,runtime">
<meta property="og:type" content="article">
<meta property="og:title" content="runtime基础">
<meta property="og:url" content="https://triplecc.github.io/2015/07/10/2015-08-27-runtimeji-chu/index.html">
<meta property="og:site_name" content="tripleCC&#39;s Blog">
<meta property="og:description" content="Objective-C的runtime语言使它具备了动态语言的特性，也就是平时所说的“运行时”。在runtime的基础上，可以做很多平时难以想到事，或者化简原先 较为繁杂的解决方案。相对于静态语言，比如C以下程序 1234567#include &amp;lt;stdio.h&amp;gt;void run()&amp;#123;&amp;#125;int main()&amp;#123;	return 0;&amp;#125;">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://triplecc.github.io/images/Snip20150711_1.png">
<meta property="og:image" content="https://triplecc.github.io/images/Snip20150711_2.png">
<meta property="og:updated_time" content="2021-05-28T00:50:58.929Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="runtime基础">
<meta name="twitter:description" content="Objective-C的runtime语言使它具备了动态语言的特性，也就是平时所说的“运行时”。在runtime的基础上，可以做很多平时难以想到事，或者化简原先 较为繁杂的解决方案。相对于静态语言，比如C以下程序 1234567#include &amp;lt;stdio.h&amp;gt;void run()&amp;#123;&amp;#125;int main()&amp;#123;	return 0;&amp;#125;">
<meta name="twitter:image" content="https://triplecc.github.io/images/Snip20150711_1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://triplecc.github.io/2015/07/10/2015-08-27-runtimeji-chu/">





  <title>runtime基础 | tripleCC's Blog</title>
  








  <script type="text/javascript">
  // https://stackoverflow.com/questions/4723213/detect-http-or-https-then-force-https-in-javascript
    var host = "triplecc.github.io"
    console.log(window.location.host, window.location.protocol)
    if ((host == window.location.host) && (window.location.protocol != "https:")) {
      console.log('切到 https 站点...')
      window.location.protocol = "https:"
    }
    console.log('加载完毕.')
  </script>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">tripleCC's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://triplecc.github.io/2015/07/10/2015-08-27-runtimeji-chu/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tripleCC">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="tripleCC's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">runtime基础</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-07-10T12:14:17+00:00">
                2015-07-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/runtime/" itemprop="url" rel="index">
                    <span itemprop="name">runtime</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2015/07/10/2015-08-27-runtimeji-chu/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/07/10/2015-08-27-runtimeji-chu/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Objective-C的runtime语言使它具备了动态语言的特性，也就是平时所说的“运行时”。在runtime的基础上，可以做很多平时难以想到事，或者化简原先 较为繁杂的解决方案。<br><br>相对于静态语言，比如C以下程序</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">void</span> run()</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>执行<code>clang -c</code>进行编译后，获取符号表<code>nm run.o</code>，可以得到全局唯一的符号<code>_run</code>，对函数run的调用直接参考链接后_run符号在代码段的地址</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000000000000010</span> T _main</span><br><span class="line"><span class="number">0000000000000000</span> T _run</span><br></pre></td></tr></table></figure>
<p>对比Objective-C的以下函数<br></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Dog</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)run</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Dog *dog = [[Dog alloc] init];</span><br><span class="line">        [dog run];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行<code>clang -rewrite-objc main.m</code>将其转换成底层C++文件后可以得到</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        Dog *dog = ((Dog *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)((Dog *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"Dog"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</span><br><span class="line">        ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)dog, sel_registerName(<span class="string">"run"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，对Objective-C编译前期，会将内部的方法调用，转换成调用<code>objc_msgSend</code>。也就是说，编译完成后，方法地址是不能确定的，需要在运行时，通过Selector进行查找，而这正是runtime的关键，也就是发送消息机制。</p>
<h2 id="runtime的基本要素"><a href="#runtime的基本要素" class="headerlink" title="runtime的基本要素"></a>runtime的基本要素</h2><p>如上面例子所示，在编译后<code>[dog run]</code>被编译器转化成了</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)dog, sel_registerName(<span class="string">"run"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设能省略(void (*)(id, SEL))(void *)和id指针强转[实际上还是需要的]</span></span><br><span class="line"><span class="comment">// sel_registerName表示注册一个selector</span></span><br><span class="line">objc_msgSend(dog, sel_registerName(<span class="string">"run"</span>));</span><br></pre></td></tr></table></figure>
<p>将上面的情况抽取成统一的说法就是，在编译器编译后<code>[receiver message]</code>会被转化成以下形式</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)</span><br></pre></td></tr></table></figure>
<p><code>objc_msgSend</code>是一个消息发送函数，它以消息接收者和方法名作为基础参数。<br><br>在有参数的情况下，则会被转换为</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
<p>消息的接收者receiver在接受到消息后，查找对应selector的实现，根据查找的结果可以进行若干种种不同的处理。<br><br>更深层的了解，需要了解下对应的数据结构</p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>上文中<code>objc_msgSend</code>的第一个参数有个强转类型，即id。id是可以指向对象的万能指针，查看runtime源码，得知其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objc_object</span></span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    isa_t isa;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isa_t</span></span><br><span class="line"><span class="keyword">union</span> isa_t</span><br><span class="line">&#123;</span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据<code>union</code>联合的存储空间以大成员的存储空间计算性质，可以猜测<code>isa_t</code>的作用只是真不同位数处理器的优化，我们可以直接这样表示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">private:</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>id</code>是一个指向<code>objc_object</code>结构体的指针（注意，在runtime中对象可以用结构体进行表示）。<br><br><code>objc_object</code>结构体包含了<code>Class isa</code>成员，而<code>isa</code>就是我们常说的创建一个对象时，用来指向所属类的<code>指针</code>。因此根据<code>isa</code>就可以获取对应的类。</p>
<ul>
<li>注：C++中结构的作用被拓宽了，也表示定义一个类的类型，struct和class的区别就在默认类型上一个是public,一个是private，这里就直接描述为结构体了</li>
</ul>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><p>上文中，<code>isa</code>为<code>Class</code>类型，而<code>Class</code>则是<code>objc_class</code>指针类型的别名：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</span><br></pre></td></tr></table></figure>
<p>而<code>objc_class</code>具体的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class : objc_object &#123;</span><br><span class="line">    <span class="comment">// Class ISA;</span></span><br><span class="line">    Class superclass;</span><br><span class="line">    cache_t cache;             <span class="comment">// formerly cache pointer and vtable</span></span><br><span class="line">    class_data_bits_t bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class_data_bits_t</span></span><br><span class="line"><span class="keyword">struct</span> class_data_bits_t &#123;</span><br><span class="line">    ...</span><br><span class="line">public:</span><br><span class="line">    class_rw_t* data() &#123;</span><br><span class="line">        <span class="keyword">return</span> (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class_rw_t</span></span><br><span class="line"><span class="keyword">struct</span> class_rw_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> class_ro_t *ro;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        method_list_t **method_lists;  <span class="comment">// RW_METHOD_ARRAY == 1</span></span><br><span class="line">        method_list_t *method_list;    <span class="comment">// RW_METHOD_ARRAY == 0</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">struct</span> chained_property_list *properties;</span><br><span class="line">    <span class="keyword">const</span> protocol_list_t ** protocols;</span><br><span class="line"></span><br><span class="line">    Class firstSubclass;</span><br><span class="line">    Class nextSiblingClass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *demangledName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class_ro_t</span></span><br><span class="line"><span class="keyword">struct</span> class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    uint32_t reserved;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * ivarLayout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="keyword">const</span> method_list_t * baseMethods;</span><br><span class="line">    <span class="keyword">const</span> protocol_list_t * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * weakIvarLayout;</span><br><span class="line">    <span class="keyword">const</span> property_list_t *baseProperties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上文中已经介绍过<code>objc_object</code>结构体，<code>objc_class</code>继承自结构体<code>objc_object</code>。可以看出<code>objc_object</code>的<code>isa</code>为<code>private</code>类型成员变量，<code>objc_class</code>继承后无法访问，所以<code>objc_object</code>提供了以下两个成员函数:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class ISA();</span><br><span class="line"></span><br><span class="line"><span class="comment">// getIsa内部调用ISA返回isa_t联合中cls成员</span></span><br><span class="line">Class getIsa();</span><br></pre></td></tr></table></figure>
<p>所以，对<code>objc_class</code>重要的成员变量进行下解释:</p>
<ul>
<li><code>isa</code>为指向对象对应类的指针（这里注意一点，由于类也是一个对象（单例），所以这个单例中也有一个<code>isa</code>指针指向类对象所属的类-&gt;<code>metaClass</code>，即元类）</li>
<li><code>superclass</code>为指向父类的指针</li>
<li><code>cache</code>用于对调用方法的缓存，类似CPU先访问L1、L2、L3缓存的目的相似，它也是推断<code>最近调用的方法极有可能被二次调用</code>，并将其存入<code>cache</code>，在二次调用时先在<code>cache</code>查找方法，而不是直接在类的方法列表中查找</li>
<li><code>properties</code>为属性列表</li>
<li><code>protocols</code>为协议列表</li>
<li><code>method_lists</code>/<code>method_list</code>为方法列表</li>
<li><code>ivars</code>为成员变量列表</li>
<li><code>class_ro_t</code>结构体中存储的都是类基本的东西，比如获取<code>&#39;load&#39;</code>方法时，是从<code>baseMethods</code>获取相应的IMP函数实现的：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">IMP objc_class::getLoadMethod()</span><br><span class="line">&#123;</span><br><span class="line">    rwlock_assert_locked(&amp;runtimeLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> method_list_t *mlist;</span><br><span class="line">    uint32_t i;</span><br><span class="line"></span><br><span class="line">    assert(isRealized());</span><br><span class="line">    assert(ISA()-&gt;isRealized());</span><br><span class="line">    assert(!isMetaClass());</span><br><span class="line">    assert(ISA()-&gt;isMetaClass());</span><br><span class="line"></span><br><span class="line">    mlist = ISA()-&gt;data()-&gt;ro-&gt;baseMethods;</span><br><span class="line">    <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; mlist-&gt;count; i++) &#123;</span><br><span class="line">            method_t *m = method_list_nth(mlist, i);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *name = sel_cname(m-&gt;name);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == strcmp(name, <span class="string">"load"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> m-&gt;imp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中先了解下<code>ivar_list_t</code>、<code>method_list_t</code>、<code>cache_t</code>的结构定义：<br></p>
<p><code>ivar_list_t</code>的结构为：</p>
<ul>
<li><code>ivar_t</code>就是对应的成员变量</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ivar_list_t &#123;</span><br><span class="line">    uint32_t entsize;</span><br><span class="line">    uint32_t count;</span><br><span class="line">    ivar_t first;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>method_list_t</code>为：</p>
<ul>
<li>其中<code>method_iterator</code>为结构体自己构造的一个迭代器，用来访问方法，可以看到，构造的迭代器结构体中包含了<code>method</code>成员变量</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> method_list_t &#123;</span><br><span class="line">    uint32_t entsize_NEVER_USE;  <span class="comment">// high bits used for fixup markers</span></span><br><span class="line">    uint32_t count;</span><br><span class="line">    method_t first;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iterate methods, taking entsize into account</span></span><br><span class="line">    <span class="comment">// fixme need a proper const_iterator</span></span><br><span class="line">    <span class="keyword">struct</span> method_iterator &#123;</span><br><span class="line">    	uint32_t entsize;</span><br><span class="line">        uint32_t index;  <span class="comment">// keeping track of this saves a divide in operator-</span></span><br><span class="line">        method_t* method;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>cache_t</code>为：</p>
<ul>
<li>可以看出<code>bucket_t</code>包含了一个<code>IMP</code>类型的私有成员，供查找后调用实现</li>
<li><code>_occupied</code>和<code>_mask</code>分别表示<code>实际占用</code>的缓存_buckets总数和<code>分配</code>的缓存_buckets总数</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cache_t &#123;</span><br><span class="line">    <span class="keyword">struct</span> bucket_t *_buckets;</span><br><span class="line">    mask_t _mask;</span><br><span class="line">    mask_t _occupied;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bucket_t</span></span><br><span class="line"><span class="keyword">struct</span> bucket_t &#123;</span><br><span class="line">private:</span><br><span class="line">    cache_key_t _key;</span><br><span class="line">    IMP _imp;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上文还涉及到了一个概念<code>metaClass</code>元类，元类为类对象所属的类，以实例解释：<br><br>当我们调用类方法时，消息的接收者即为类，如文中一开始的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dog *dog = [[Dog alloc] init];</span><br></pre></td></tr></table></figure>
<p>这里的<code>alloc</code>消息即发送给了<code>Dog</code>类，编译转换后的代码为:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dog *dog = ((Dog *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)((Dog *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"Dog"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</span><br></pre></td></tr></table></figure>
<p>我们只需要关注这一行：</p>
<ul>
<li>这里获取到的是类对象，只要再获取一次就得到了元类</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc_getClass表示根据对象名获取对应的类</span></span><br><span class="line">objc_getClass(<span class="string">"Dog"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取元类</span></span><br><span class="line">objc_getClass(objc_getClass(<span class="string">"Dog"</span>))</span><br></pre></td></tr></table></figure>
<p>关于元类，苹果提供了这么一张表：<br><br><img src="/images/Snip20150711_1.png" alt=""><br><br>图中的实线是<code>superclass</code>指针，虚线是<code>isa</code>指针。可以看到，根元类的超类<code>NSObject</code>(Root class)并没有对应的超类，并且，它的<code>isa</code>指针指向了自己。<br>总结一下：</p>
<ul>
<li>每个实例对象的<code>isa</code>都指向了所属的<code>类</code></li>
<li>每个类对象的<code>isa</code>都指向了所属的类，即<code>元类</code>，其<code>superclass</code>指针指向继承的<code>父类</code></li>
<li>每个元类的<code>isa</code>都指向了<code>超类</code>，即<code>NSObject</code></li>
</ul>
<h3 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h3><p><code>Ivar</code>，我把它理解成<code>instance variable</code>，也就是实例变量，可以观察它的定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> ivar_t *Ivar;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ivar_t</span></span><br><span class="line"><span class="keyword">struct</span> ivar_t &#123;</span><br><span class="line">    int32_t *offset;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;</span><br><span class="line">    <span class="comment">// alignment is sometimes -1; use alignment() instead</span></span><br><span class="line">    uint32_t alignment_raw;</span><br><span class="line">    uint32_t size;</span><br><span class="line">	<span class="comment">// 内存中数据对齐（如字对齐、半字对齐等）</span></span><br><span class="line">    uint32_t alignment() &#123;</span><br><span class="line">        <span class="keyword">if</span> (alignment_raw == ~(uint32_t)<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>U &lt;&lt; WORD_SHIFT;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; alignment_raw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Ivar</code>其实是指向<code>ivar_t</code>结构体的指针，它包含了实例变量名（name）、类型（type）、相对对象地址偏移（offset）以及内存数据对齐等信息。<br><br>跟多关于实例变量的剖析可以查看<a href="http://quotation.github.io/objc/2015/05/21/objc-runtime-ivar-access.html" target="_blank" rel="noopener">Objective-C类成员变量深度剖析</a></p>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>从以下定义的结构体可以看出，<code>Method</code>主要住用为关联了方法名<code>SEL</code>和方法的实现<code>IMP</code>，当遍通过<code>Method</code>自己的定义的迭代器查找方法名<code>SEL</code>时，就可以找到对应的方法实现<code>IMP</code>，从而调用方法的实现执行相关的操作。<code>types</code>表示方法实现的参数以及返回值类型。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> method_t *Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">// method_t</span></span><br><span class="line"><span class="keyword">struct</span> method_t &#123;</span><br><span class="line">    SEL name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types;</span><br><span class="line">    IMP imp;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h3><p><code>SEL</code>为方法选择器，观察下它的定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL;</span><br></pre></td></tr></table></figure>
<p>可以看出<code>SEL</code>实际是<code>objc_selector</code>指针类型的别名，它用于表示运行时方法的名字，以便进行方法实现的查找。因为要对应方法实现，所以每一个方法对应的<code>SEL</code>都是唯一的。因此它不具备C++可以进行函数重载的特性，当两个方法名一样时，会发生编译错误，即使参数不一样。</p>
<h3 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h3><p><code>IMP</code>的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (*IMP)(<span class="keyword">void</span> <span class="comment">/* id, SEL, ... */</span> );</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">id</span> (*IMP)(<span class="keyword">id</span>, SEL, ...);</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure>
<p>可以看出<code>IMP</code>其实就是一个函数指针的别名，也可以把它理解为函数名。它有两个必须的参数：<br></p>
<ul>
<li><code>id</code>，为<code>self</code>指针，表示消息接收者</li>
<li><code>SEL</code>，方法选择器，表示一个方法的<code>selector</code>指针</li>
<li>后面的为传送消息的一些参数<br></li>
</ul>
<p>在某些情况下，通过获取<code>IMP</code>而直接调用方法实现，可以直接跳过消息传递机制，像C语言调用函数那样，在一定程度上，可以提供程序的性能。</p>
<h3 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h3><p>了解完runtime中一些必要的元素，继续回到文章开头的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Dog</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)run</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Dog *dog = [[Dog alloc] init];</span><br><span class="line">        [dog run];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器将其转换成了：</p>
<ul>
<li>为了看起来简洁点，我把一些强制转换变为别名</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> (Dog *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) MyImp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        Dog *dog = ((MyImp)objc_msgSend)((<span class="keyword">id</span>)((MyImp)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"Dog"</span>), sel_registerName(<span class="string">"alloc"</span>)), sel_registerName(<span class="string">"init"</span>));</span><br><span class="line">        ((MyImp)objc_msgSend)((<span class="keyword">id</span>)dog, sel_registerName(<span class="string">"run"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出，第二个<code>objc_msgSend</code>返回值是作为第一个<code>objc_msgSend</code>的首个参数的。<br><br>上文已经说过，<code>[receiver message]</code>会被转化成以下形式</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_msgSend(receiver, selector, ...)</span><br></pre></td></tr></table></figure>
<p>接下来看看它主要做了哪几件事情：</p>
<ul>
<li>根据<code>receiver</code>的<code>isa</code>指针，获取到所属类，先在类的<code>cache</code>即缓存中查找<code>selector</code>，如果没有找到，再在类的<code>method_lists</code>即方法列表中查找</li>
<li>如果没有找到<code>selector</code>，则会沿着下图类的联系路径一直查找，直到<code>NSObject</code>类</li>
<li>如果找到了<code>selector</code>，则获取实现方法并调用，并传入接收者对象以及方法的所有参数；没有找到时走方法解析和消息转发流程。</li>
<li>将实现的返回值作为它自己的返回值<br><br><img src="/images/Snip20150711_2.png" alt=""></li>
</ul>
<p>除此之外，<code>objc_msgSend</code>还会传递两个隐藏参数：</p>
<ul>
<li>消息接收对象（<code>self</code>引用的对象）</li>
<li>方法选择器（<code>_cmd</code>，调用的方法）</li>
</ul>
<p><code>objc_msgSend</code>找到方法实现后，会在调用该实现时，传入这两个隐藏参数，这样就能够在方法实现里面里面获取消息接受对象，即方法调用者了。<br><br><code>隐藏参数</code>表示这两个参数在源代码方法的定义中并没有声明这两个参数，这两个参数是在<code>代码编译期间</code>，被<code>插入</code>到实现中的。</p>
<h3 id="self和super的联系"><a href="#self和super的联系" class="headerlink" title="self和super的联系"></a>self和super的联系</h3><blockquote>
<p>2019.5.28 勘误，下面都是错的，self 从本类查找方法，super 从父类查找方法，最终因为 class 只有根类 NSObject 实现，所以都调用的 object_getClass(self)，最后的值也一样</p>
</blockquote>
<p>根据上文对<code>objc_msgSend</code>的了解，可以解决以下代码输出一致问题</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Dog</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)run</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="keyword">super</span> <span class="keyword">class</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        Dog *dog = [[Dog alloc] init];</span><br><span class="line"></span><br><span class="line">        [dog run];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">5491</span>:<span class="number">173185</span>] Dog</span><br><span class="line">[<span class="number">5491</span>:<span class="number">173185</span>] Dog</span><br></pre></td></tr></table></figure>
<p>这是为什么呢？先来看看编译后的<code>-run</code>方法的情况:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_Dog_run(Dog * <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_50_3f5nr6h10h1csn8byghy30q80000gn_T_main_d06ff4_mi_0, ((Class (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)<span class="keyword">self</span>, sel_registerName(<span class="string">"class"</span>)));</span><br><span class="line">    <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_50_3f5nr6h10h1csn8byghy30q80000gn_T_main_d06ff4_mi_1, ((Class (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123; (<span class="keyword">id</span>)<span class="keyword">self</span>, (<span class="keyword">id</span>)class_getSuperclass(objc_getClass(<span class="string">"Dog"</span>)) &#125;, sel_registerName(<span class="string">"class"</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面只要关注两句：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [self class]</span></span><br><span class="line">((Class (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)<span class="keyword">self</span>, sel_registerName(<span class="string">"class"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// [super class]</span></span><br><span class="line">((Class (*)(__rw_objc_super *, SEL))(<span class="keyword">void</span> *)objc_msgSendSuper)((__rw_objc_super)&#123; (<span class="keyword">id</span>)<span class="keyword">self</span>, (<span class="keyword">id</span>)class_getSuperclass(objc_getClass(<span class="string">"Dog"</span>)) &#125;, sel_registerName(<span class="string">"class"</span>))</span><br></pre></td></tr></table></figure>
<p>首先我们需要了解<code>self</code>和<code>super</code>的差异：</p>
<ul>
<li><code>super</code>：<code>编译标识符</code>，告诉编译器，调用方法时，去调用父类的方法，而不是本类的方法</li>
<li><code>self</code>：<code>隐藏参数</code>，每个方法的实现第一个参数就是<code>self</code></li>
</ul>
<p>这里可以看出，编译后，经过<code>super</code>标识符修饰的方法调用，会调用<code>objc_msgSendSuper</code>函数来进行消息的发送，而不是<code>objc_msgSend</code>。先来了解下<code>objc_msgSendSuper</code>的声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id objc_msgSendSuper ( struct objc_super *super, SEL op, ... );</span><br></pre></td></tr></table></figure>
<p>其中<code>objc_super</code>的定义为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// receiver   消息实际接收者</span><br><span class="line">// class      指向当前类的父类</span><br><span class="line">struct objc_super &#123; id receiver; Class class; &#125;;</span><br></pre></td></tr></table></figure>
<p>结合以上信息，我们可以知道：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(__rw_objc_super)&#123; (id)self, (id)class_getSuperclass(objc_getClass(&quot;Dog&quot;)) &#125;</span><br></pre></td></tr></table></figure>
<p>就是对结构体<code>objc_super</code>的赋值，也就是说<code>objc_super-&gt;receiver=self</code>。到这里可能就有点明了了，<code>super</code>只是告诉编译器，去查找父类中的<code>class</code>方法，当找到之后，使用<code>objc_super-&gt;receiver</code>即<code>self</code>进行调用。用流程表示就是：<br><br><code>[super class]-&gt;objc_msgSendSuper(objc_super{self, superclass)}, sel_registerName(&quot;class&quot;))-&gt;objc_msgSend(objc_super-&gt;self, sel_registerName(&quot;class&quot;))＝[self class]</code>。<br><br>可以看出两者输出结果一致的关键就是，<code>[self class]</code>的消息接收者和<code>[super class]</code>的消息接收者一样，都是调用方法的实例对象。</p>
<h3 id="方法解析和消息转发"><a href="#方法解析和消息转发" class="headerlink" title="方法解析和消息转发"></a>方法解析和消息转发</h3><p>当上文<code>objc_msgSend</code>处理流程中，<code>selector</code>没有找到时，会触发三个阶段，在这三个阶段都可以进行相关处理使程序不抛出异常：</p>
<ul>
<li>Method Resolution  (动态方法解析)</li>
<li>Fast Forwarding    (备用接收者)</li>
<li>Normal Forwarding  (完整转发)<br></li>
</ul>
<p>由于实际代码中很少有看到这种操作，所以这里不做详细解释，参考这个资料即可<a href="http://southpeak.github.io/blog/2014/11/03/objective-c-runtime-yun-xing-shi-zhi-san-:fang-fa-yu-xiao-xi-zhuan-fa/" target="_blank" rel="noopener">Objective-C Runtime 运行时之三：方法与消息</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://southpeak.github.io/blog/2014/10/25/objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang/" target="_blank" rel="noopener">Objective-C Runtime 运行时之一：类与对象</a><br><br><a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="noopener">Objective-C Runtime</a><br><br><a href="https://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" target="_blank" rel="noopener">What is a meta-class in Objective-C?</a><br></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Interview/" rel="tag"># Interview</a>
          
            <a href="/tags/objective-c/" rel="tag"># objective-c</a>
          
            <a href="/tags/runtime/" rel="tag"># runtime</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/06/29/2015-09-05-uiimagetu-pian-wu-xian-gun-dong-de-shi-xian/" rel="next" title="UIImage图片无限滚动的实现">
                <i class="fa fa-chevron-left"></i> UIImage图片无限滚动的实现
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2015/07/11/2015-08-27-runtimeying-yong-zhi-kvc/" rel="prev" title="Runtime应用之KVC">
                Runtime应用之KVC <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="tripleCC">
            
              <p class="site-author-name" itemprop="name">tripleCC</p>
              <p class="site-description motion-element" itemprop="description">ʕ•̫͡•ʔ-̫͡-ʕ•͓͡•ʔ-̫͡-ʕ•̫͡•ʔ-̫͡-ʕ•͓͡•ʔ-̫͡-ʔ</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">63</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/tripleCC" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.jianshu.com/u/97e39e95c2cc" target="_blank" title="简书">
                      
                        <i class="fa fa-fw fa-globe"></i>简书</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://twitter.com/tripleCCBrian" target="_blank" title="Twitter">
                      
                        <i class="fa fa-fw fa-twitter"></i>Twitter</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://stackoverflow.com/users/5187957/triplecc" target="_blank" title="StackOverflow">
                      
                        <i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:triplec.linux@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#runtime的基本要素"><span class="nav-number">1.</span> <span class="nav-text">runtime的基本要素</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#id"><span class="nav-number">1.1.</span> <span class="nav-text">id</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class"><span class="nav-number">1.2.</span> <span class="nav-text">Class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ivar"><span class="nav-number">1.3.</span> <span class="nav-text">Ivar</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Method"><span class="nav-number">1.4.</span> <span class="nav-text">Method</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SEL"><span class="nav-number">1.5.</span> <span class="nav-text">SEL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IMP"><span class="nav-number">1.6.</span> <span class="nav-text">IMP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息传递"><span class="nav-number">1.7.</span> <span class="nav-text">消息传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#self和super的联系"><span class="nav-number">1.8.</span> <span class="nav-text">self和super的联系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法解析和消息转发"><span class="nav-number">1.9.</span> <span class="nav-text">方法解析和消息转发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考"><span class="nav-number">1.10.</span> <span class="nav-text">参考</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tripleCC</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://tripleCC.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://triplecc.github.io/2015/07/10/2015-08-27-runtimeji-chu/';
          this.page.identifier = '2015/07/10/2015-08-27-runtimeji-chu/';
          this.page.title = 'runtime基础';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://tripleCC.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  

  

  

</body>
</html>

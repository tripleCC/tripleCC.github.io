
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>一次短暂的mac开发之旅 - tripleCC的技术博客</title>
  <meta name="author" content="tripleCC">

  
  <meta name="description" content="回杭近一周，发现公司后台写的接口文档还是比较清晰的。特别是自己组负责的业务线，接口文档上的字段和实际返回的字段几乎没有差别。 询问了周围小伙伴如何写模型文件之后，发现无非三种方式： 手写啦＝＝
Xcode8以前的用ESJsonFormat插件，Xcode8以后手写
用JSONExport生成 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://triplecc.github.io/blog/2016-10-22-yi-ci-duan-zan-de-mackai-fa-zhi-lu/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="tripleCC的技术博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://libs.useso.com/js/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.useso.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.useso.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">tripleCC的技术博客</a></h1>
  
    <h2>日拱一卒</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.baidu.com" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="triplecc.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">所有文章</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">一次短暂的mac开发之旅</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-10-22T22:43:37+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2016</span></span> <span class='time'>10:43 pm</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>回杭近一周，发现公司后台写的接口文档还是比较清晰的。特别是自己组负责的业务线，接口文档上的字段和实际返回的字段几乎没有差别。</p>

<p>询问了周围小伙伴如何写模型文件之后，发现无非三种方式：</p>

<ul>
<li>手写啦＝＝</li>
<li><code>Xcode8</code>以前的用<code>ESJsonFormat</code>插件，<code>Xcode8</code>以后手写</li>
<li>用<code>JSONExport</code>生成</li>
</ul>


<p>针对以上三种方式，我做了一个简短的分析：</p>

<ul>
<li>这个不用说了，耗时费力不讨好。量少好说，量大就比较蛋疼了。</li>
<li><code>xcode8</code>之后，第三方插件被禁止了。虽说有方法能让<code>xcode8</code>重新用上这个插件，但是即使用上了这个插件，还是需要自己写注释，并且生成模型需要后台返回的<code>json</code>。</li>
<li>和上一个方式一样，只是从插件编程了<code>mac</code>软件</li>
</ul>


<p>在打听完后，我随即产生了自己写一个转换工具的想法。</p>

<p>原因如下：</p>

<ul>
<li>后台文档已经写的比较清晰，可以从网页上把这些数据都爬下来，然后生成含有注释的模型</li>
<li>可以自动将<code>Vo</code>结尾的模型和属性，转成<code>Model</code>结尾的模型和属性，并且生成<code>YYModel</code>需要的映射关系</li>
<li>因为接口文档都处于一个统一的<code>baseURL</code>下，加上模型名称就是完整路径，所以可以很方便地进行批量处理</li>
<li>不需要测试后台发布的接口后，再通过获取接口返回的<code>json</code>生成模型；只要接口文档一发布就可以生成模型</li>
</ul>


<!--more-->


<p>然后我花了一个周末的时间，完成了一个简易的模型抓取生成工具。具体界面如下：<br></p>

<p><img src="/images/2016-10-30fetcher.png" alt="" /></p>

<p>输入浏览公司内部资料所需要的用户名和密码，并且输入自己需要的抓取的模型名，点击开始抓取，然后就等桌面上生成对应的模型文件了。当然，在界面上的预览窗口可以看到生成文件的内容，以及生成文件的保存地址。</p>

<p>话不多说，接下来记录下自己写这个<code>mac</code>工具的过程。</p>

<h3>确认要抓取的内容及条件</h3>

<p>首先摘一个接口的文档：<br></p>

<p><img src="/images/2016-10-30.png" alt="" /></p>

<p>总结两点：</p>

<ul>
<li>需要的数据有数字编号或者没有编号（也可以说从第二行开始＝＝）</li>
<li>需要的数据在表格的2、3、4行（对应1、2、3索引）</li>
</ul>


<p>接下来再看下需要抓取内容的HTML:<br></p>

<p><img src="/images/2016-10-30xpath.png" alt="" /></p>

<p>可以看到，拿到第一个标签为<code>table</code>、类名为<code>confluenceTable</code>的元素，然后再取第一个标签为<code>tbody</code>的元素即可获取所有需要的数据。</p>

<p>最后，查看接口需要在登录状态，所以得在<code>chrome</code>的开发者工具中获取登录请求的<code>URL</code>和参数。由于接口文档所在服务器搭在公司内网，所以并没有太过复杂的验证，还是比较方便的。</p>

<h3>确定使用的技术</h3>

<p>由于对<code>Python</code>不是很熟悉，所以还是先使用<code>swift</code>来写。选用的框架如下：</p>

<ul>
<li>RxSwift</li>
<li>Ji (HTML解析用)</li>
<li>Moya</li>
</ul>


<p>最后说下<code>mac</code>开发，我直接采用了<code>storyboard</code>的方式。主要是自己以前没有接触过<code>mac</code>开发，使用IB能降低难度和开发时间。</p>

<h3>实际开发过程</h3>

<p>数据获取解析和软件界面逻辑编写的时间占比大概在7-3左右。<br></p>

<h5>数据获取解析</h5>

<p> 通过<code>Moya</code>请求获取<code>HTML</code>就不说了，主要记录下如何使用<code>Ji</code>来解析<code>HTML</code>。</p>

<p> 获取第一个标签为<code>table</code>、类名为<code>confluenceTable</code>的元素代码如下：</p>

<p> ```swift
 extension TDFInterfaceFetcherHTMLParser  {
    var firstTableBody: [JiNode]? {
        return firstContentTable.flatMap{ $0.firstChildWithName(&ldquo;tbody&rdquo;)?.children }
    }</p>

<pre><code>private var firstContentTable: JiNode?{
    let lastTable = rootNode?
        .descendantsWithName("table")
        .filter{ $0.attributes["class"] == "confluenceTable" }
        .first
    return lastTable
}
</code></pre>

<p>}</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> 
</span><span class='line'>- `descendantsWithName("table")`可以获取所有标签为`table`的元素
</span><span class='line'>- `JiNode`的`attributes`是标签所有属性的键值对，这里过滤掉`class`不是`confluenceTable`的`JiNode`
</span><span class='line'>- `JiNode`的`firstChildWithName("tbody").children`可以获取子节点中，第一个标签为`tbody`的元素的所有子节点。
</span><span class='line'>
</span><span class='line'>得到所有目标子节点后，再通过以下方法获取叶子节点：
</span></code></pre></td></tr></table></div></figure>


<p>swift
//1、是叶子节点，添加到数组
//2、不是叶子节点，遍历其所有子节点</p>

<p>extension JiNode {
    func allLeafNodes() -> [JiNode] {
        var leafNodes = <a href="">JiNode</a>
        if !hasChildren {
            leafNodes.append(self)
        } else {
            children.forEach {
                leafNodes.append(contentsOf: $0.allLeafNodes())
            }
        }
        return leafNodes
    }
}</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>接下来通过`JiNode`的`value`属性获取所有叶子节点对应元素的内容就好了：
</span></code></pre></td></tr></table></div></figure>


<p>swift
firstTableBody.map{ $0.allLeafNodes().flatMap{ $0.value } }</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>经过上面代码的处理，输出的数据如下：
</span></code></pre></td></tr></table></div></figure>


<p>[&ldquo;编号&rdquo;, &ldquo;参数名（中文）&rdquo;, &ldquo;参数名（英文）&rdquo;, &ldquo;类型&rdquo;, &ldquo;对应表&rdquo;, &ldquo;对应字段&rdquo;, &ldquo;备注&rdquo;]
[&ldquo;1&rdquo;, &ldquo;采购单ID&rdquo;, &ldquo;id&rdquo;, &ldquo;String&rdquo;, &ldquo;purchase_info&rdquo;, &ldquo;id&rdquo;, &ldquo;　&rdquo;]
[&ldquo;2&rdquo;, &ldquo;所属实体ID&rdquo;, &ldquo;entityId&rdquo;, &ldquo;String&rdquo;, &ldquo;purchase_info&rdquo;, &ldquo;entity_id&rdquo;, &ldquo;　&rdquo;]
[&ldquo;3&rdquo;, &ldquo;自实体ID&rdquo;, &ldquo;selfEntityId&rdquo;, &ldquo;String&rdquo;, &ldquo;purchase_info&rdquo;, &ldquo;self_entity_id&rdquo;, &ldquo;　&rdquo;]
[&ldquo;4&rdquo;, &ldquo;自实体名称&rdquo;, &ldquo;selfEntityName&rdquo;, &ldquo;String&rdquo;, &ldquo;　&rdquo;, &ldquo;　&rdquo;, &ldquo;　&rdquo;]
[&ldquo;5&rdquo;, &ldquo;供应商Id&rdquo;, &ldquo;supplyId&rdquo;, &ldquo;String&rdquo;, &ldquo;purchase_info&rdquo;, &ldquo;supply_id&rdquo;, &ldquo;　&rdquo;]
[&ldquo;6&rdquo;, &ldquo;供应商名称&rdquo;, &ldquo;supplyName&rdquo;, &ldquo;String&rdquo;, &ldquo;supply&rdquo;, &ldquo;name&rdquo;, &ldquo;　&rdquo;]
[&ldquo;7&rdquo;, &ldquo;仓库Id&rdquo;, &ldquo;warehouseId&rdquo;, &ldquo;String&rdquo;, &ldquo;purchase_info&rdquo;, &ldquo;warehouse_id&rdquo;, &ldquo;　&rdquo;]
[&ldquo;8&rdquo;, &ldquo;仓库名称&rdquo;, &ldquo;warehouseName&rdquo;, &ldquo;String&rdquo;, &ldquo;warehouse&rdquo;, &ldquo;name&rdquo;, &ldquo;　&rdquo;]
[&ldquo;9&rdquo;, &ldquo;单号&rdquo;, &ldquo;no&rdquo;, &ldquo;String&rdquo;, &ldquo;purchase_info&rdquo;, &ldquo;no&rdquo;, &ldquo;　&rdquo;]</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>OK！后面的事情就相对简单了，主要是结合`Objective-C`的语法以及自身采用的`JSON`转模型框架来对上面的数组进行加工。项目里采用的是YYModel，所以最终输出结果大致如下：
</span></code></pre></td></tr></table></div></figure>


<p>objc
//======================================  <br/>
// TDFPurchaseModel.h <br/>
//======================================</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<p>@interface TDFPurchaseModel : NSObject<br/>
/<strong> 采购单ID <em>/<br/>
@property (nonatomic, copy) NSString </em>id; <br/>
/</strong> 所属实体ID <em>/ <br/>
@property (nonatomic, copy) NSString </em>entityId;
/<strong> 自实体ID <em>/<br/>
@property (nonatomic, copy) NSString </em>selfEntityId;
/</strong> 自实体名称 <em>/<br/>
@property (nonatomic, copy) NSString </em>selfEntityName; <br/>
/<em><em> 供应商Id </em>/<br/>
@property (nonatomic, copy) NSString </em>supplyId;
&hellip;&hellip;</p>

<p>//======================================  <br/>
// TDFPurchaseModel.m <br/>
//======================================</p>

<h1>import &ldquo;TDFPurchaseModel.h&rdquo;</h1>

<p>@implementation TDFPurchaseModel  <br/>
+ (nullable NSDictionary<NSString *, id> *)modelCustomPropertyMapper {<br/>
    return @{ <br/>
        @&ldquo;purchaseDetails&rdquo; : @&ldquo;purchaseDetailsVo&rdquo; <br/>
    };<br/>
} <br/>
@end</p>

<p>```</p>

<h5>软件界面逻辑编写</h5>

<p><code>mac</code>界面的搭建，我主要参考了<code>JSONExport</code>。不过对于没有接触过<code>mac</code>开发的我来说，直接上手去拖拽控件还是出现了一些问题。</p>

<p>记忆最深的是在<code>mac</code>开发中，拖拽到<code>storyboard</code>中的控件，其内部可能内置多个子控件。当我直接以<code>iOS</code>开发在<code>storyboard</code>中拖拽控件的方式设置约束时，就会出现一些问题：</p>

<p><img src="/images/Snip20161030_1.png" alt="" /></p>

<p>这样的约束是针对内部的<code>NSTextView</code>设置的，当输入文本超过父控件时，依赖于<code>NSTextView</code>高度约束的控件会发生变化。所以应该像下面这样，在侧边栏设置：</p>

<p><img src="/images/Snip20161030_3.png" alt="" /></p>

<p>至于其它，由于只是搭了一个简单的界面，也不好说些啥。不过现在感觉做<code>iOS</code>开发的，上手<code>mac</code>开发还是相对容易一些。</p>

<p>最后挂下抓取结果图：</p>

<p><img src="/images/2016-10-30result.png" alt="" /></p>

<h3>总结</h3>

<p>写这个软件大概花了我一天半的时间，不过应该能给身边的小伙伴省下一些不必要的时间开销，还是挺高兴的。<br></p>

<p>感觉程序员还是要多思考，不过是对代码还是对业务流程。不能说以前的人这么写，或者这么做了，我就跟着这么做，而不加以思考这样的代码或者流程到底合不合理，是不是正确/最优的做法，否则很难跳出自己的舒适区域。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">tripleCC</span></span>

      




<time class='entry-date' datetime='2016-10-22T22:43:37+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2016</span></span> <span class='time'>10:43 pm</span></time>
      


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2016-10-15-shi-yong-rxswift-plus-moya-plus-objectmapperjie-ru-mo-xing/" title="Previous Post: 使用RxSwift+Moya+ObjectMapper接入模型">&laquo; 使用RxSwift+Moya+ObjectMapper接入模型</a>
      
      
        <a class="basic-alignment right" href="/blog/2016-11-12-objective-cshi-yong-fan-xing-shi-xian-mapti-shi/" title="Next Post: Objective-C使用范型实现map提示">Objective-C使用范型实现map提示 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>关于我</h1>
  <p> 喜欢技术，喜欢Ubuntu，喜欢字符终端，热衷底层，涉略微处理器、Linux，最终加入移动大家庭 </p>
  <a href="http://www.jianshu.com/users/97e39e95c2cc" style="color: coral"> 访问我的简书 </a><br>
  <a href="https://github.com/tripleCC" style="color: coral"> 访问我的github </a><br>
  <a href="https://twitter.com/tripleCCBrian" style="color: coral"> 我的twitter </a>
</section>
<section>
  <h1>最近发布</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016-11-13-guo-wai-ioskai-fa-zhe-de-bo-ke/">国外iOS开发者的博客</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016-11-12-objective-cshi-yong-fan-xing-shi-xian-mapti-shi/">Objective-C使用范型实现map提示</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016-10-22-yi-ci-duan-zan-de-mackai-fa-zhi-lu/">一次短暂的mac开发之旅</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016-10-15-shi-yong-rxswift-plus-moya-plus-objectmapperjie-ru-mo-xing/">使用RxSwift+Moya+ObjectMapper接入模型</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016-10-06-rxswiftzhong-usingde-ying-yong/">ReactiveX中Using操作的应用</a>
      </li>
    
  </ul>
</section>




<section>
    <h1>友情链接</h1>
    <ul>
        <li>
            <a href="http://wxgbridgeq.github.io/">小乔的个人学习博客</a>
        </li>
    </ul>
</section>
  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - tripleCC -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>

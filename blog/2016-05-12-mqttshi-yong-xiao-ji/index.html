
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>MQTT使用小记 - tripleCC的技术博客</title>
  <meta name="author" content="tripleCC">

  
  <meta name="description" content="MQTT全称Message Queue Telemetry Transport，是一个针对轻量级的发布/订阅式消息传输场景的协议，同时也是被推崇的物联网传输协议。MQTT详细的介绍文章可以从官方网站获得，所以这里就不进行详细的展开了，而是针对这些天的使用经历与感受做一番纪录。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://triplecc.github.io/blog/2016-05-12-mqttshi-yong-xiao-ji/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="tripleCC的技术博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://libs.useso.com/js/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.useso.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.useso.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">tripleCC的技术博客</a></h1>
  
    <h2>日拱一卒</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.baidu.com" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="triplecc.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">所有文章</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">MQTT使用小记</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-05-12T17:12:43+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>12</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>5:12 pm</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>MQTT全称Message Queue Telemetry Transport，是一个针对轻量级的发布/订阅式消息传输场景的协议，同时也是被推崇的物联网传输协议。MQTT详细的介绍文章可以从<a href="http://mqtt.org/">官方网站</a>获得，所以这里就不进行详细的展开了，而是针对这些天的使用经历与感受做一番纪录。</p>

<p>MQTT开源的iOS客户端有以下几种：</p>

<table>
<thead>
<tr>
<th>MQTTKit  </th>
<th>Marquette</th>
<th>Moscapsule</th>
<th>Musqueteer</th>
<th>MQTT-Client</th>
<th>MqttSDK</th>
<th>CocoaMQTT</th>
</tr>
</thead>
<tbody>
<tr>
<td>Obj-C    </td>
<td>Obj-C    </td>
<td>Swift     </td>
<td>Obj-C     </td>
<td>Obj-C      </td>
<td>Obj-C  </td>
<td>Swift    </td>
</tr>
<tr>
<td>Mosquitto</td>
<td>Mosquitto</td>
<td>Mosquitto </td>
<td>Mosquitto </td>
<td>native     </td>
<td>native </td>
<td>native   </td>
</tr>
</tbody>
</table>


<p>以上开源库我只看过部分MQTTKit、MQTT-Client、CocoaMQTT的开源代码，总体来说MQTT-Client支持的功能更多全面一些。如果只是对协议本身进行学习不考虑功能的话，可以阅读CocoaMQTT，也可以阅读我重写的<a href="https://github.com/tripleCC/SwiftMQTT">SwiftMQTT</a>，因为代码量相对前面两个库少了很多。</p>

<p>而MQTT的broker一般选择<a href="http://mosquitto.org/">Mosquitto</a>，Mosquitto是一个由C编写的集客户端和服务端为一体的开源项目，所以相对来说风格较为友好，可以无障碍地阅读并调试源码（<a href="https://github.com/eclipse/mosquitto">开源地址</a>）。可以看到，以上客户端开源库中的前四种就是基于Mosquitto的一层封装。</p>

<!--more-->


<h4>Mosquitto的安装和使用</h4>

<p>Mosquitto在Linux下的安装相对比Mac-OS简单很多，主要是因为openssl的一些路径问题，后者需要多一些步骤。Mac-OS下可以通过两种方法运行Mosquitto，一种是通过brew命令安装Mosquitto:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>brew install mosquitto</span></code></pre></td></tr></table></div></figure>


<p>安装完成后就可以在mosquitto.conf文件中更改相应的配置了。接着进入根目录（也可以指定$PATH到mosquitto可执行文件的目录），执行以下命令运行mosquitto：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// -c 读取配置
</span><span class='line'>// -d 后台运行
</span><span class='line'>// -v 打印详细日志
</span><span class='line'>./sbin/mosquitto -c etc/mosquitto/mosquitto.conf -d -v</span></code></pre></td></tr></table></div></figure>


<p>如果要重启mosquitto服务，可以先kill掉，再重启：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tripleCC:1.4.8 songruiwang$ ps -A | grep mosquitto
</span><span class='line'>55417 ??         0:00.05 ./sbin/mosquitto -c etc/mosquitto/mosquitto.conf -d -v
</span><span class='line'>tripleCC:1.4.8 songruiwang$ kill -9 55417</span></code></pre></td></tr></table></div></figure>


<p>现在要说明的是第二种方式，通过源码编译生成mosquitto可执行文件（好处是可以通过lldb对mosquitto进行调试，能更好地熟悉运行机制）。</p>

<p>下载mosquitto源码后进入根目录，然后执行以下命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 禁用TLS_PSK，并且声称Debug版本（后续lldb调试需要用到符号表）
</span><span class='line'>// 如果openssl是通过brew进行安装，就需要手动指定OPENSSL_ROOT_DIR和OPENSSL_INCLUDE_DIR环境变量
</span><span class='line'>// 但是后来发现即使指定了，在编译时符号表中还是找不到TLS_PSK相关的函数
</span><span class='line'>cmake -DWITH_TLS_PSK=OFF -DWITH_TLS=OFF -DCMAKE_BUILD_TYPE=Debug 
</span><span class='line'>make install</span></code></pre></td></tr></table></div></figure>


<p>终端会提示无法拷贝可执行文件mosquitto，这个问题无伤大雅。可以手动拷贝到$PATH指定的目录下，也可以直接进入mosquitto所在目录运行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>tripleCC:src songruiwang$ lldb mosquitto
</span><span class='line'>(lldb) target create "mosquitto"
</span><span class='line'>Current executable set to 'mosquitto' (x86_64).
</span><span class='line'>(lldb) b mqtt3_packet_handle
</span><span class='line'>Breakpoint 1: where = mosquitto`mqtt3_packet_handle + 16 at read_handle.c:36, address = 0x0000000100018eb0
</span><span class='line'>(lldb) r</span></code></pre></td></tr></table></div></figure>


<p>这样当客户端连接到broker时，就可以对mosquitto进行逐行调试了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Process 57680 launched: '/Users/songruiwang/Desktop/mosquitto/src/mosquitto' (x86_64)
</span><span class='line'>1463049645: mosquitto version 1.4.8 (build date 2016-05-12 18:36:15+0800) starting
</span><span class='line'>1463049645: Using default config.
</span><span class='line'>1463049645: Opening ipv4 listen socket on port 1883.
</span><span class='line'>1463049645: Opening ipv6 listen socket on port 1883.
</span><span class='line'>1463049659: New connection from 127.0.0.1 on port 1883.
</span><span class='line'>Process 57680 stopped
</span><span class='line'>* thread #1: tid = 0xba449, 0x0000000100018eb0 mosquitto`mqtt3_packet_handle(db=0x000000010002f4f0, context=0x0000000100201990) + 16 at read_handle.c:36, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1
</span><span class='line'>    frame #0: 0x0000000100018eb0 mosquitto`mqtt3_packet_handle(db=0x000000010002f4f0, context=0x0000000100201990) + 16 at read_handle.c:36
</span><span class='line'>   33     
</span><span class='line'>   34     int mqtt3_packet_handle(struct mosquitto_db *db, struct mosquitto *context)
</span><span class='line'>   35     {
</span><span class='line'>-&gt; 36          if(!context) return MOSQ_ERR_INVAL;
</span><span class='line'>   37     
</span><span class='line'>   38         switch((context-&gt;in_packet.command)&0xF0){
</span><span class='line'>   39             case PINGREQ:
</span><span class='line'>(lldb) p *context
</span><span class='line'>(mosquitto) $0 = {
</span><span class='line'>  sock = 6
</span><span class='line'>  protocol = mosq_p_invalid
</span><span class='line'>  address = 0x0000000100200db0 "127.0.0.1"
</span><span class='line'>  id = 0x0000000000000000 &lt;no value available&gt;
</span><span class='line'>  username = 0x0000000000000000 &lt;no value available&gt;
</span><span class='line'>  password = 0x0000000000000000 &lt;no value available&gt;
</span><span class='line'>  keepalive = 60
</span><span class='line'>  last_mid = 0
</span><span class='line'>  state = mosq_cs_new
</span><span class='line'>  last_msg_in = 39584
</span><span class='line'>  last_msg_out = 39584
</span><span class='line'>  ......</span></code></pre></td></tr></table></div></figure>


<p>这里安利一款代码阅读器Understand（和window下的SourceInsight很相似，都很强大！）<br>
lldb很多命令和gdb相似，具体更多命令可以在lldb中执行help进行查看。
更加详细的使用教程可以参考<a href="http://blog.csdn.net/shagoo/article/details/7910598">Mosquitto简要教程（安装/使用/测试）</a></p>

<h4>使用Wireshark抓取报文</h4>

<p>测试时使用的host一般为lo0，即本地回环地址，所以选择对应的过滤器：</p>

<p><img src="/images/Snip20160512_2.png" alt="" /></p>

<p>对端口进行过滤（这里使用的是1883端口）：</p>

<p><img src="/images/Snip20160512_3.png" alt="" /></p>

<p>然后连接客户端和服务端，就可以看见对应的MQTT报文了：</p>

<p><img src="/images/Snip20160512_4.png" alt="" /></p>

<p>在一些linux嵌入式环境下，无法通过Wireshark抓取报文，可以使用tcpdump抓取生成pcap文件，然后使用ftp等协议将文件传回到电脑，再使用Wireshark打开：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// 这里还是用回环地址举例
</span><span class='line'>tcpdump -i lo0 'tcp port 1883' -s 65535 -w packet.pcap</span></code></pre></td></tr></table></div></figure>


<h4>MQTT协议的实践</h4>

<h5>MQTT协议消息类型</h5>

<p>为了能够更好地熟悉协议，我用struct+protocol的方式重写了CocoaMQTT的代码（<a href="https://github.com/tripleCC/SwiftMQTT">SwiftMQTT</a>）。CocoaMQTT库使用的是传统的面相对象编程方式，所以阅读起来并没有什么障碍，只不过小小吐槽下代码风格。<br></p>

<p>MQTT协议总共有14种消息类型，使用枚举表示如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public enum SwiftMQTTMessageType : UInt8 {
</span><span class='line'>    case Connect        = 0x10
</span><span class='line'>    case ConnAck        = 0x20
</span><span class='line'>    case Publish        = 0x30
</span><span class='line'>    case PubAck         = 0x40
</span><span class='line'>    case PubRec         = 0x50
</span><span class='line'>    case PubRel         = 0x60
</span><span class='line'>    case PubComp        = 0x70
</span><span class='line'>    case Subscribe      = 0x80
</span><span class='line'>    case SubAck         = 0x90
</span><span class='line'>    case Unsubscribe    = 0xA0
</span><span class='line'>    case UnsubBack      = 0xB0
</span><span class='line'>    case PingReq        = 0xC0
</span><span class='line'>    case PingResp       = 0xD0
</span><span class='line'>    case Disconnect     = 0xE0
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>以上消息可由"固定报头"+&ldquo;可变报头&rdquo;+&ldquo;有效载荷"三部分组成。<br></p>

<p>固定报头由"类型+标志位"+&ldquo;剩余长度"组成，可以使用protocol表示第一部分：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public protocol SwiftMQTTCommandProtocol {
</span><span class='line'>    var command: UInt8 {get set}
</span><span class='line'>    var messageType: SwiftMQTTMessageType {get set}
</span><span class='line'>    var dupFlag: Bool {get set}
</span><span class='line'>    var qosLevel: SwiftMQTTQosLevel {get set}
</span><span class='line'>    var retain: Bool {get set}
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>extension SwiftMQTTCommandProtocol {
</span><span class='line'>    /**
</span><span class='line'>     * +---------------+----------+-----------+--------+
</span><span class='line'>     * |    7 6 5 4    |     3    |    2 1    |   0    |
</span><span class='line'>     * |  Message Type | DUP flag | QoS level | RETAIN |
</span><span class='line'>     * +---------------+----------+-----------+--------+
</span><span class='line'>     */
</span><span class='line'>    public var messageType: SwiftMQTTMessageType {
</span><span class='line'>        get { return SwiftMQTTMessageType(rawValue: command & 0xF0) ?? .Connect }
</span><span class='line'>        set { command = newValue.rawValue | (command & 0x0F) }
</span><span class='line'>    }
</span><span class='line'>    public var dupFlag: Bool {
</span><span class='line'>        get { return Bool((command &gt;&gt; 3) & 0x01) }
</span><span class='line'>        set { command = (UInt8(newValue) &lt;&lt; 3) | (command & 0xF7) }
</span><span class='line'>    }
</span><span class='line'>    public var qosLevel: SwiftMQTTQosLevel {
</span><span class='line'>        get { return SwiftMQTTQosLevel(rawValue: (command &gt;&gt; 1) & 0x03) ?? .AtMostOnce }
</span><span class='line'>        set { command = newValue.rawValue &lt;&lt; 1 | (command & 0xF9 ) }
</span><span class='line'>    }
</span><span class='line'>    public var retain: Bool {
</span><span class='line'>        get { return Bool(command & 0x01) }
</span><span class='line'>        set { command = UInt8(newValue) | (command & 0xFE) }
</span><span class='line'>    }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>剩余长度等于"可变报头"+&ldquo;有效载荷"各自的长度相加，这两者表示如下:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public protocol SwiftMQTTVariableHeaderProtocol {
</span><span class='line'>     var variableHeader: NSData {get}
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>extension SwiftMQTTVariableHeaderProtocol {
</span><span class='line'>    public var variableHeader: NSData { return NSData() }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public protocol SwiftMQTTPayloadProtocol {
</span><span class='line'>    var payload: NSData {get}
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>extension SwiftMQTTPayloadProtocol {
</span><span class='line'>    public var payload: NSData { return NSData() }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>为了减少没有这两个部分的消息结构体的代码量，所以协议扩展中先返回空数据。<br>
然后就可以定义并实现一个固定报头的总协议了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public protocol SwiftMQTTFixedHeaderProtocol : SwiftMQTTCommandProtocol, SwiftMQTTVariableHeaderProtocol, SwiftMQTTPayloadProtocol {
</span><span class='line'>    var remainingLength: UInt32 {get}
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>extension SwiftMQTTFixedHeaderProtocol {
</span><span class='line'>    public var remainingLength: UInt32 {
</span><span class='line'>        let remainingLength = variableHeader.length + payload.length
</span><span class='line'>        guard remainingLength &lt;= kSwiftMQTTMaxRemainingLength else {
</span><span class='line'>            SMPrint("the size of remaining length field should be below \(kSwiftMQTTMaxRemainingLength).")
</span><span class='line'>            return UInt32(kSwiftMQTTMaxRemainingLength)
</span><span class='line'>        }
</span><span class='line'>        return UInt32(remainingLength)
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>有了所有发送消息的组成部分之后，就可以对数据进行编码了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public protocol SwiftMQTTMessageProtocol : SwiftMQTTFixedHeaderProtocol {
</span><span class='line'>    var data: NSData {get}
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>extension SwiftMQTTMessageProtocol {
</span><span class='line'>    public var data: NSData {
</span><span class='line'>        let data = NSMutableData()
</span><span class='line'>        data.appendByte(command)
</span><span class='line'>        data.appendData(remainingLength.data)
</span><span class='line'>        data.appendData(variableHeader)
</span><span class='line'>        data.appendData(payload)
</span><span class='line'>        return data
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里以Connect报文为例，结合以上协议，构成一个有效的消息结构体。<br>
首先让SwiftMQTTConnectMessage遵守SwiftMQTTMessageProtocol协议，以此获得固定报头解析以及编码等能力：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public struct SwiftMQTTConnectMessage : SwiftMQTTMessageProtocol {
</span><span class='line'>  public var command = UInt8(0x00)
</span><span class='line'>  ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>由于command是固定报头类型和标志的必要载体，所以必须在结构体中实现。那么问题来了，MQTT协议的消息有14种，于是就需要在14种结构体种都实现一次这个成员变量，如果使用面向对象的方式，在公共子类中呈现这个成员变量就行了。这里是第一个让我感觉面向协议方式在实现MQTT不顺手的地方。<br>
Connect报文的可变报头中分为四个部分:协议名，协议级别，连接标志和保持连接。这几个部分可以使用两个协议来实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public protocol SwiftMQTTConnectFlagProtocol {
</span><span class='line'>    var connectFlag: UInt8 {get set}
</span><span class='line'>    var usernameFlag: Bool {get set}
</span><span class='line'>    var passwordFlag: Bool {get set}
</span><span class='line'>    var willRetain: Bool {get set}
</span><span class='line'>    var willQos: SwiftMQTTQosLevel {get set}
</span><span class='line'>    var willFlag: Bool {get set}
</span><span class='line'>    var cleanSession: Bool {get set}
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>extension SwiftMQTTConnectFlagProtocol {
</span><span class='line'>    /**
</span><span class='line'>     * +----------+----------+------------+---------+----------+--------------+----------+
</span><span class='line'>     * |     7    |    6     |      5     |  4  3   |     2    |       1      |     0    |
</span><span class='line'>     * | username | password | willretain | willqos | willflag | cleansession | reserved |
</span><span class='line'>     * +----------+----------+------------+---------+----------+--------------+----------+
</span><span class='line'>     */
</span><span class='line'>    public var usernameFlag: Bool {
</span><span class='line'>        get { return Bool((connectFlag & 0x80) &gt;&gt; 7) }
</span><span class='line'>        set { connectFlag = (UInt8(newValue) &lt;&lt; 7) | (connectFlag & 0x7F) }
</span><span class='line'>    }
</span><span class='line'>    public var passwordFlag: Bool {
</span><span class='line'>        get { return Bool((connectFlag & 0x40) &gt;&gt; 6) }
</span><span class='line'>        set { connectFlag = (UInt8(newValue) &lt;&lt; 6) | (connectFlag & 0xBF) }
</span><span class='line'>    }
</span><span class='line'>    public var willRetain: Bool {
</span><span class='line'>        get { return Bool((connectFlag & 0x20) &gt;&gt; 5) }
</span><span class='line'>        set { connectFlag = (UInt8(newValue) &lt;&lt; 5) | (connectFlag & 0xDF) }
</span><span class='line'>    }
</span><span class='line'>    public var willQos: SwiftMQTTQosLevel {
</span><span class='line'>        get { return SwiftMQTTQosLevel(rawValue: (connectFlag & 0x18) &gt;&gt; 3) ?? .AtMostOnce }
</span><span class='line'>        set { connectFlag = (UInt8(newValue.rawValue) &lt;&lt; 3) | (connectFlag & 0xE7) }
</span><span class='line'>    }
</span><span class='line'>    public var willFlag: Bool {
</span><span class='line'>        get { return Bool((connectFlag & 0x08) &gt;&gt; 2) }
</span><span class='line'>        set { connectFlag = (UInt8(newValue) &lt;&lt; 2) | (connectFlag & 0xFA) }
</span><span class='line'>    }
</span><span class='line'>    public var cleanSession: Bool {
</span><span class='line'>        get { return Bool((connectFlag & 0x04) &gt;&gt; 1) }
</span><span class='line'>        set { connectFlag = (UInt8(newValue) &lt;&lt; 1) | (connectFlag & 0xFD) }
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>protocol SwiftMQTTClientProtocol {
</span><span class='line'>    var protocolName: String {get}
</span><span class='line'>    var protocolLevel: UInt8 {get}
</span><span class='line'>    var keepalive: UInt16 {get}
</span><span class='line'>    var clientId: String {get}
</span><span class='line'>    var account: SwiftMQTTAccount? {get}
</span><span class='line'>    var will: SwiftMQTTWill? {get}
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>extension SwiftMQTTClientProtocol {
</span><span class='line'>    var protocolName: String { return "MQTT" }
</span><span class='line'>    var protocolLevel: UInt8 { return 0x04 }
</span><span class='line'>    var keepalive: UInt16 { return 60 }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这样Connect报文结构体已经有了所有需要的协议，接下来主要的工作就是实现真正的variableHeader和payload了：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public var variableHeader: NSData {
</span><span class='line'>    let variableHeader = NSMutableData()
</span><span class='line'>    variableHeader.appendMQTTString(protocolName)
</span><span class='line'>    variableHeader.appendByte(protocolLevel)
</span><span class='line'>    variableHeader.appendByte(connectFlag)
</span><span class='line'>    variableHeader.appendUInt16(keepalive)
</span><span class='line'>    return variableHeader
</span><span class='line'>}
</span><span class='line'>public var payload: NSData {
</span><span class='line'>    let payload = NSMutableData()
</span><span class='line'>    // 客户端标识符-&gt;遗嘱主题-&gt;遗嘱消息-&gt;用户名-&gt;密码
</span><span class='line'>    payload.appendMQTTString(clientId)
</span><span class='line'>    if let willTopic = will?.willTopic {
</span><span class='line'>        payload.appendMQTTString(willTopic)
</span><span class='line'>    }
</span><span class='line'>    if let willMessage = will?.willMessage {
</span><span class='line'>        payload.appendMQTTString(willMessage)
</span><span class='line'>    }
</span><span class='line'>    if let username = account?.username {
</span><span class='line'>        payload.appendMQTTString(username)
</span><span class='line'>    }
</span><span class='line'>    if let password = account?.password {
</span><span class='line'>        payload.appendMQTTString(password)
</span><span class='line'>    }
</span><span class='line'>    return payload
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>至此，Connect的主要部分都已经构建完成。接下来以ConAck报文为例，实现从broker中返回的报文。<br>
由于需要解析从broker中返回的报文，所以定义一个返回消息类型协议：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public protocol SwiftMQTTAckMessageProtocol: SwiftMQTTCommandProtocol {
</span><span class='line'>    init?(_ bytes: [UInt8], command: UInt8)
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>最终SwiftMQTTConnAckMessage结构体如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public struct SwiftMQTTConnAckMessage : SwiftMQTTAckMessageProtocol {
</span><span class='line'>    public var command = UInt8(0x00)
</span><span class='line'>    public var sessionPresent: Bool
</span><span class='line'>    public var connectReturnCode: SwiftMQTTConnectReturnCode
</span><span class='line'>    public init?(_ bytes: [UInt8], command: UInt8) {
</span><span class='line'>        guard bytes.count == 2 else { return nil }
</span><span class='line'>        sessionPresent = Bool(bytes[0])
</span><span class='line'>        connectReturnCode = SwiftMQTTConnectReturnCode(rawValue: bytes[1]) ?? .Accepted
</span><span class='line'>        self.command = command
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>这里又产生了第二个让我不是很舒服的地方：在protocol extension中实现有效的init非常麻烦（暂且不论在protocol extension中实现init的必要性）。下面是一个不完全的实现方式：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>protocol MessageProtocol {
</span><span class='line'>    var messageId : UInt16 { get set }
</span><span class='line'>    init()
</span><span class='line'>    init?(_ bytes: [UInt8])
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>extension Message {
</span><span class='line'>    init?(_ bytes: [UInt8]) {
</span><span class='line'>        guard bytes.count == 2 else { return nil }
</span><span class='line'>        messageId = UInt16(bytes[0]) &lt;&lt; 8 + UInt16(bytes[1])
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>struct Message: MessageProtocol {
</span><span class='line'>    var messageId: UInt16
</span><span class='line'>    init() {
</span><span class='line'>        messageId = 0
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>为了能在protocol extension实现一个默认的init?(_ bytes: [UInt8])方法，就必须要多定义一个没什么意义的init()方法。这让我直接放弃了这个念头，转而直接在每个消息类型的struct中实现对应的解析init方法，虽然这样会让部分代码重复。<br>
至此，MQTT协议的消息类型实现差不多完成了，因为后续的12种消息和前面这2种大同小异。<br></p>

<h5>MQTT协议消息解析</h5>

<p>和CocoaMQTT一样，SwiftMQTT也是使用GCDAsyncSocket来进行socket通信。在调用GCDAsyncSocket实例的readData系列方法并读取到数据后，便可以从以下代理方法中解析读取到的数据：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)socket:(GCDAsyncSocket *)sock didReadData:(NSData *)data withTag:(long)tag</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是，如果使用的是按照缓存排列每次读取固定子节的方法：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- (void)readDataToLength:(NSUInteger)length withTimeout:(NSTimeInterval)timeout tag:(long)tag;</span></code></pre></td></tr></table></div></figure>


<p>那么只要有一次读取错误，就会影响到后续所有数据的读取。<br>
解析返回报文的主要方法如下：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>mutating func unpackData(data: NSData, part: SwiftMQTTMessagePart, nextReader:SwiftMQTTMessageDecoderNextReader) {
</span><span class='line'>    let bytes = data.bytesArray
</span><span class='line'>    switch part {
</span><span class='line'>    case .Header:
</span><span class='line'>        messageHeader = unpackHeader(bytes)
</span><span class='line'>        // 读取一个字节的剩余长度
</span><span class='line'>        nextReader(length: 1, part: .Length)
</span><span class='line'>    case .Length:
</span><span class='line'>        messageLengthBytes.appendContentsOf(bytes)
</span><span class='line'>        // 如果最高位为0，则剩余长度已确定
</span><span class='line'>        if Bool(bytes[0] & 0x80) {
</span><span class='line'>            // 继续读取一个字节的剩余长度
</span><span class='line'>            nextReader(length: 1, part: .Length)
</span><span class='line'>        } else {
</span><span class='line'>            // 获取剩余长度
</span><span class='line'>            let messageLength = unpackLength(messageLengthBytes)
</span><span class='line'>            if messageLength &gt; 0 {
</span><span class='line'>                // 读取可变报头和payload
</span><span class='line'>                nextReader(length: messageLength, part: .Content)
</span><span class='line'>            } else {
</span><span class='line'>                // 没有可变报头和payload，不需要再进行读取操作，直接解包
</span><span class='line'>                unpackContent()
</span><span class='line'>            }
</span><span class='line'>            // 重置长度缓存
</span><span class='line'>            messageLengthBytes.removeAll()
</span><span class='line'>        }
</span><span class='line'>    case .Content:
</span><span class='line'>        // 解析可变报头和payload
</span><span class='line'>        unpackContent(bytes)
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>报文分三个部分进行读取。需要注意的是读取剩余长度时，需要循环读取一个字节，以便确定剩余长度的最高字节。</p>

<h4>小结</h4>

<p>最后对比各个协议库，如果需要使用到MQTT的大部分功能，那么阅读Mosquitto源码会是个不错的选择，毕竟其实现的功能还是相对完善的。<br>
而对于这次实践，总感觉有些地方使用面向协议没有面向对象来的更加简洁，不过这也是利弊的权衡吧，还是在可以接受的范围。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">tripleCC</span></span>

      




<time class='entry-date' datetime='2016-05-12T17:12:43+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>12</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>5:12 pm</span></time>
      


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2016-04-23-geng-jia-kuai-su-di-she-zhi-frame/" title="Previous Post: 更加快速地设置Frame">&laquo; 更加快速地设置Frame</a>
      
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>关于我</h1>
  <p> 喜欢技术，喜欢Ubuntu，喜欢字符终端，热衷底层，涉略微处理器、Linux，最终加入移动大家庭 </p>
  <a href="http://www.jianshu.com/users/97e39e95c2cc" style="color: coral"> 访问我的简书 </a><br>
  <a href="https://github.com/tripleCC" style="color: coral"> 访问我的github </a><br>
  <a href="https://twitter.com/tripleCCBrian" style="color: coral"> 我的twitter </a>
</section>
<section>
  <h1>最近发布</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016-05-12-mqttshi-yong-xiao-ji/">MQTT使用小记</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016-04-23-geng-jia-kuai-su-di-she-zhi-frame/">更加快速地设置Frame</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016-03-17-sdwebimageshe-zhi-da-chi-cun-tu-pian-beng-kui-wen-ti/">SDWebImage设置大尺寸图片崩溃问题</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016-03-09-ioszhi-shi-sui-pian-wu/">iOS知识碎片五</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016-02-05-locksmithmian-xiang-xie-yi-ku/">关于keychain封装库Locksmith</a>
      </li>
    
  </ul>
</section>




<section>
    <h1>友情链接</h1>
    <ul>
        <li>
            <a href="http://wxgbridgeq.github.io/">小乔的个人学习博客</a>
        </li>
    </ul>
</section>
  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - tripleCC -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>

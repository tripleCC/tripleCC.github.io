
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>使用响应者链条解决需求 - tripleCC的技术博客</title>
  <meta name="author" content="tripleCC">

  
  <meta name="description" content="事件传递和触底整体过程 发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中(产生)
UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）（传递） &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://triplecc.github.io/blog/2015-09-02-shi-yong-xiang-ying-zhe-lian-tiao-jie-jue-xu-qiu/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="tripleCC的技术博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://libs.useso.com/js/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.useso.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.useso.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">tripleCC的技术博客</a></h1>
  
    <h2>日拱一卒</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.baidu.com" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="triplecc.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">所有文章</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">使用响应者链条解决需求</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-09-02T00:20:22+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>12:20 am</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><ul>
<li>事件传递和触底整体过程

<ul>
<li>发生触摸事件后，系统会将该事件加入到一个由<code>UIApplication管理的事件队列</code>中(<strong>产生</strong>)</li>
<li>UIApplication会从事件队列中取出<code>最前面的事件</code>，并将事件分发下去以便处理，通常，先发送事件给应用程序的<code>主窗口（keyWindow）</code>（<strong>传递</strong>）</li>
<li>主窗口会在视图层次结构中找到一个<code>最合适的视图</code>来处理触摸事件，这也是整个事件处理过程的<code>第一步</code>（<strong>传递</strong>）</li>
<li>找到合适的视图控件后，就会调用<code>视图控件的touches方法</code>来作具体的事件处理（<strong>处理</strong>）</li>
</ul>
</li>
<li>事件<code>传递</code>方向

<ul>
<li>底层->顶层

<ul>
<li>所以<code>父控件不能接收</code>触摸事件时，<code>子控件就不能</code>接收触摸事件</li>
</ul>
</li>
</ul>
</li>
<li>事件<code>处理</code>方向

<ul>
<li>顶层->底层

<ul>
<li>所以在<code>子控件处理</code>了事件，并且<code>没有向父控件传递</code>事件时，<code>父控件就不会处理</code>事件</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>事件传递</h2>

<p><img src="/images%0A-%20%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E5%92%8C%E8%A7%A6%E5%BA%95%E6%95%B4%E4%BD%93%E8%BF%87%E7%A8%8B%0A%20%20-%20%E5%8F%91%E7%94%9F%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E5%90%8E%EF%BC%8C%E7%B3%BB%E7%BB%9F%E4%BC%9A%E5%B0%86%E8%AF%A5%E4%BA%8B%E4%BB%B6%E5%8A%A0%E5%85%A5%E5%88%B0%E4%B8%80%E4%B8%AA%E7%94%B1`UIApplication%E7%AE%A1%E7%90%86%E7%9A%84%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97`%E4%B8%AD(**%E4%BA%A7%E7%94%9F**" alt="" />
  - UIApplication会从事件队列中取出<code>最前面的事件</code>，并将事件分发下去以便处理，通常，先发送事件给应用程序的<code>主窗口（keyWindow）</code>（<strong>传递</strong>）
  - 主窗口会在视图层次结构中找到一个<code>最合适的视图</code>来处理触摸事件，这也是整个事件处理过程的<code>第一步</code>（<strong>传递</strong>）
  - 找到合适的视图控件后，就会调用<code>视图控件的touches方法</code>来作具体的事件处理（<strong>处理</strong>）
- 事件<code>传递</code>方向
  - 底层->顶层
    - 所以<code>父控件不能接收</code>触摸事件时，<code>子控件就不能</code>接收触摸事件
- 事件<code>处理</code>方向
  - 顶层->底层
    - 所以在<code>子控件处理</code>了事件，并且<code>没有向父控件传递</code>事件时，<code>父控件就不会处理</code>事件</p>

<h2>事件传递</h2>

<p><img src="./image/Snip20150616_2.png" alt="" /><br></p>

<ul>
<li>点击绿色View

<ul>
<li>UIApplication->UIWindow->白色View->绿色View</li>
</ul>
</li>
<li>点击黄色View

<ul>
<li>UIApplication->UIWindow->白色View->橙色View->蓝色View->黄色View</li>
</ul>
</li>
<li><p>查找最合适的控件来处理事件</p>

<ul>
<li><code>自己能否接收触摸事件</code>(1)</li>
<li><code>触摸点是否在自己身上</code>(2)</li>
<li><code>从后往前遍历子控件，重复前面两个步骤</code>(3)</li>
<li><code>如果没有符合条件的子控件，那么自己就是最合适的控件</code>(4)

<ul>
<li>点击黄色View的查找情况

<ul>
<li>UIApplication->UIWindow->白色View很明显</li>
<li>白色View:满足(1),(2)

<ul>
<li>执行(3)(在子控件数组中，橙色View在绿色View后面)

<ul>
<li>->橙色View:满足(1),(2)

<ul>
<li>执行(3)(红色View后于蓝色View添加，先遍历红色View)

<ul>
<li>->红色View:满足(1),不满足(2)</li>
<li>->蓝色View:满足(1),(2)

<ul>
<li>执行(3)

<ul>
<li>->黄色View:满足(1),(2)

<ul>
<li>执行(3),没有子控件，自己就是最适合的控件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>->绿色View:满足(1),不满足(2)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>UIView<code>不接受触摸</code>的三种情况</p>

<ul>
<li>不使能用户交互<br></li>
</ul>


<pre><code class="objc">userInteractionEnabled = NO
</code></pre>

<ul>
<li>隐藏<br></li>
</ul>


<pre><code class="objc">hidden = YES
</code></pre>

<ul>
<li>透明<br></li>
</ul>


<pre><code class="objc">alpha = 0.0 ~ 0.01
</code></pre>

<ul>
<li>苹果说明<br>
<img src="./image/Snip20150616_1.png" alt="" /></li>
</ul>
</li>
<li><p>寻找最适合控件内部实现</p>

<ul>
<li>寻找最适合控件方法<br>

<ul>
<li>方法内部的默认实现是依次调用子控件的这个方法，直到遍历完自己的子控件然后返回</li>
</ul>


<p>```objc
// 当事件传递给控件的时候[父控件找到子控件，调用子控件的这个方法并传入event参数]，就会调用控件的这个方法，去寻找最合适的view</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event;
```</li>
<li><p>坐标判断和转换<br></p>

<pre><code class="objc">// 将point的值，从调用这个方法的控件坐标系转到view控件    坐标系
- (CGPoint)convertPoint:(CGPoint)point toView:(UIView     *)view;
// 判断事件发生点是否在调用此方法的控件上
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent     *)event;
</code></pre></li>
<li><p>由以上两点信息可以写出<code>寻找最适合控件的内部实现</code> <br></p>

<p>```objc</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event
{
// 1.是否可以响应
if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt; 0.01) {
   return nil;
}</li>
</ul>


<p>  // 2.触摸点是否在控件上
  if ([self pointInside:point withEvent:event] == NO) {
      return nil;
  }</p>

<p>  // 3.递归遍历子控件
  for (int i = (int)self.subviews.count - 1; i >= 0; i&ndash;) {
      UIView *view = self.subviews[i];</p>

<pre><code>  // 将当前控件上的坐标系转换成子控件上的坐标系
  CGPoint childP = [self convertPoint:point toView:view];

  UIView *fitView = [view hitTest:childP withEvent:event];

  if (fitView) {
      // 找到适合的子控件
      return fitView;
  }
</code></pre>

<p>  }</p>

<p>  // 循环结束，表示没有比自己更适合的view
  return self;
}
```</p></li>
</ul>


<h2>事件处理</h2>

<ul>
<li>用户点击屏幕后产生的一个触摸事件，经过一系列的传递过程后，会找到最合适的视图控件来处理这个事件</li>
<li>找到最合适的视图控件后，就会调用<code>对应控件</code>的touches方法来作具体的事件处理

<ul>
<li>touchesBegan…</li>
<li>touchesMoved…</li>
<li>touchedEnded…</li>
<li>如果没有实现以上方法，就传递给父控件</li>
</ul>
</li>
<li>touches方法的<code>默认做法</code>是将事件<code>顺着响应者链条向上传递</code>，将事件交给上一个响应者进行处理

<ul>
<li>所以在相应控件实现了touches方法，就等于拦截了事件，在拦截控件上进行处理</li>
<li>这里<code>注意UIGestureRecognizer的区别</code>，两个并<code>不互相拦截</code>，要想拦截UIGestureRecognizer的手势处理，需要<code>在子控件上添加相同的手势</code>，<code>实现touches方法是没用的</code></li>
</ul>
</li>
</ul>


<h3>响应者链条</h3>

<ul>
<li>响应者链条：是由多个响应者对象连接起来的链条</li>
<li>作用：能很清楚的看见每个响应者之间的联系，并且可以让一个事件多个对象处理。</li>
<li>响应者对象：能处理事件的对象</li>
<li>响应者链条示意图
<img src="./image/Snip20150616_3.png" alt="" />

<ul>
<li>如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图</li>
<li>在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理</li>
<li>如果window对象也不处理，则其将事件或消息传递给UIApplication对象</li>
<li>如果UIApplication也不能处理该事件或消息，则将其丢弃</li>
</ul>
</li>
</ul>


<h2>事件传递的完整过程</h2>

<ul>
<li><p>先将事件对象由上往下传递(由父控件传递给子控件,也就是<code>从底层到顶层</code>)，找到最合适的控件来处理这个事件。</p></li>
<li><p>调用<code>最合适控件的touches….方法</code></p></li>
<li><p>如果调用了<code>[super touches….];</code>就会将事件顺着响应者链条往上传递，传递给上一个响应者［可以做到<code>一个事件多个控件响应</code>］</p>

<ul>
<li>注意，<code>如果这时，父类实现了touches….方法，但是没有调用[super touches….]，就不会传给上一个响应者，而是以父类的touches….方法解决</code>

<ul>
<li>在继承UIButton的时候就需要注意这一点，自定义button调用[super touches….]是不会传递给父控件的，因为UIButton实现了touches….方法，但是没有调用[super touches….]

<ul>
<li><code>UIButton的addTagert:方法会和touches方法冲突</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接着就会调用上一个响应者的touches….方法</p></li>
<li>判断上一个响应者

<ul>
<li>如果<code>当前这个view是控制器的view，那么控制器就是上一个响应者</code></li>
<li>如果<code>当前这个view不是控制器的view，那么父控件就是上一个响应者</code></li>
</ul>
</li>
</ul>


<h2>利用事件传递解决需求</h2>

<ul>
<li><p>实例1<br>
<img src="./image/Snip20150616_4.png" alt="" /></p>

<ul>
<li>需求：在点击到按钮的部分时，需要按钮响应，其他部分由绿色view响应

<ul>
<li>问题：由于部分按钮被绿色view覆盖了，所以点击被覆盖的按钮时，还是绿色view响应</li>
<li>解决：自定义绿色view，添加按钮属性，并重写绿色view的-hitTest:withEvent:方法，在里面判断是否在按钮范围内。<br></li>
</ul>


<pre><code class="objc">// 自定义绿色view
@interface TPCView()
/** 按钮 */
@property (weak, nonatomic) IBOutlet UIButton *button;
@end

@implementation TPCView

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
// 转换成按钮坐标系
CGPoint buttonP = [self convertPoint:point toView:_button];

// 如果点在按钮上，就返回按钮
if ([_button pointInside:buttonP withEvent:event]) {
    return _button;
}

// 其他情况返回本身
return [super hitTest:point withEvent:event];
}
@end
</code></pre></li>
</ul>
</li>
<li><p>实例2</p>

<ul>
<li>开始<br>
<img src="./image/Snip20150616_5.png" alt="" /></li>
<li>点击按钮<br>
<img src="./image/Snip20150616_6.png" alt="" /></li>
<li>点击对话框<br>
<img src="./image/Snip20150616_10.png" alt="" /></li>
<li>需求：点击按钮出现对话框，能对对话框进行点击，并且能对按钮进行拖动（对话框也同时动）</li>
<li>解决：点击按钮时，将对话框设置为按钮的子控件</li>
<li>问题：对话框不在父控件范围内，点击对话框时，无法满足事件传递要求（触摸点不在父控件按钮上，在这里就断了，所以不会去判断其子控件）</li>
<li><p>解决：自定义按钮控件，添加对话框属性，重写按钮的-hitTest:withEvent:方法，在里面判断是否在对话框范围内范围内。<br></p>

<pre><code class="objc">// 控制器中代码
- (IBAction)popChatView:(PopBtn *)sender {
// 弹出对话框
UIButton *chatView = [UIButton buttonWithType:UIButtonTypeCustom];

chatView.bounds = CGRectMake(0, 0, 200, 200);
chatView.center = CGPointMake(100, -100);

[chatView setBackgroundImage:[UIImage imageNamed:@"对话框"] forState:UIControlStateNormal];
[chatView setBackgroundImage:[UIImage imageNamed:@"小孩"] forState:UIControlStateHighlighted];
sender.chatView = chatView;
[sender addSubview:chatView];

}
</code></pre>

<pre><code class="objc">
// 自定义按钮
@implementation PopBtn

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{

// 当前控件上的点转换到chatView上
CGPoint chatP = [self convertPoint:point toView:self.chatView];

// 判断下点在不在chatView上
if ([self.chatView pointInside:chatP withEvent:event]) {
    return self.chatView;
}else{
    return [super hitTest:point withEvent:event];
}

}

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
// 获取UITouch
UITouch *touch = [touches anyObject];

// 获取当前的点
CGPoint curP = [touch locationInView:self];

// 获取上一个的点
CGPoint preP = [touch previousLocationInView:self];

// 获取偏移量
CGFloat offsetX = curP.x - preP.x;
CGFloat OffsetY = curP.y - preP.y;

// 修改控件的位置
CGPoint center = self.center;
center.x += offsetX;
center.y += OffsetY;

self.center = center;

}
@end
</code></pre></li>
</ul>
</li>
<li>总结

<ul>
<li>这种情况下，大都是自定义覆盖需要响应控件的控件，或者子控件超出父控件范围的父控件，然后添加对应需要接收响应的控件属性，重写自定义控件的hitTest方法，在里面将触摸点转换成需要接收响应控件的坐标系，判断是否在其坐标系内，再返回对应的控件

<h1>eventstransmitandhandle</h1></li>
</ul>
</li>
<li>事件传递和触底整体过程

<ul>
<li>发生触摸事件后，系统会将该事件加入到一个由<code>UIApplication管理的事件队列</code>中(<strong>产生</strong>)</li>
<li>UIApplication会从事件队列中取出<code>最前面的事件</code>，并将事件分发下去以便处理，通常，先发送事件给应用程序的<code>主窗口（keyWindow）</code>（<strong>传递</strong>）</li>
<li>主窗口会在视图层次结构中找到一个<code>最合适的视图</code>来处理触摸事件，这也是整个事件处理过程的<code>第一步</code>（<strong>传递</strong>）</li>
<li>找到合适的视图控件后，就会调用<code>视图控件的touches方法</code>来作具体的事件处理（<strong>处理</strong>）</li>
</ul>
</li>
<li>事件<code>传递</code>方向

<ul>
<li>底层->顶层

<ul>
<li>所以<code>父控件不能接收</code>触摸事件时，<code>子控件就不能</code>接收触摸事件</li>
</ul>
</li>
</ul>
</li>
<li>事件<code>处理</code>方向

<ul>
<li>顶层->底层

<ul>
<li>所以在<code>子控件处理</code>了事件，并且<code>没有向父控件传递</code>事件时，<code>父控件就不会处理</code>事件</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>事件传递</h2>

<p><img src="./image/Snip20150616_2.png" alt="" /><br></p>

<ul>
<li>点击绿色View

<ul>
<li>UIApplication->UIWindow->白色View->绿色View</li>
</ul>
</li>
<li>点击黄色View

<ul>
<li>UIApplication->UIWindow->白色View->橙色View->蓝色View->黄色View</li>
</ul>
</li>
<li><p>查找最合适的控件来处理事件</p>

<ul>
<li><code>自己能否接收触摸事件</code>(1)</li>
<li><code>触摸点是否在自己身上</code>(2)</li>
<li><code>从后往前遍历子控件，重复前面两个步骤</code>(3)</li>
<li><code>如果没有符合条件的子控件，那么自己就是最合适的控件</code>(4)

<ul>
<li>点击黄色View的查找情况

<ul>
<li>UIApplication->UIWindow->白色View很明显</li>
<li>白色View:满足(1),(2)

<ul>
<li>执行(3)(在子控件数组中，橙色View在绿色View后面)

<ul>
<li>->橙色View:满足(1),(2)

<ul>
<li>执行(3)(红色View后于蓝色View添加，先遍历红色View)

<ul>
<li>->红色View:满足(1),不满足(2)</li>
<li>->蓝色View:满足(1),(2)

<ul>
<li>执行(3)

<ul>
<li>->黄色View:满足(1),(2)

<ul>
<li>执行(3),没有子控件，自己就是最适合的控件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>->绿色View:满足(1),不满足(2)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>UIView<code>不接受触摸</code>的三种情况</p>

<ul>
<li>不使能用户交互<br></li>
</ul>


<pre><code class="objc">userInteractionEnabled = NO
</code></pre>

<ul>
<li>隐藏<br></li>
</ul>


<pre><code class="objc">hidden = YES
</code></pre>

<ul>
<li>透明<br></li>
</ul>


<pre><code class="objc">alpha = 0.0 ~ 0.01
</code></pre>

<ul>
<li>苹果说明<br>
<img src="./image/Snip20150616_1.png" alt="" /></li>
</ul>
</li>
<li><p>寻找最适合控件内部实现</p>

<ul>
<li>寻找最适合控件方法<br>

<ul>
<li>方法内部的默认实现是依次调用子控件的这个方法，直到遍历完自己的子控件然后返回</li>
</ul>


<p>```objc
// 当事件传递给控件的时候[父控件找到子控件，调用子控件的这个方法并传入event参数]，就会调用控件的这个方法，去寻找最合适的view</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event;
```</li>
<li><p>坐标判断和转换<br></p>

<pre><code class="objc">// 将point的值，从调用这个方法的控件坐标系转到view控件    坐标系
- (CGPoint)convertPoint:(CGPoint)point toView:(UIView     *)view;
// 判断事件发生点是否在调用此方法的控件上
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent     *)event;
</code></pre></li>
<li><p>由以上两点信息可以写出<code>寻找最适合控件的内部实现</code> <br></p>

<p>```objc</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event
{
// 1.是否可以响应
if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt; 0.01) {
   return nil;
}</li>
</ul>


<p>  // 2.触摸点是否在控件上
  if ([self pointInside:point withEvent:event] == NO) {
      return nil;
  }</p>

<p>  // 3.递归遍历子控件
  for (int i = (int)self.subviews.count - 1; i >= 0; i&ndash;) {
      UIView *view = self.subviews[i];</p>

<pre><code>  // 将当前控件上的坐标系转换成子控件上的坐标系
  CGPoint childP = [self convertPoint:point toView:view];

  UIView *fitView = [view hitTest:childP withEvent:event];

  if (fitView) {
      // 找到适合的子控件
      return fitView;
  }
</code></pre>

<p>  }</p>

<p>  // 循环结束，表示没有比自己更适合的view
  return self;
}
```</p></li>
</ul>


<h2>事件处理</h2>

<ul>
<li>用户点击屏幕后产生的一个触摸事件，经过一系列的传递过程后，会找到最合适的视图控件来处理这个事件</li>
<li>找到最合适的视图控件后，就会调用<code>对应控件</code>的touches方法来作具体的事件处理

<ul>
<li>touchesBegan…</li>
<li>touchesMoved…</li>
<li>touchedEnded…</li>
<li>如果没有实现以上方法，就传递给父控件</li>
</ul>
</li>
<li>touches方法的<code>默认做法</code>是将事件<code>顺着响应者链条向上传递</code>，将事件交给上一个响应者进行处理

<ul>
<li>所以在相应控件实现了touches方法，就等于拦截了事件，在拦截控件上进行处理</li>
<li>这里<code>注意UIGestureRecognizer的区别</code>，两个并<code>不互相拦截</code>，要想拦截UIGestureRecognizer的手势处理，需要<code>在子控件上添加相同的手势</code>，<code>实现touches方法是没用的</code></li>
</ul>
</li>
</ul>


<h3>响应者链条</h3>

<ul>
<li>响应者链条：是由多个响应者对象连接起来的链条</li>
<li>作用：能很清楚的看见每个响应者之间的联系，并且可以让一个事件多个对象处理。</li>
<li>响应者对象：能处理事件的对象</li>
<li>响应者链条示意图
<img src="./image/Snip20150616_3.png" alt="" />

<ul>
<li>如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图</li>
<li>在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理</li>
<li>如果window对象也不处理，则其将事件或消息传递给UIApplication对象</li>
<li>如果UIApplication也不能处理该事件或消息，则将其丢弃</li>
</ul>
</li>
</ul>


<h2>事件传递的完整过程</h2>

<ul>
<li><p>先将事件对象由上往下传递(由父控件传递给子控件,也就是<code>从底层到顶层</code>)，找到最合适的控件来处理这个事件。</p></li>
<li><p>调用<code>最合适控件的touches….方法</code></p></li>
<li><p>如果调用了<code>[super touches….];</code>就会将事件顺着响应者链条往上传递，传递给上一个响应者［可以做到<code>一个事件多个控件响应</code>］</p>

<ul>
<li>注意，<code>如果这时，父类实现了touches….方法，但是没有调用[super touches….]，就不会传给上一个响应者，而是以父类的touches….方法解决</code>

<ul>
<li>在继承UIButton的时候就需要注意这一点，自定义button调用[super touches….]是不会传递给父控件的，因为UIButton实现了touches….方法，但是没有调用[super touches….]

<ul>
<li><code>UIButton的addTagert:方法会和touches方法冲突</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接着就会调用上一个响应者的touches….方法</p></li>
<li>判断上一个响应者

<ul>
<li>如果<code>当前这个view是控制器的view，那么控制器就是上一个响应者</code></li>
<li>如果<code>当前这个view不是控制器的view，那么父控件就是上一个响应者</code></li>
</ul>
</li>
</ul>


<h2>利用事件传递解决需求</h2>

<ul>
<li><p>实例1<br>
<img src="./image/Snip20150616_4.png" alt="" /></p>

<ul>
<li>需求：在点击到按钮的部分时，需要按钮响应，其他部分由绿色view响应

<ul>
<li>问题：由于部分按钮被绿色view覆盖了，所以点击被覆盖的按钮时，还是绿色view响应</li>
<li>解决：自定义绿色view，添加按钮属性，并重写绿色view的-hitTest:withEvent:方法，在里面判断是否在按钮范围内。<br></li>
</ul>


<pre><code class="objc">// 自定义绿色view
@interface TPCView()
/** 按钮 */
@property (weak, nonatomic) IBOutlet UIButton *button;
@end

@implementation TPCView

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
// 转换成按钮坐标系
CGPoint buttonP = [self convertPoint:point toView:_button];

// 如果点在按钮上，就返回按钮
if ([_button pointInside:buttonP withEvent:event]) {
    return _button;
}

// 其他情况返回本身
return [super hitTest:point withEvent:event];
}
@end
</code></pre></li>
</ul>
</li>
<li><p>实例2</p>

<ul>
<li>开始<br>
<img src="./image/Snip20150616_5.png" alt="" /></li>
<li>点击按钮<br>
<img src="./image/Snip20150616_6.png" alt="" /></li>
<li>点击对话框<br>
<img src="./image/Snip20150616_10.png" alt="" /></li>
<li>需求：点击按钮出现对话框，能对对话框进行点击，并且能对按钮进行拖动（对话框也同时动）</li>
<li>解决：点击按钮时，将对话框设置为按钮的子控件</li>
<li>问题：对话框不在父控件范围内，点击对话框时，无法满足事件传递要求（触摸点不在父控件按钮上，在这里就断了，所以不会去判断其子控件）</li>
<li><p>解决：自定义按钮控件，添加对话框属性，重写按钮的-hitTest:withEvent:方法，在里面判断是否在对话框范围内范围内。<br></p>

<pre><code class="objc">// 控制器中代码
- (IBAction)popChatView:(PopBtn *)sender {
// 弹出对话框
UIButton *chatView = [UIButton buttonWithType:UIButtonTypeCustom];

chatView.bounds = CGRectMake(0, 0, 200, 200);
chatView.center = CGPointMake(100, -100);

[chatView setBackgroundImage:[UIImage imageNamed:@"对话框"] forState:UIControlStateNormal];
[chatView setBackgroundImage:[UIImage imageNamed:@"小孩"] forState:UIControlStateHighlighted];
sender.chatView = chatView;
[sender addSubview:chatView];

}
</code></pre>

<pre><code class="objc">
// 自定义按钮
@implementation PopBtn

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{

// 当前控件上的点转换到chatView上
CGPoint chatP = [self convertPoint:point toView:self.chatView];

// 判断下点在不在chatView上
if ([self.chatView pointInside:chatP withEvent:event]) {
    return self.chatView;
}else{
    return [super hitTest:point withEvent:event];
}

}

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
// 获取UITouch
UITouch *touch = [touches anyObject];

// 获取当前的点
CGPoint curP = [touch locationInView:self];

// 获取上一个的点
CGPoint preP = [touch previousLocationInView:self];

// 获取偏移量
CGFloat offsetX = curP.x - preP.x;
CGFloat OffsetY = curP.y - preP.y;

// 修改控件的位置
CGPoint center = self.center;
center.x += offsetX;
center.y += OffsetY;

self.center = center;

}
@end
</code></pre></li>
</ul>
</li>
<li><p>总结</p>

<ul>
<li>这种情况下，大都是自定义覆盖需要响应控件的控件，或者子控件超出父控件范围的父控件，然后添加对应需要接收响应的控件属性，重写自定义控件的hitTest方法，在里面将触摸点转换成需要接收响应控件的坐标系，判断是否在其坐标系内，再返回对应的控件
/Snip20150616_2.png)<br></li>
</ul>
</li>
<li><p>点击绿色View</p>

<ul>
<li>UIApplication->UIWindow->白色View->绿色View</li>
</ul>
</li>
<li>点击黄色View

<ul>
<li>UIApplication->UIWindow->白色View->橙色View->蓝色View->黄色View</li>
</ul>
</li>
<li><p>查找最合适的控件来处理事件</p>

<ul>
<li><code>自己能否接收触摸事件</code>(1)</li>
<li><code>触摸点是否在自己身上</code>(2)</li>
<li><code>从后往前遍历子控件，重复前面两个步骤</code>(3)</li>
<li><code>如果没有符合条件的子控件，那么自己就是最合适的控件</code>(4)

<ul>
<li>点击黄色View的查找情况

<ul>
<li>UIApplication->UIWindow->白色View很明显</li>
<li>白色View:满足(1),(2)

<ul>
<li>执行(3)(在子控件数组中，橙色View在绿色View后面)

<ul>
<li>->橙色View:满足(1),(2)

<ul>
<li>执行(3)(红色View后于蓝色View添加，先遍历红色View)

<ul>
<li>->红色View:满足(1),不满足(2)</li>
<li>->蓝色View:满足(1),(2)

<ul>
<li>执行(3)

<ul>
<li>->黄色View:满足(1),(2)

<ul>
<li>执行(3),没有子控件，自己就是最适合的控件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>->绿色View:满足(1),不满足(2)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>UIView<code>不接受触摸</code>的三种情况</p>

<ul>
<li>不使能用户交互<br></li>
</ul>


<pre><code class="objc">userInteractionEnabled = NO
</code></pre>

<ul>
<li>隐藏<br></li>
</ul>


<pre><code class="objc">hidden = YES
</code></pre>

<ul>
<li>透明<br></li>
</ul>


<pre><code class="objc">alpha = 0.0 ~ 0.01
</code></pre>

<ul>
<li>苹果说明<br>
![](/images</li>
</ul>
</li>
<li>事件传递和触底整体过程

<ul>
<li>发生触摸事件后，系统会将该事件加入到一个由<code>UIApplication管理的事件队列</code>中(<strong>产生</strong>)</li>
<li>UIApplication会从事件队列中取出<code>最前面的事件</code>，并将事件分发下去以便处理，通常，先发送事件给应用程序的<code>主窗口（keyWindow）</code>（<strong>传递</strong>）</li>
<li>主窗口会在视图层次结构中找到一个<code>最合适的视图</code>来处理触摸事件，这也是整个事件处理过程的<code>第一步</code>（<strong>传递</strong>）</li>
<li>找到合适的视图控件后，就会调用<code>视图控件的touches方法</code>来作具体的事件处理（<strong>处理</strong>）</li>
</ul>
</li>
<li>事件<code>传递</code>方向

<ul>
<li>底层->顶层

<ul>
<li>所以<code>父控件不能接收</code>触摸事件时，<code>子控件就不能</code>接收触摸事件</li>
</ul>
</li>
</ul>
</li>
<li>事件<code>处理</code>方向

<ul>
<li>顶层->底层

<ul>
<li>所以在<code>子控件处理</code>了事件，并且<code>没有向父控件传递</code>事件时，<code>父控件就不会处理</code>事件</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>事件传递</h2>

<p><img src="./image/Snip20150616_2.png" alt="" /><br></p>

<ul>
<li>点击绿色View

<ul>
<li>UIApplication->UIWindow->白色View->绿色View</li>
</ul>
</li>
<li>点击黄色View

<ul>
<li>UIApplication->UIWindow->白色View->橙色View->蓝色View->黄色View</li>
</ul>
</li>
<li><p>查找最合适的控件来处理事件</p>

<ul>
<li><code>自己能否接收触摸事件</code>(1)</li>
<li><code>触摸点是否在自己身上</code>(2)</li>
<li><code>从后往前遍历子控件，重复前面两个步骤</code>(3)</li>
<li><code>如果没有符合条件的子控件，那么自己就是最合适的控件</code>(4)

<ul>
<li>点击黄色View的查找情况

<ul>
<li>UIApplication->UIWindow->白色View很明显</li>
<li>白色View:满足(1),(2)

<ul>
<li>执行(3)(在子控件数组中，橙色View在绿色View后面)

<ul>
<li>->橙色View:满足(1),(2)

<ul>
<li>执行(3)(红色View后于蓝色View添加，先遍历红色View)

<ul>
<li>->红色View:满足(1),不满足(2)</li>
<li>->蓝色View:满足(1),(2)

<ul>
<li>执行(3)

<ul>
<li>->黄色View:满足(1),(2)

<ul>
<li>执行(3),没有子控件，自己就是最适合的控件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>->绿色View:满足(1),不满足(2)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>UIView<code>不接受触摸</code>的三种情况</p>

<ul>
<li>不使能用户交互<br></li>
</ul>


<pre><code class="objc">userInteractionEnabled = NO
</code></pre>

<ul>
<li>隐藏<br></li>
</ul>


<pre><code class="objc">hidden = YES
</code></pre>

<ul>
<li>透明<br></li>
</ul>


<pre><code class="objc">alpha = 0.0 ~ 0.01
</code></pre>

<ul>
<li>苹果说明<br>
<img src="./image/Snip20150616_1.png" alt="" /></li>
</ul>
</li>
<li><p>寻找最适合控件内部实现</p>

<ul>
<li>寻找最适合控件方法<br>

<ul>
<li>方法内部的默认实现是依次调用子控件的这个方法，直到遍历完自己的子控件然后返回</li>
</ul>


<p>```objc
// 当事件传递给控件的时候[父控件找到子控件，调用子控件的这个方法并传入event参数]，就会调用控件的这个方法，去寻找最合适的view</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event;
```</li>
<li><p>坐标判断和转换<br></p>

<pre><code class="objc">// 将point的值，从调用这个方法的控件坐标系转到view控件    坐标系
- (CGPoint)convertPoint:(CGPoint)point toView:(UIView     *)view;
// 判断事件发生点是否在调用此方法的控件上
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent     *)event;
</code></pre></li>
<li><p>由以上两点信息可以写出<code>寻找最适合控件的内部实现</code> <br></p>

<p>```objc</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event
{
// 1.是否可以响应
if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt; 0.01) {
   return nil;
}</li>
</ul>


<p>  // 2.触摸点是否在控件上
  if ([self pointInside:point withEvent:event] == NO) {
      return nil;
  }</p>

<p>  // 3.递归遍历子控件
  for (int i = (int)self.subviews.count - 1; i >= 0; i&ndash;) {
      UIView *view = self.subviews[i];</p>

<pre><code>  // 将当前控件上的坐标系转换成子控件上的坐标系
  CGPoint childP = [self convertPoint:point toView:view];

  UIView *fitView = [view hitTest:childP withEvent:event];

  if (fitView) {
      // 找到适合的子控件
      return fitView;
  }
</code></pre>

<p>  }</p>

<p>  // 循环结束，表示没有比自己更适合的view
  return self;
}
```</p></li>
</ul>


<h2>事件处理</h2>

<ul>
<li>用户点击屏幕后产生的一个触摸事件，经过一系列的传递过程后，会找到最合适的视图控件来处理这个事件</li>
<li>找到最合适的视图控件后，就会调用<code>对应控件</code>的touches方法来作具体的事件处理

<ul>
<li>touchesBegan…</li>
<li>touchesMoved…</li>
<li>touchedEnded…</li>
<li>如果没有实现以上方法，就传递给父控件</li>
</ul>
</li>
<li>touches方法的<code>默认做法</code>是将事件<code>顺着响应者链条向上传递</code>，将事件交给上一个响应者进行处理

<ul>
<li>所以在相应控件实现了touches方法，就等于拦截了事件，在拦截控件上进行处理</li>
<li>这里<code>注意UIGestureRecognizer的区别</code>，两个并<code>不互相拦截</code>，要想拦截UIGestureRecognizer的手势处理，需要<code>在子控件上添加相同的手势</code>，<code>实现touches方法是没用的</code></li>
</ul>
</li>
</ul>


<h3>响应者链条</h3>

<ul>
<li>响应者链条：是由多个响应者对象连接起来的链条</li>
<li>作用：能很清楚的看见每个响应者之间的联系，并且可以让一个事件多个对象处理。</li>
<li>响应者对象：能处理事件的对象</li>
<li>响应者链条示意图
<img src="./image/Snip20150616_3.png" alt="" />

<ul>
<li>如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图</li>
<li>在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理</li>
<li>如果window对象也不处理，则其将事件或消息传递给UIApplication对象</li>
<li>如果UIApplication也不能处理该事件或消息，则将其丢弃</li>
</ul>
</li>
</ul>


<h2>事件传递的完整过程</h2>

<ul>
<li><p>先将事件对象由上往下传递(由父控件传递给子控件,也就是<code>从底层到顶层</code>)，找到最合适的控件来处理这个事件。</p></li>
<li><p>调用<code>最合适控件的touches….方法</code></p></li>
<li><p>如果调用了<code>[super touches….];</code>就会将事件顺着响应者链条往上传递，传递给上一个响应者［可以做到<code>一个事件多个控件响应</code>］</p>

<ul>
<li>注意，<code>如果这时，父类实现了touches….方法，但是没有调用[super touches….]，就不会传给上一个响应者，而是以父类的touches….方法解决</code>

<ul>
<li>在继承UIButton的时候就需要注意这一点，自定义button调用[super touches….]是不会传递给父控件的，因为UIButton实现了touches….方法，但是没有调用[super touches….]

<ul>
<li><code>UIButton的addTagert:方法会和touches方法冲突</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接着就会调用上一个响应者的touches….方法</p></li>
<li>判断上一个响应者

<ul>
<li>如果<code>当前这个view是控制器的view，那么控制器就是上一个响应者</code></li>
<li>如果<code>当前这个view不是控制器的view，那么父控件就是上一个响应者</code></li>
</ul>
</li>
</ul>


<h2>利用事件传递解决需求</h2>

<ul>
<li><p>实例1<br>
<img src="./image/Snip20150616_4.png" alt="" /></p>

<ul>
<li>需求：在点击到按钮的部分时，需要按钮响应，其他部分由绿色view响应

<ul>
<li>问题：由于部分按钮被绿色view覆盖了，所以点击被覆盖的按钮时，还是绿色view响应</li>
<li>解决：自定义绿色view，添加按钮属性，并重写绿色view的-hitTest:withEvent:方法，在里面判断是否在按钮范围内。<br></li>
</ul>


<pre><code class="objc">// 自定义绿色view
@interface TPCView()
/** 按钮 */
@property (weak, nonatomic) IBOutlet UIButton *button;
@end

@implementation TPCView

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
// 转换成按钮坐标系
CGPoint buttonP = [self convertPoint:point toView:_button];

// 如果点在按钮上，就返回按钮
if ([_button pointInside:buttonP withEvent:event]) {
    return _button;
}

// 其他情况返回本身
return [super hitTest:point withEvent:event];
}
@end
</code></pre></li>
</ul>
</li>
<li><p>实例2</p>

<ul>
<li>开始<br>
<img src="./image/Snip20150616_5.png" alt="" /></li>
<li>点击按钮<br>
<img src="./image/Snip20150616_6.png" alt="" /></li>
<li>点击对话框<br>
<img src="./image/Snip20150616_10.png" alt="" /></li>
<li>需求：点击按钮出现对话框，能对对话框进行点击，并且能对按钮进行拖动（对话框也同时动）</li>
<li>解决：点击按钮时，将对话框设置为按钮的子控件</li>
<li>问题：对话框不在父控件范围内，点击对话框时，无法满足事件传递要求（触摸点不在父控件按钮上，在这里就断了，所以不会去判断其子控件）</li>
<li><p>解决：自定义按钮控件，添加对话框属性，重写按钮的-hitTest:withEvent:方法，在里面判断是否在对话框范围内范围内。<br></p>

<pre><code class="objc">// 控制器中代码
- (IBAction)popChatView:(PopBtn *)sender {
// 弹出对话框
UIButton *chatView = [UIButton buttonWithType:UIButtonTypeCustom];

chatView.bounds = CGRectMake(0, 0, 200, 200);
chatView.center = CGPointMake(100, -100);

[chatView setBackgroundImage:[UIImage imageNamed:@"对话框"] forState:UIControlStateNormal];
[chatView setBackgroundImage:[UIImage imageNamed:@"小孩"] forState:UIControlStateHighlighted];
sender.chatView = chatView;
[sender addSubview:chatView];

}
</code></pre>

<pre><code class="objc">
// 自定义按钮
@implementation PopBtn

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{

// 当前控件上的点转换到chatView上
CGPoint chatP = [self convertPoint:point toView:self.chatView];

// 判断下点在不在chatView上
if ([self.chatView pointInside:chatP withEvent:event]) {
    return self.chatView;
}else{
    return [super hitTest:point withEvent:event];
}

}

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
// 获取UITouch
UITouch *touch = [touches anyObject];

// 获取当前的点
CGPoint curP = [touch locationInView:self];

// 获取上一个的点
CGPoint preP = [touch previousLocationInView:self];

// 获取偏移量
CGFloat offsetX = curP.x - preP.x;
CGFloat OffsetY = curP.y - preP.y;

// 修改控件的位置
CGPoint center = self.center;
center.x += offsetX;
center.y += OffsetY;

self.center = center;

}
@end
</code></pre></li>
</ul>
</li>
<li>总结

<ul>
<li>这种情况下，大都是自定义覆盖需要响应控件的控件，或者子控件超出父控件范围的父控件，然后添加对应需要接收响应的控件属性，重写自定义控件的hitTest方法，在里面将触摸点转换成需要接收响应控件的坐标系，判断是否在其坐标系内，再返回对应的控件

<h1>eventstransmitandhandle</h1></li>
</ul>
</li>
<li>事件传递和触底整体过程

<ul>
<li>发生触摸事件后，系统会将该事件加入到一个由<code>UIApplication管理的事件队列</code>中(<strong>产生</strong>)</li>
<li>UIApplication会从事件队列中取出<code>最前面的事件</code>，并将事件分发下去以便处理，通常，先发送事件给应用程序的<code>主窗口（keyWindow）</code>（<strong>传递</strong>）</li>
<li>主窗口会在视图层次结构中找到一个<code>最合适的视图</code>来处理触摸事件，这也是整个事件处理过程的<code>第一步</code>（<strong>传递</strong>）</li>
<li>找到合适的视图控件后，就会调用<code>视图控件的touches方法</code>来作具体的事件处理（<strong>处理</strong>）</li>
</ul>
</li>
<li>事件<code>传递</code>方向

<ul>
<li>底层->顶层

<ul>
<li>所以<code>父控件不能接收</code>触摸事件时，<code>子控件就不能</code>接收触摸事件</li>
</ul>
</li>
</ul>
</li>
<li>事件<code>处理</code>方向

<ul>
<li>顶层->底层

<ul>
<li>所以在<code>子控件处理</code>了事件，并且<code>没有向父控件传递</code>事件时，<code>父控件就不会处理</code>事件</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>事件传递</h2>

<p><img src="./image/Snip20150616_2.png" alt="" /><br></p>

<ul>
<li>点击绿色View

<ul>
<li>UIApplication->UIWindow->白色View->绿色View</li>
</ul>
</li>
<li>点击黄色View

<ul>
<li>UIApplication->UIWindow->白色View->橙色View->蓝色View->黄色View</li>
</ul>
</li>
<li><p>查找最合适的控件来处理事件</p>

<ul>
<li><code>自己能否接收触摸事件</code>(1)</li>
<li><code>触摸点是否在自己身上</code>(2)</li>
<li><code>从后往前遍历子控件，重复前面两个步骤</code>(3)</li>
<li><code>如果没有符合条件的子控件，那么自己就是最合适的控件</code>(4)

<ul>
<li>点击黄色View的查找情况

<ul>
<li>UIApplication->UIWindow->白色View很明显</li>
<li>白色View:满足(1),(2)

<ul>
<li>执行(3)(在子控件数组中，橙色View在绿色View后面)

<ul>
<li>->橙色View:满足(1),(2)

<ul>
<li>执行(3)(红色View后于蓝色View添加，先遍历红色View)

<ul>
<li>->红色View:满足(1),不满足(2)</li>
<li>->蓝色View:满足(1),(2)

<ul>
<li>执行(3)

<ul>
<li>->黄色View:满足(1),(2)

<ul>
<li>执行(3),没有子控件，自己就是最适合的控件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>->绿色View:满足(1),不满足(2)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>UIView<code>不接受触摸</code>的三种情况</p>

<ul>
<li>不使能用户交互<br></li>
</ul>


<pre><code class="objc">userInteractionEnabled = NO
</code></pre>

<ul>
<li>隐藏<br></li>
</ul>


<pre><code class="objc">hidden = YES
</code></pre>

<ul>
<li>透明<br></li>
</ul>


<pre><code class="objc">alpha = 0.0 ~ 0.01
</code></pre>

<ul>
<li>苹果说明<br>
<img src="./image/Snip20150616_1.png" alt="" /></li>
</ul>
</li>
<li><p>寻找最适合控件内部实现</p>

<ul>
<li>寻找最适合控件方法<br>

<ul>
<li>方法内部的默认实现是依次调用子控件的这个方法，直到遍历完自己的子控件然后返回</li>
</ul>


<p>```objc
// 当事件传递给控件的时候[父控件找到子控件，调用子控件的这个方法并传入event参数]，就会调用控件的这个方法，去寻找最合适的view</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event;
```</li>
<li><p>坐标判断和转换<br></p>

<pre><code class="objc">// 将point的值，从调用这个方法的控件坐标系转到view控件    坐标系
- (CGPoint)convertPoint:(CGPoint)point toView:(UIView     *)view;
// 判断事件发生点是否在调用此方法的控件上
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent     *)event;
</code></pre></li>
<li><p>由以上两点信息可以写出<code>寻找最适合控件的内部实现</code> <br></p>

<p>```objc</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event
{
// 1.是否可以响应
if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt; 0.01) {
   return nil;
}</li>
</ul>


<p>  // 2.触摸点是否在控件上
  if ([self pointInside:point withEvent:event] == NO) {
      return nil;
  }</p>

<p>  // 3.递归遍历子控件
  for (int i = (int)self.subviews.count - 1; i >= 0; i&ndash;) {
      UIView *view = self.subviews[i];</p>

<pre><code>  // 将当前控件上的坐标系转换成子控件上的坐标系
  CGPoint childP = [self convertPoint:point toView:view];

  UIView *fitView = [view hitTest:childP withEvent:event];

  if (fitView) {
      // 找到适合的子控件
      return fitView;
  }
</code></pre>

<p>  }</p>

<p>  // 循环结束，表示没有比自己更适合的view
  return self;
}
```</p></li>
</ul>


<h2>事件处理</h2>

<ul>
<li>用户点击屏幕后产生的一个触摸事件，经过一系列的传递过程后，会找到最合适的视图控件来处理这个事件</li>
<li>找到最合适的视图控件后，就会调用<code>对应控件</code>的touches方法来作具体的事件处理

<ul>
<li>touchesBegan…</li>
<li>touchesMoved…</li>
<li>touchedEnded…</li>
<li>如果没有实现以上方法，就传递给父控件</li>
</ul>
</li>
<li>touches方法的<code>默认做法</code>是将事件<code>顺着响应者链条向上传递</code>，将事件交给上一个响应者进行处理

<ul>
<li>所以在相应控件实现了touches方法，就等于拦截了事件，在拦截控件上进行处理</li>
<li>这里<code>注意UIGestureRecognizer的区别</code>，两个并<code>不互相拦截</code>，要想拦截UIGestureRecognizer的手势处理，需要<code>在子控件上添加相同的手势</code>，<code>实现touches方法是没用的</code></li>
</ul>
</li>
</ul>


<h3>响应者链条</h3>

<ul>
<li>响应者链条：是由多个响应者对象连接起来的链条</li>
<li>作用：能很清楚的看见每个响应者之间的联系，并且可以让一个事件多个对象处理。</li>
<li>响应者对象：能处理事件的对象</li>
<li>响应者链条示意图
<img src="./image/Snip20150616_3.png" alt="" />

<ul>
<li>如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图</li>
<li>在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理</li>
<li>如果window对象也不处理，则其将事件或消息传递给UIApplication对象</li>
<li>如果UIApplication也不能处理该事件或消息，则将其丢弃</li>
</ul>
</li>
</ul>


<h2>事件传递的完整过程</h2>

<ul>
<li><p>先将事件对象由上往下传递(由父控件传递给子控件,也就是<code>从底层到顶层</code>)，找到最合适的控件来处理这个事件。</p></li>
<li><p>调用<code>最合适控件的touches….方法</code></p></li>
<li><p>如果调用了<code>[super touches….];</code>就会将事件顺着响应者链条往上传递，传递给上一个响应者［可以做到<code>一个事件多个控件响应</code>］</p>

<ul>
<li>注意，<code>如果这时，父类实现了touches….方法，但是没有调用[super touches….]，就不会传给上一个响应者，而是以父类的touches….方法解决</code>

<ul>
<li>在继承UIButton的时候就需要注意这一点，自定义button调用[super touches….]是不会传递给父控件的，因为UIButton实现了touches….方法，但是没有调用[super touches….]

<ul>
<li><code>UIButton的addTagert:方法会和touches方法冲突</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接着就会调用上一个响应者的touches….方法</p></li>
<li>判断上一个响应者

<ul>
<li>如果<code>当前这个view是控制器的view，那么控制器就是上一个响应者</code></li>
<li>如果<code>当前这个view不是控制器的view，那么父控件就是上一个响应者</code></li>
</ul>
</li>
</ul>


<h2>利用事件传递解决需求</h2>

<ul>
<li><p>实例1<br>
<img src="./image/Snip20150616_4.png" alt="" /></p>

<ul>
<li>需求：在点击到按钮的部分时，需要按钮响应，其他部分由绿色view响应

<ul>
<li>问题：由于部分按钮被绿色view覆盖了，所以点击被覆盖的按钮时，还是绿色view响应</li>
<li>解决：自定义绿色view，添加按钮属性，并重写绿色view的-hitTest:withEvent:方法，在里面判断是否在按钮范围内。<br></li>
</ul>


<pre><code class="objc">// 自定义绿色view
@interface TPCView()
/** 按钮 */
@property (weak, nonatomic) IBOutlet UIButton *button;
@end

@implementation TPCView

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
// 转换成按钮坐标系
CGPoint buttonP = [self convertPoint:point toView:_button];

// 如果点在按钮上，就返回按钮
if ([_button pointInside:buttonP withEvent:event]) {
    return _button;
}

// 其他情况返回本身
return [super hitTest:point withEvent:event];
}
@end
</code></pre></li>
</ul>
</li>
<li><p>实例2</p>

<ul>
<li>开始<br>
<img src="./image/Snip20150616_5.png" alt="" /></li>
<li>点击按钮<br>
<img src="./image/Snip20150616_6.png" alt="" /></li>
<li>点击对话框<br>
<img src="./image/Snip20150616_10.png" alt="" /></li>
<li>需求：点击按钮出现对话框，能对对话框进行点击，并且能对按钮进行拖动（对话框也同时动）</li>
<li>解决：点击按钮时，将对话框设置为按钮的子控件</li>
<li>问题：对话框不在父控件范围内，点击对话框时，无法满足事件传递要求（触摸点不在父控件按钮上，在这里就断了，所以不会去判断其子控件）</li>
<li><p>解决：自定义按钮控件，添加对话框属性，重写按钮的-hitTest:withEvent:方法，在里面判断是否在对话框范围内范围内。<br></p>

<pre><code class="objc">// 控制器中代码
- (IBAction)popChatView:(PopBtn *)sender {
// 弹出对话框
UIButton *chatView = [UIButton buttonWithType:UIButtonTypeCustom];

chatView.bounds = CGRectMake(0, 0, 200, 200);
chatView.center = CGPointMake(100, -100);

[chatView setBackgroundImage:[UIImage imageNamed:@"对话框"] forState:UIControlStateNormal];
[chatView setBackgroundImage:[UIImage imageNamed:@"小孩"] forState:UIControlStateHighlighted];
sender.chatView = chatView;
[sender addSubview:chatView];

}
</code></pre>

<pre><code class="objc">
// 自定义按钮
@implementation PopBtn

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{

// 当前控件上的点转换到chatView上
CGPoint chatP = [self convertPoint:point toView:self.chatView];

// 判断下点在不在chatView上
if ([self.chatView pointInside:chatP withEvent:event]) {
    return self.chatView;
}else{
    return [super hitTest:point withEvent:event];
}

}

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
// 获取UITouch
UITouch *touch = [touches anyObject];

// 获取当前的点
CGPoint curP = [touch locationInView:self];

// 获取上一个的点
CGPoint preP = [touch previousLocationInView:self];

// 获取偏移量
CGFloat offsetX = curP.x - preP.x;
CGFloat OffsetY = curP.y - preP.y;

// 修改控件的位置
CGPoint center = self.center;
center.x += offsetX;
center.y += OffsetY;

self.center = center;

}
@end
</code></pre></li>
</ul>
</li>
<li><p>总结</p>

<ul>
<li>这种情况下，大都是自定义覆盖需要响应控件的控件，或者子控件超出父控件范围的父控件，然后添加对应需要接收响应的控件属性，重写自定义控件的hitTest方法，在里面将触摸点转换成需要接收响应控件的坐标系，判断是否在其坐标系内，再返回对应的控件
/Snip20150616_1.png)</li>
</ul>
</li>
<li><p>寻找最适合控件内部实现</p>

<ul>
<li>寻找最适合控件方法<br>

<ul>
<li>方法内部的默认实现是依次调用子控件的这个方法，直到遍历完自己的子控件然后返回</li>
</ul>


<p>```objc
// 当事件传递给控件的时候[父控件找到子控件，调用子控件的这个方法并传入event参数]，就会调用控件的这个方法，去寻找最合适的view</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event;
```</li>
<li><p>坐标判断和转换<br></p>

<pre><code class="objc">// 将point的值，从调用这个方法的控件坐标系转到view控件    坐标系
- (CGPoint)convertPoint:(CGPoint)point toView:(UIView     *)view;
// 判断事件发生点是否在调用此方法的控件上
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent     *)event;
</code></pre></li>
<li><p>由以上两点信息可以写出<code>寻找最适合控件的内部实现</code> <br></p>

<p>```objc</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event
{
// 1.是否可以响应
if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt; 0.01) {
   return nil;
}</li>
</ul>


<p>  // 2.触摸点是否在控件上
  if ([self pointInside:point withEvent:event] == NO) {
      return nil;
  }</p>

<p>  // 3.递归遍历子控件
  for (int i = (int)self.subviews.count - 1; i >= 0; i&ndash;) {
      UIView *view = self.subviews[i];</p>

<pre><code>  // 将当前控件上的坐标系转换成子控件上的坐标系
  CGPoint childP = [self convertPoint:point toView:view];

  UIView *fitView = [view hitTest:childP withEvent:event];

  if (fitView) {
      // 找到适合的子控件
      return fitView;
  }
</code></pre>

<p>  }</p>

<p>  // 循环结束，表示没有比自己更适合的view
  return self;
}
```</p></li>
</ul>


<h2>事件处理</h2>

<ul>
<li>用户点击屏幕后产生的一个触摸事件，经过一系列的传递过程后，会找到最合适的视图控件来处理这个事件</li>
<li>找到最合适的视图控件后，就会调用<code>对应控件</code>的touches方法来作具体的事件处理

<ul>
<li>touchesBegan…</li>
<li>touchesMoved…</li>
<li>touchedEnded…</li>
<li>如果没有实现以上方法，就传递给父控件</li>
</ul>
</li>
<li>touches方法的<code>默认做法</code>是将事件<code>顺着响应者链条向上传递</code>，将事件交给上一个响应者进行处理

<ul>
<li>所以在相应控件实现了touches方法，就等于拦截了事件，在拦截控件上进行处理</li>
<li>这里<code>注意UIGestureRecognizer的区别</code>，两个并<code>不互相拦截</code>，要想拦截UIGestureRecognizer的手势处理，需要<code>在子控件上添加相同的手势</code>，<code>实现touches方法是没用的</code></li>
</ul>
</li>
</ul>


<h3>响应者链条</h3>

<ul>
<li>响应者链条：是由多个响应者对象连接起来的链条</li>
<li>作用：能很清楚的看见每个响应者之间的联系，并且可以让一个事件多个对象处理。</li>
<li>响应者对象：能处理事件的对象</li>
<li>响应者链条示意图
![](/images</li>
<li>事件传递和触底整体过程

<ul>
<li>发生触摸事件后，系统会将该事件加入到一个由<code>UIApplication管理的事件队列</code>中(<strong>产生</strong>)</li>
<li>UIApplication会从事件队列中取出<code>最前面的事件</code>，并将事件分发下去以便处理，通常，先发送事件给应用程序的<code>主窗口（keyWindow）</code>（<strong>传递</strong>）</li>
<li>主窗口会在视图层次结构中找到一个<code>最合适的视图</code>来处理触摸事件，这也是整个事件处理过程的<code>第一步</code>（<strong>传递</strong>）</li>
<li>找到合适的视图控件后，就会调用<code>视图控件的touches方法</code>来作具体的事件处理（<strong>处理</strong>）</li>
</ul>
</li>
<li>事件<code>传递</code>方向

<ul>
<li>底层->顶层

<ul>
<li>所以<code>父控件不能接收</code>触摸事件时，<code>子控件就不能</code>接收触摸事件</li>
</ul>
</li>
</ul>
</li>
<li>事件<code>处理</code>方向

<ul>
<li>顶层->底层

<ul>
<li>所以在<code>子控件处理</code>了事件，并且<code>没有向父控件传递</code>事件时，<code>父控件就不会处理</code>事件</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>事件传递</h2>

<p><img src="./image/Snip20150616_2.png" alt="" /><br></p>

<ul>
<li>点击绿色View

<ul>
<li>UIApplication->UIWindow->白色View->绿色View</li>
</ul>
</li>
<li>点击黄色View

<ul>
<li>UIApplication->UIWindow->白色View->橙色View->蓝色View->黄色View</li>
</ul>
</li>
<li><p>查找最合适的控件来处理事件</p>

<ul>
<li><code>自己能否接收触摸事件</code>(1)</li>
<li><code>触摸点是否在自己身上</code>(2)</li>
<li><code>从后往前遍历子控件，重复前面两个步骤</code>(3)</li>
<li><code>如果没有符合条件的子控件，那么自己就是最合适的控件</code>(4)

<ul>
<li>点击黄色View的查找情况

<ul>
<li>UIApplication->UIWindow->白色View很明显</li>
<li>白色View:满足(1),(2)

<ul>
<li>执行(3)(在子控件数组中，橙色View在绿色View后面)

<ul>
<li>->橙色View:满足(1),(2)

<ul>
<li>执行(3)(红色View后于蓝色View添加，先遍历红色View)

<ul>
<li>->红色View:满足(1),不满足(2)</li>
<li>->蓝色View:满足(1),(2)

<ul>
<li>执行(3)

<ul>
<li>->黄色View:满足(1),(2)

<ul>
<li>执行(3),没有子控件，自己就是最适合的控件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>->绿色View:满足(1),不满足(2)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>UIView<code>不接受触摸</code>的三种情况</p>

<ul>
<li>不使能用户交互<br></li>
</ul>


<pre><code class="objc">userInteractionEnabled = NO
</code></pre>

<ul>
<li>隐藏<br></li>
</ul>


<pre><code class="objc">hidden = YES
</code></pre>

<ul>
<li>透明<br></li>
</ul>


<pre><code class="objc">alpha = 0.0 ~ 0.01
</code></pre>

<ul>
<li>苹果说明<br>
<img src="./image/Snip20150616_1.png" alt="" /></li>
</ul>
</li>
<li><p>寻找最适合控件内部实现</p>

<ul>
<li>寻找最适合控件方法<br>

<ul>
<li>方法内部的默认实现是依次调用子控件的这个方法，直到遍历完自己的子控件然后返回</li>
</ul>


<p>```objc
// 当事件传递给控件的时候[父控件找到子控件，调用子控件的这个方法并传入event参数]，就会调用控件的这个方法，去寻找最合适的view</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event;
```</li>
<li><p>坐标判断和转换<br></p>

<pre><code class="objc">// 将point的值，从调用这个方法的控件坐标系转到view控件    坐标系
- (CGPoint)convertPoint:(CGPoint)point toView:(UIView     *)view;
// 判断事件发生点是否在调用此方法的控件上
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent     *)event;
</code></pre></li>
<li><p>由以上两点信息可以写出<code>寻找最适合控件的内部实现</code> <br></p>

<p>```objc</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event
{
// 1.是否可以响应
if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt; 0.01) {
   return nil;
}</li>
</ul>


<p>  // 2.触摸点是否在控件上
  if ([self pointInside:point withEvent:event] == NO) {
      return nil;
  }</p>

<p>  // 3.递归遍历子控件
  for (int i = (int)self.subviews.count - 1; i >= 0; i&ndash;) {
      UIView *view = self.subviews[i];</p>

<pre><code>  // 将当前控件上的坐标系转换成子控件上的坐标系
  CGPoint childP = [self convertPoint:point toView:view];

  UIView *fitView = [view hitTest:childP withEvent:event];

  if (fitView) {
      // 找到适合的子控件
      return fitView;
  }
</code></pre>

<p>  }</p>

<p>  // 循环结束，表示没有比自己更适合的view
  return self;
}
```</p></li>
</ul>


<h2>事件处理</h2>

<ul>
<li>用户点击屏幕后产生的一个触摸事件，经过一系列的传递过程后，会找到最合适的视图控件来处理这个事件</li>
<li>找到最合适的视图控件后，就会调用<code>对应控件</code>的touches方法来作具体的事件处理

<ul>
<li>touchesBegan…</li>
<li>touchesMoved…</li>
<li>touchedEnded…</li>
<li>如果没有实现以上方法，就传递给父控件</li>
</ul>
</li>
<li>touches方法的<code>默认做法</code>是将事件<code>顺着响应者链条向上传递</code>，将事件交给上一个响应者进行处理

<ul>
<li>所以在相应控件实现了touches方法，就等于拦截了事件，在拦截控件上进行处理</li>
<li>这里<code>注意UIGestureRecognizer的区别</code>，两个并<code>不互相拦截</code>，要想拦截UIGestureRecognizer的手势处理，需要<code>在子控件上添加相同的手势</code>，<code>实现touches方法是没用的</code></li>
</ul>
</li>
</ul>


<h3>响应者链条</h3>

<ul>
<li>响应者链条：是由多个响应者对象连接起来的链条</li>
<li>作用：能很清楚的看见每个响应者之间的联系，并且可以让一个事件多个对象处理。</li>
<li>响应者对象：能处理事件的对象</li>
<li>响应者链条示意图
<img src="./image/Snip20150616_3.png" alt="" />

<ul>
<li>如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图</li>
<li>在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理</li>
<li>如果window对象也不处理，则其将事件或消息传递给UIApplication对象</li>
<li>如果UIApplication也不能处理该事件或消息，则将其丢弃</li>
</ul>
</li>
</ul>


<h2>事件传递的完整过程</h2>

<ul>
<li><p>先将事件对象由上往下传递(由父控件传递给子控件,也就是<code>从底层到顶层</code>)，找到最合适的控件来处理这个事件。</p></li>
<li><p>调用<code>最合适控件的touches….方法</code></p></li>
<li><p>如果调用了<code>[super touches….];</code>就会将事件顺着响应者链条往上传递，传递给上一个响应者［可以做到<code>一个事件多个控件响应</code>］</p>

<ul>
<li>注意，<code>如果这时，父类实现了touches….方法，但是没有调用[super touches….]，就不会传给上一个响应者，而是以父类的touches….方法解决</code>

<ul>
<li>在继承UIButton的时候就需要注意这一点，自定义button调用[super touches….]是不会传递给父控件的，因为UIButton实现了touches….方法，但是没有调用[super touches….]

<ul>
<li><code>UIButton的addTagert:方法会和touches方法冲突</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接着就会调用上一个响应者的touches….方法</p></li>
<li>判断上一个响应者

<ul>
<li>如果<code>当前这个view是控制器的view，那么控制器就是上一个响应者</code></li>
<li>如果<code>当前这个view不是控制器的view，那么父控件就是上一个响应者</code></li>
</ul>
</li>
</ul>


<h2>利用事件传递解决需求</h2>

<ul>
<li><p>实例1<br>
<img src="./image/Snip20150616_4.png" alt="" /></p>

<ul>
<li>需求：在点击到按钮的部分时，需要按钮响应，其他部分由绿色view响应

<ul>
<li>问题：由于部分按钮被绿色view覆盖了，所以点击被覆盖的按钮时，还是绿色view响应</li>
<li>解决：自定义绿色view，添加按钮属性，并重写绿色view的-hitTest:withEvent:方法，在里面判断是否在按钮范围内。<br></li>
</ul>


<pre><code class="objc">// 自定义绿色view
@interface TPCView()
/** 按钮 */
@property (weak, nonatomic) IBOutlet UIButton *button;
@end

@implementation TPCView

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
// 转换成按钮坐标系
CGPoint buttonP = [self convertPoint:point toView:_button];

// 如果点在按钮上，就返回按钮
if ([_button pointInside:buttonP withEvent:event]) {
    return _button;
}

// 其他情况返回本身
return [super hitTest:point withEvent:event];
}
@end
</code></pre></li>
</ul>
</li>
<li><p>实例2</p>

<ul>
<li>开始<br>
<img src="./image/Snip20150616_5.png" alt="" /></li>
<li>点击按钮<br>
<img src="./image/Snip20150616_6.png" alt="" /></li>
<li>点击对话框<br>
<img src="./image/Snip20150616_10.png" alt="" /></li>
<li>需求：点击按钮出现对话框，能对对话框进行点击，并且能对按钮进行拖动（对话框也同时动）</li>
<li>解决：点击按钮时，将对话框设置为按钮的子控件</li>
<li>问题：对话框不在父控件范围内，点击对话框时，无法满足事件传递要求（触摸点不在父控件按钮上，在这里就断了，所以不会去判断其子控件）</li>
<li><p>解决：自定义按钮控件，添加对话框属性，重写按钮的-hitTest:withEvent:方法，在里面判断是否在对话框范围内范围内。<br></p>

<pre><code class="objc">// 控制器中代码
- (IBAction)popChatView:(PopBtn *)sender {
// 弹出对话框
UIButton *chatView = [UIButton buttonWithType:UIButtonTypeCustom];

chatView.bounds = CGRectMake(0, 0, 200, 200);
chatView.center = CGPointMake(100, -100);

[chatView setBackgroundImage:[UIImage imageNamed:@"对话框"] forState:UIControlStateNormal];
[chatView setBackgroundImage:[UIImage imageNamed:@"小孩"] forState:UIControlStateHighlighted];
sender.chatView = chatView;
[sender addSubview:chatView];

}
</code></pre>

<pre><code class="objc">
// 自定义按钮
@implementation PopBtn

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{

// 当前控件上的点转换到chatView上
CGPoint chatP = [self convertPoint:point toView:self.chatView];

// 判断下点在不在chatView上
if ([self.chatView pointInside:chatP withEvent:event]) {
    return self.chatView;
}else{
    return [super hitTest:point withEvent:event];
}

}

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
// 获取UITouch
UITouch *touch = [touches anyObject];

// 获取当前的点
CGPoint curP = [touch locationInView:self];

// 获取上一个的点
CGPoint preP = [touch previousLocationInView:self];

// 获取偏移量
CGFloat offsetX = curP.x - preP.x;
CGFloat OffsetY = curP.y - preP.y;

// 修改控件的位置
CGPoint center = self.center;
center.x += offsetX;
center.y += OffsetY;

self.center = center;

}
@end
</code></pre></li>
</ul>
</li>
<li>总结

<ul>
<li>这种情况下，大都是自定义覆盖需要响应控件的控件，或者子控件超出父控件范围的父控件，然后添加对应需要接收响应的控件属性，重写自定义控件的hitTest方法，在里面将触摸点转换成需要接收响应控件的坐标系，判断是否在其坐标系内，再返回对应的控件

<h1>eventstransmitandhandle</h1></li>
</ul>
</li>
<li>事件传递和触底整体过程

<ul>
<li>发生触摸事件后，系统会将该事件加入到一个由<code>UIApplication管理的事件队列</code>中(<strong>产生</strong>)</li>
<li>UIApplication会从事件队列中取出<code>最前面的事件</code>，并将事件分发下去以便处理，通常，先发送事件给应用程序的<code>主窗口（keyWindow）</code>（<strong>传递</strong>）</li>
<li>主窗口会在视图层次结构中找到一个<code>最合适的视图</code>来处理触摸事件，这也是整个事件处理过程的<code>第一步</code>（<strong>传递</strong>）</li>
<li>找到合适的视图控件后，就会调用<code>视图控件的touches方法</code>来作具体的事件处理（<strong>处理</strong>）</li>
</ul>
</li>
<li>事件<code>传递</code>方向

<ul>
<li>底层->顶层

<ul>
<li>所以<code>父控件不能接收</code>触摸事件时，<code>子控件就不能</code>接收触摸事件</li>
</ul>
</li>
</ul>
</li>
<li>事件<code>处理</code>方向

<ul>
<li>顶层->底层

<ul>
<li>所以在<code>子控件处理</code>了事件，并且<code>没有向父控件传递</code>事件时，<code>父控件就不会处理</code>事件</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>事件传递</h2>

<p><img src="./image/Snip20150616_2.png" alt="" /><br></p>

<ul>
<li>点击绿色View

<ul>
<li>UIApplication->UIWindow->白色View->绿色View</li>
</ul>
</li>
<li>点击黄色View

<ul>
<li>UIApplication->UIWindow->白色View->橙色View->蓝色View->黄色View</li>
</ul>
</li>
<li><p>查找最合适的控件来处理事件</p>

<ul>
<li><code>自己能否接收触摸事件</code>(1)</li>
<li><code>触摸点是否在自己身上</code>(2)</li>
<li><code>从后往前遍历子控件，重复前面两个步骤</code>(3)</li>
<li><code>如果没有符合条件的子控件，那么自己就是最合适的控件</code>(4)

<ul>
<li>点击黄色View的查找情况

<ul>
<li>UIApplication->UIWindow->白色View很明显</li>
<li>白色View:满足(1),(2)

<ul>
<li>执行(3)(在子控件数组中，橙色View在绿色View后面)

<ul>
<li>->橙色View:满足(1),(2)

<ul>
<li>执行(3)(红色View后于蓝色View添加，先遍历红色View)

<ul>
<li>->红色View:满足(1),不满足(2)</li>
<li>->蓝色View:满足(1),(2)

<ul>
<li>执行(3)

<ul>
<li>->黄色View:满足(1),(2)

<ul>
<li>执行(3),没有子控件，自己就是最适合的控件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>->绿色View:满足(1),不满足(2)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>UIView<code>不接受触摸</code>的三种情况</p>

<ul>
<li>不使能用户交互<br></li>
</ul>


<pre><code class="objc">userInteractionEnabled = NO
</code></pre>

<ul>
<li>隐藏<br></li>
</ul>


<pre><code class="objc">hidden = YES
</code></pre>

<ul>
<li>透明<br></li>
</ul>


<pre><code class="objc">alpha = 0.0 ~ 0.01
</code></pre>

<ul>
<li>苹果说明<br>
<img src="./image/Snip20150616_1.png" alt="" /></li>
</ul>
</li>
<li><p>寻找最适合控件内部实现</p>

<ul>
<li>寻找最适合控件方法<br>

<ul>
<li>方法内部的默认实现是依次调用子控件的这个方法，直到遍历完自己的子控件然后返回</li>
</ul>


<p>```objc
// 当事件传递给控件的时候[父控件找到子控件，调用子控件的这个方法并传入event参数]，就会调用控件的这个方法，去寻找最合适的view</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event;
```</li>
<li><p>坐标判断和转换<br></p>

<pre><code class="objc">// 将point的值，从调用这个方法的控件坐标系转到view控件    坐标系
- (CGPoint)convertPoint:(CGPoint)point toView:(UIView     *)view;
// 判断事件发生点是否在调用此方法的控件上
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent     *)event;
</code></pre></li>
<li><p>由以上两点信息可以写出<code>寻找最适合控件的内部实现</code> <br></p>

<p>```objc</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event
{
// 1.是否可以响应
if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt; 0.01) {
   return nil;
}</li>
</ul>


<p>  // 2.触摸点是否在控件上
  if ([self pointInside:point withEvent:event] == NO) {
      return nil;
  }</p>

<p>  // 3.递归遍历子控件
  for (int i = (int)self.subviews.count - 1; i >= 0; i&ndash;) {
      UIView *view = self.subviews[i];</p>

<pre><code>  // 将当前控件上的坐标系转换成子控件上的坐标系
  CGPoint childP = [self convertPoint:point toView:view];

  UIView *fitView = [view hitTest:childP withEvent:event];

  if (fitView) {
      // 找到适合的子控件
      return fitView;
  }
</code></pre>

<p>  }</p>

<p>  // 循环结束，表示没有比自己更适合的view
  return self;
}
```</p></li>
</ul>


<h2>事件处理</h2>

<ul>
<li>用户点击屏幕后产生的一个触摸事件，经过一系列的传递过程后，会找到最合适的视图控件来处理这个事件</li>
<li>找到最合适的视图控件后，就会调用<code>对应控件</code>的touches方法来作具体的事件处理

<ul>
<li>touchesBegan…</li>
<li>touchesMoved…</li>
<li>touchedEnded…</li>
<li>如果没有实现以上方法，就传递给父控件</li>
</ul>
</li>
<li>touches方法的<code>默认做法</code>是将事件<code>顺着响应者链条向上传递</code>，将事件交给上一个响应者进行处理

<ul>
<li>所以在相应控件实现了touches方法，就等于拦截了事件，在拦截控件上进行处理</li>
<li>这里<code>注意UIGestureRecognizer的区别</code>，两个并<code>不互相拦截</code>，要想拦截UIGestureRecognizer的手势处理，需要<code>在子控件上添加相同的手势</code>，<code>实现touches方法是没用的</code></li>
</ul>
</li>
</ul>


<h3>响应者链条</h3>

<ul>
<li>响应者链条：是由多个响应者对象连接起来的链条</li>
<li>作用：能很清楚的看见每个响应者之间的联系，并且可以让一个事件多个对象处理。</li>
<li>响应者对象：能处理事件的对象</li>
<li>响应者链条示意图
<img src="./image/Snip20150616_3.png" alt="" />

<ul>
<li>如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图</li>
<li>在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理</li>
<li>如果window对象也不处理，则其将事件或消息传递给UIApplication对象</li>
<li>如果UIApplication也不能处理该事件或消息，则将其丢弃</li>
</ul>
</li>
</ul>


<h2>事件传递的完整过程</h2>

<ul>
<li><p>先将事件对象由上往下传递(由父控件传递给子控件,也就是<code>从底层到顶层</code>)，找到最合适的控件来处理这个事件。</p></li>
<li><p>调用<code>最合适控件的touches….方法</code></p></li>
<li><p>如果调用了<code>[super touches….];</code>就会将事件顺着响应者链条往上传递，传递给上一个响应者［可以做到<code>一个事件多个控件响应</code>］</p>

<ul>
<li>注意，<code>如果这时，父类实现了touches….方法，但是没有调用[super touches….]，就不会传给上一个响应者，而是以父类的touches….方法解决</code>

<ul>
<li>在继承UIButton的时候就需要注意这一点，自定义button调用[super touches….]是不会传递给父控件的，因为UIButton实现了touches….方法，但是没有调用[super touches….]

<ul>
<li><code>UIButton的addTagert:方法会和touches方法冲突</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接着就会调用上一个响应者的touches….方法</p></li>
<li>判断上一个响应者

<ul>
<li>如果<code>当前这个view是控制器的view，那么控制器就是上一个响应者</code></li>
<li>如果<code>当前这个view不是控制器的view，那么父控件就是上一个响应者</code></li>
</ul>
</li>
</ul>


<h2>利用事件传递解决需求</h2>

<ul>
<li><p>实例1<br>
<img src="./image/Snip20150616_4.png" alt="" /></p>

<ul>
<li>需求：在点击到按钮的部分时，需要按钮响应，其他部分由绿色view响应

<ul>
<li>问题：由于部分按钮被绿色view覆盖了，所以点击被覆盖的按钮时，还是绿色view响应</li>
<li>解决：自定义绿色view，添加按钮属性，并重写绿色view的-hitTest:withEvent:方法，在里面判断是否在按钮范围内。<br></li>
</ul>


<pre><code class="objc">// 自定义绿色view
@interface TPCView()
/** 按钮 */
@property (weak, nonatomic) IBOutlet UIButton *button;
@end

@implementation TPCView

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
// 转换成按钮坐标系
CGPoint buttonP = [self convertPoint:point toView:_button];

// 如果点在按钮上，就返回按钮
if ([_button pointInside:buttonP withEvent:event]) {
    return _button;
}

// 其他情况返回本身
return [super hitTest:point withEvent:event];
}
@end
</code></pre></li>
</ul>
</li>
<li><p>实例2</p>

<ul>
<li>开始<br>
<img src="./image/Snip20150616_5.png" alt="" /></li>
<li>点击按钮<br>
<img src="./image/Snip20150616_6.png" alt="" /></li>
<li>点击对话框<br>
<img src="./image/Snip20150616_10.png" alt="" /></li>
<li>需求：点击按钮出现对话框，能对对话框进行点击，并且能对按钮进行拖动（对话框也同时动）</li>
<li>解决：点击按钮时，将对话框设置为按钮的子控件</li>
<li>问题：对话框不在父控件范围内，点击对话框时，无法满足事件传递要求（触摸点不在父控件按钮上，在这里就断了，所以不会去判断其子控件）</li>
<li><p>解决：自定义按钮控件，添加对话框属性，重写按钮的-hitTest:withEvent:方法，在里面判断是否在对话框范围内范围内。<br></p>

<pre><code class="objc">// 控制器中代码
- (IBAction)popChatView:(PopBtn *)sender {
// 弹出对话框
UIButton *chatView = [UIButton buttonWithType:UIButtonTypeCustom];

chatView.bounds = CGRectMake(0, 0, 200, 200);
chatView.center = CGPointMake(100, -100);

[chatView setBackgroundImage:[UIImage imageNamed:@"对话框"] forState:UIControlStateNormal];
[chatView setBackgroundImage:[UIImage imageNamed:@"小孩"] forState:UIControlStateHighlighted];
sender.chatView = chatView;
[sender addSubview:chatView];

}
</code></pre>

<pre><code class="objc">
// 自定义按钮
@implementation PopBtn

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{

// 当前控件上的点转换到chatView上
CGPoint chatP = [self convertPoint:point toView:self.chatView];

// 判断下点在不在chatView上
if ([self.chatView pointInside:chatP withEvent:event]) {
    return self.chatView;
}else{
    return [super hitTest:point withEvent:event];
}

}

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
// 获取UITouch
UITouch *touch = [touches anyObject];

// 获取当前的点
CGPoint curP = [touch locationInView:self];

// 获取上一个的点
CGPoint preP = [touch previousLocationInView:self];

// 获取偏移量
CGFloat offsetX = curP.x - preP.x;
CGFloat OffsetY = curP.y - preP.y;

// 修改控件的位置
CGPoint center = self.center;
center.x += offsetX;
center.y += OffsetY;

self.center = center;

}
@end
</code></pre></li>
</ul>
</li>
<li>总结

<ul>
<li>这种情况下，大都是自定义覆盖需要响应控件的控件，或者子控件超出父控件范围的父控件，然后添加对应需要接收响应的控件属性，重写自定义控件的hitTest方法，在里面将触摸点转换成需要接收响应控件的坐标系，判断是否在其坐标系内，再返回对应的控件
/Snip20150616_3.png)</li>
<li>如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图</li>
<li>在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理</li>
<li>如果window对象也不处理，则其将事件或消息传递给UIApplication对象</li>
<li>如果UIApplication也不能处理该事件或消息，则将其丢弃</li>
</ul>
</li>
</ul>


<h2>事件传递的完整过程</h2>

<ul>
<li><p>先将事件对象由上往下传递(由父控件传递给子控件,也就是<code>从底层到顶层</code>)，找到最合适的控件来处理这个事件。</p></li>
<li><p>调用<code>最合适控件的touches….方法</code></p></li>
<li><p>如果调用了<code>[super touches….];</code>就会将事件顺着响应者链条往上传递，传递给上一个响应者［可以做到<code>一个事件多个控件响应</code>］</p>

<ul>
<li>注意，<code>如果这时，父类实现了touches….方法，但是没有调用[super touches….]，就不会传给上一个响应者，而是以父类的touches….方法解决</code>

<ul>
<li>在继承UIButton的时候就需要注意这一点，自定义button调用[super touches….]是不会传递给父控件的，因为UIButton实现了touches….方法，但是没有调用[super touches….]

<ul>
<li><code>UIButton的addTagert:方法会和touches方法冲突</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接着就会调用上一个响应者的touches….方法</p></li>
<li>判断上一个响应者

<ul>
<li>如果<code>当前这个view是控制器的view，那么控制器就是上一个响应者</code></li>
<li>如果<code>当前这个view不是控制器的view，那么父控件就是上一个响应者</code></li>
</ul>
</li>
</ul>


<h2>利用事件传递解决需求</h2>

<ul>
<li>实例1<br>
![](/images</li>
<li>事件传递和触底整体过程

<ul>
<li>发生触摸事件后，系统会将该事件加入到一个由<code>UIApplication管理的事件队列</code>中(<strong>产生</strong>)</li>
<li>UIApplication会从事件队列中取出<code>最前面的事件</code>，并将事件分发下去以便处理，通常，先发送事件给应用程序的<code>主窗口（keyWindow）</code>（<strong>传递</strong>）</li>
<li>主窗口会在视图层次结构中找到一个<code>最合适的视图</code>来处理触摸事件，这也是整个事件处理过程的<code>第一步</code>（<strong>传递</strong>）</li>
<li>找到合适的视图控件后，就会调用<code>视图控件的touches方法</code>来作具体的事件处理（<strong>处理</strong>）</li>
</ul>
</li>
<li>事件<code>传递</code>方向

<ul>
<li>底层->顶层

<ul>
<li>所以<code>父控件不能接收</code>触摸事件时，<code>子控件就不能</code>接收触摸事件</li>
</ul>
</li>
</ul>
</li>
<li>事件<code>处理</code>方向

<ul>
<li>顶层->底层

<ul>
<li>所以在<code>子控件处理</code>了事件，并且<code>没有向父控件传递</code>事件时，<code>父控件就不会处理</code>事件</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>事件传递</h2>

<p><img src="./image/Snip20150616_2.png" alt="" /><br></p>

<ul>
<li>点击绿色View

<ul>
<li>UIApplication->UIWindow->白色View->绿色View</li>
</ul>
</li>
<li>点击黄色View

<ul>
<li>UIApplication->UIWindow->白色View->橙色View->蓝色View->黄色View</li>
</ul>
</li>
<li><p>查找最合适的控件来处理事件</p>

<ul>
<li><code>自己能否接收触摸事件</code>(1)</li>
<li><code>触摸点是否在自己身上</code>(2)</li>
<li><code>从后往前遍历子控件，重复前面两个步骤</code>(3)</li>
<li><code>如果没有符合条件的子控件，那么自己就是最合适的控件</code>(4)

<ul>
<li>点击黄色View的查找情况

<ul>
<li>UIApplication->UIWindow->白色View很明显</li>
<li>白色View:满足(1),(2)

<ul>
<li>执行(3)(在子控件数组中，橙色View在绿色View后面)

<ul>
<li>->橙色View:满足(1),(2)

<ul>
<li>执行(3)(红色View后于蓝色View添加，先遍历红色View)

<ul>
<li>->红色View:满足(1),不满足(2)</li>
<li>->蓝色View:满足(1),(2)

<ul>
<li>执行(3)

<ul>
<li>->黄色View:满足(1),(2)

<ul>
<li>执行(3),没有子控件，自己就是最适合的控件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>->绿色View:满足(1),不满足(2)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>UIView<code>不接受触摸</code>的三种情况</p>

<ul>
<li>不使能用户交互<br></li>
</ul>


<pre><code class="objc">userInteractionEnabled = NO
</code></pre>

<ul>
<li>隐藏<br></li>
</ul>


<pre><code class="objc">hidden = YES
</code></pre>

<ul>
<li>透明<br></li>
</ul>


<pre><code class="objc">alpha = 0.0 ~ 0.01
</code></pre>

<ul>
<li>苹果说明<br>
<img src="./image/Snip20150616_1.png" alt="" /></li>
</ul>
</li>
<li><p>寻找最适合控件内部实现</p>

<ul>
<li>寻找最适合控件方法<br>

<ul>
<li>方法内部的默认实现是依次调用子控件的这个方法，直到遍历完自己的子控件然后返回</li>
</ul>


<p>```objc
// 当事件传递给控件的时候[父控件找到子控件，调用子控件的这个方法并传入event参数]，就会调用控件的这个方法，去寻找最合适的view</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event;
```</li>
<li><p>坐标判断和转换<br></p>

<pre><code class="objc">// 将point的值，从调用这个方法的控件坐标系转到view控件    坐标系
- (CGPoint)convertPoint:(CGPoint)point toView:(UIView     *)view;
// 判断事件发生点是否在调用此方法的控件上
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent     *)event;
</code></pre></li>
<li><p>由以上两点信息可以写出<code>寻找最适合控件的内部实现</code> <br></p>

<p>```objc</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event
{
// 1.是否可以响应
if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt; 0.01) {
   return nil;
}</li>
</ul>


<p>  // 2.触摸点是否在控件上
  if ([self pointInside:point withEvent:event] == NO) {
      return nil;
  }</p>

<p>  // 3.递归遍历子控件
  for (int i = (int)self.subviews.count - 1; i >= 0; i&ndash;) {
      UIView *view = self.subviews[i];</p>

<pre><code>  // 将当前控件上的坐标系转换成子控件上的坐标系
  CGPoint childP = [self convertPoint:point toView:view];

  UIView *fitView = [view hitTest:childP withEvent:event];

  if (fitView) {
      // 找到适合的子控件
      return fitView;
  }
</code></pre>

<p>  }</p>

<p>  // 循环结束，表示没有比自己更适合的view
  return self;
}
```</p></li>
</ul>


<h2>事件处理</h2>

<ul>
<li>用户点击屏幕后产生的一个触摸事件，经过一系列的传递过程后，会找到最合适的视图控件来处理这个事件</li>
<li>找到最合适的视图控件后，就会调用<code>对应控件</code>的touches方法来作具体的事件处理

<ul>
<li>touchesBegan…</li>
<li>touchesMoved…</li>
<li>touchedEnded…</li>
<li>如果没有实现以上方法，就传递给父控件</li>
</ul>
</li>
<li>touches方法的<code>默认做法</code>是将事件<code>顺着响应者链条向上传递</code>，将事件交给上一个响应者进行处理

<ul>
<li>所以在相应控件实现了touches方法，就等于拦截了事件，在拦截控件上进行处理</li>
<li>这里<code>注意UIGestureRecognizer的区别</code>，两个并<code>不互相拦截</code>，要想拦截UIGestureRecognizer的手势处理，需要<code>在子控件上添加相同的手势</code>，<code>实现touches方法是没用的</code></li>
</ul>
</li>
</ul>


<h3>响应者链条</h3>

<ul>
<li>响应者链条：是由多个响应者对象连接起来的链条</li>
<li>作用：能很清楚的看见每个响应者之间的联系，并且可以让一个事件多个对象处理。</li>
<li>响应者对象：能处理事件的对象</li>
<li>响应者链条示意图
<img src="./image/Snip20150616_3.png" alt="" />

<ul>
<li>如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图</li>
<li>在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理</li>
<li>如果window对象也不处理，则其将事件或消息传递给UIApplication对象</li>
<li>如果UIApplication也不能处理该事件或消息，则将其丢弃</li>
</ul>
</li>
</ul>


<h2>事件传递的完整过程</h2>

<ul>
<li><p>先将事件对象由上往下传递(由父控件传递给子控件,也就是<code>从底层到顶层</code>)，找到最合适的控件来处理这个事件。</p></li>
<li><p>调用<code>最合适控件的touches….方法</code></p></li>
<li><p>如果调用了<code>[super touches….];</code>就会将事件顺着响应者链条往上传递，传递给上一个响应者［可以做到<code>一个事件多个控件响应</code>］</p>

<ul>
<li>注意，<code>如果这时，父类实现了touches….方法，但是没有调用[super touches….]，就不会传给上一个响应者，而是以父类的touches….方法解决</code>

<ul>
<li>在继承UIButton的时候就需要注意这一点，自定义button调用[super touches….]是不会传递给父控件的，因为UIButton实现了touches….方法，但是没有调用[super touches….]

<ul>
<li><code>UIButton的addTagert:方法会和touches方法冲突</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接着就会调用上一个响应者的touches….方法</p></li>
<li>判断上一个响应者

<ul>
<li>如果<code>当前这个view是控制器的view，那么控制器就是上一个响应者</code></li>
<li>如果<code>当前这个view不是控制器的view，那么父控件就是上一个响应者</code></li>
</ul>
</li>
</ul>


<h2>利用事件传递解决需求</h2>

<ul>
<li><p>实例1<br>
<img src="./image/Snip20150616_4.png" alt="" /></p>

<ul>
<li>需求：在点击到按钮的部分时，需要按钮响应，其他部分由绿色view响应

<ul>
<li>问题：由于部分按钮被绿色view覆盖了，所以点击被覆盖的按钮时，还是绿色view响应</li>
<li>解决：自定义绿色view，添加按钮属性，并重写绿色view的-hitTest:withEvent:方法，在里面判断是否在按钮范围内。<br></li>
</ul>


<pre><code class="objc">// 自定义绿色view
@interface TPCView()
/** 按钮 */
@property (weak, nonatomic) IBOutlet UIButton *button;
@end

@implementation TPCView

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
// 转换成按钮坐标系
CGPoint buttonP = [self convertPoint:point toView:_button];

// 如果点在按钮上，就返回按钮
if ([_button pointInside:buttonP withEvent:event]) {
    return _button;
}

// 其他情况返回本身
return [super hitTest:point withEvent:event];
}
@end
</code></pre></li>
</ul>
</li>
<li><p>实例2</p>

<ul>
<li>开始<br>
<img src="./image/Snip20150616_5.png" alt="" /></li>
<li>点击按钮<br>
<img src="./image/Snip20150616_6.png" alt="" /></li>
<li>点击对话框<br>
<img src="./image/Snip20150616_10.png" alt="" /></li>
<li>需求：点击按钮出现对话框，能对对话框进行点击，并且能对按钮进行拖动（对话框也同时动）</li>
<li>解决：点击按钮时，将对话框设置为按钮的子控件</li>
<li>问题：对话框不在父控件范围内，点击对话框时，无法满足事件传递要求（触摸点不在父控件按钮上，在这里就断了，所以不会去判断其子控件）</li>
<li><p>解决：自定义按钮控件，添加对话框属性，重写按钮的-hitTest:withEvent:方法，在里面判断是否在对话框范围内范围内。<br></p>

<pre><code class="objc">// 控制器中代码
- (IBAction)popChatView:(PopBtn *)sender {
// 弹出对话框
UIButton *chatView = [UIButton buttonWithType:UIButtonTypeCustom];

chatView.bounds = CGRectMake(0, 0, 200, 200);
chatView.center = CGPointMake(100, -100);

[chatView setBackgroundImage:[UIImage imageNamed:@"对话框"] forState:UIControlStateNormal];
[chatView setBackgroundImage:[UIImage imageNamed:@"小孩"] forState:UIControlStateHighlighted];
sender.chatView = chatView;
[sender addSubview:chatView];

}
</code></pre>

<pre><code class="objc">
// 自定义按钮
@implementation PopBtn

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{

// 当前控件上的点转换到chatView上
CGPoint chatP = [self convertPoint:point toView:self.chatView];

// 判断下点在不在chatView上
if ([self.chatView pointInside:chatP withEvent:event]) {
    return self.chatView;
}else{
    return [super hitTest:point withEvent:event];
}

}

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
// 获取UITouch
UITouch *touch = [touches anyObject];

// 获取当前的点
CGPoint curP = [touch locationInView:self];

// 获取上一个的点
CGPoint preP = [touch previousLocationInView:self];

// 获取偏移量
CGFloat offsetX = curP.x - preP.x;
CGFloat OffsetY = curP.y - preP.y;

// 修改控件的位置
CGPoint center = self.center;
center.x += offsetX;
center.y += OffsetY;

self.center = center;

}
@end
</code></pre></li>
</ul>
</li>
<li>总结

<ul>
<li>这种情况下，大都是自定义覆盖需要响应控件的控件，或者子控件超出父控件范围的父控件，然后添加对应需要接收响应的控件属性，重写自定义控件的hitTest方法，在里面将触摸点转换成需要接收响应控件的坐标系，判断是否在其坐标系内，再返回对应的控件

<h1>eventstransmitandhandle</h1></li>
</ul>
</li>
<li>事件传递和触底整体过程

<ul>
<li>发生触摸事件后，系统会将该事件加入到一个由<code>UIApplication管理的事件队列</code>中(<strong>产生</strong>)</li>
<li>UIApplication会从事件队列中取出<code>最前面的事件</code>，并将事件分发下去以便处理，通常，先发送事件给应用程序的<code>主窗口（keyWindow）</code>（<strong>传递</strong>）</li>
<li>主窗口会在视图层次结构中找到一个<code>最合适的视图</code>来处理触摸事件，这也是整个事件处理过程的<code>第一步</code>（<strong>传递</strong>）</li>
<li>找到合适的视图控件后，就会调用<code>视图控件的touches方法</code>来作具体的事件处理（<strong>处理</strong>）</li>
</ul>
</li>
<li>事件<code>传递</code>方向

<ul>
<li>底层->顶层

<ul>
<li>所以<code>父控件不能接收</code>触摸事件时，<code>子控件就不能</code>接收触摸事件</li>
</ul>
</li>
</ul>
</li>
<li>事件<code>处理</code>方向

<ul>
<li>顶层->底层

<ul>
<li>所以在<code>子控件处理</code>了事件，并且<code>没有向父控件传递</code>事件时，<code>父控件就不会处理</code>事件</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>事件传递</h2>

<p><img src="./image/Snip20150616_2.png" alt="" /><br></p>

<ul>
<li>点击绿色View

<ul>
<li>UIApplication->UIWindow->白色View->绿色View</li>
</ul>
</li>
<li>点击黄色View

<ul>
<li>UIApplication->UIWindow->白色View->橙色View->蓝色View->黄色View</li>
</ul>
</li>
<li><p>查找最合适的控件来处理事件</p>

<ul>
<li><code>自己能否接收触摸事件</code>(1)</li>
<li><code>触摸点是否在自己身上</code>(2)</li>
<li><code>从后往前遍历子控件，重复前面两个步骤</code>(3)</li>
<li><code>如果没有符合条件的子控件，那么自己就是最合适的控件</code>(4)

<ul>
<li>点击黄色View的查找情况

<ul>
<li>UIApplication->UIWindow->白色View很明显</li>
<li>白色View:满足(1),(2)

<ul>
<li>执行(3)(在子控件数组中，橙色View在绿色View后面)

<ul>
<li>->橙色View:满足(1),(2)

<ul>
<li>执行(3)(红色View后于蓝色View添加，先遍历红色View)

<ul>
<li>->红色View:满足(1),不满足(2)</li>
<li>->蓝色View:满足(1),(2)

<ul>
<li>执行(3)

<ul>
<li>->黄色View:满足(1),(2)

<ul>
<li>执行(3),没有子控件，自己就是最适合的控件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>->绿色View:满足(1),不满足(2)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>UIView<code>不接受触摸</code>的三种情况</p>

<ul>
<li>不使能用户交互<br></li>
</ul>


<pre><code class="objc">userInteractionEnabled = NO
</code></pre>

<ul>
<li>隐藏<br></li>
</ul>


<pre><code class="objc">hidden = YES
</code></pre>

<ul>
<li>透明<br></li>
</ul>


<pre><code class="objc">alpha = 0.0 ~ 0.01
</code></pre>

<ul>
<li>苹果说明<br>
<img src="./image/Snip20150616_1.png" alt="" /></li>
</ul>
</li>
<li><p>寻找最适合控件内部实现</p>

<ul>
<li>寻找最适合控件方法<br>

<ul>
<li>方法内部的默认实现是依次调用子控件的这个方法，直到遍历完自己的子控件然后返回</li>
</ul>


<p>```objc
// 当事件传递给控件的时候[父控件找到子控件，调用子控件的这个方法并传入event参数]，就会调用控件的这个方法，去寻找最合适的view</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event;
```</li>
<li><p>坐标判断和转换<br></p>

<pre><code class="objc">// 将point的值，从调用这个方法的控件坐标系转到view控件    坐标系
- (CGPoint)convertPoint:(CGPoint)point toView:(UIView     *)view;
// 判断事件发生点是否在调用此方法的控件上
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent     *)event;
</code></pre></li>
<li><p>由以上两点信息可以写出<code>寻找最适合控件的内部实现</code> <br></p>

<p>```objc</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event
{
// 1.是否可以响应
if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt; 0.01) {
   return nil;
}</li>
</ul>


<p>  // 2.触摸点是否在控件上
  if ([self pointInside:point withEvent:event] == NO) {
      return nil;
  }</p>

<p>  // 3.递归遍历子控件
  for (int i = (int)self.subviews.count - 1; i >= 0; i&ndash;) {
      UIView *view = self.subviews[i];</p>

<pre><code>  // 将当前控件上的坐标系转换成子控件上的坐标系
  CGPoint childP = [self convertPoint:point toView:view];

  UIView *fitView = [view hitTest:childP withEvent:event];

  if (fitView) {
      // 找到适合的子控件
      return fitView;
  }
</code></pre>

<p>  }</p>

<p>  // 循环结束，表示没有比自己更适合的view
  return self;
}
```</p></li>
</ul>


<h2>事件处理</h2>

<ul>
<li>用户点击屏幕后产生的一个触摸事件，经过一系列的传递过程后，会找到最合适的视图控件来处理这个事件</li>
<li>找到最合适的视图控件后，就会调用<code>对应控件</code>的touches方法来作具体的事件处理

<ul>
<li>touchesBegan…</li>
<li>touchesMoved…</li>
<li>touchedEnded…</li>
<li>如果没有实现以上方法，就传递给父控件</li>
</ul>
</li>
<li>touches方法的<code>默认做法</code>是将事件<code>顺着响应者链条向上传递</code>，将事件交给上一个响应者进行处理

<ul>
<li>所以在相应控件实现了touches方法，就等于拦截了事件，在拦截控件上进行处理</li>
<li>这里<code>注意UIGestureRecognizer的区别</code>，两个并<code>不互相拦截</code>，要想拦截UIGestureRecognizer的手势处理，需要<code>在子控件上添加相同的手势</code>，<code>实现touches方法是没用的</code></li>
</ul>
</li>
</ul>


<h3>响应者链条</h3>

<ul>
<li>响应者链条：是由多个响应者对象连接起来的链条</li>
<li>作用：能很清楚的看见每个响应者之间的联系，并且可以让一个事件多个对象处理。</li>
<li>响应者对象：能处理事件的对象</li>
<li>响应者链条示意图
<img src="./image/Snip20150616_3.png" alt="" />

<ul>
<li>如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图</li>
<li>在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理</li>
<li>如果window对象也不处理，则其将事件或消息传递给UIApplication对象</li>
<li>如果UIApplication也不能处理该事件或消息，则将其丢弃</li>
</ul>
</li>
</ul>


<h2>事件传递的完整过程</h2>

<ul>
<li><p>先将事件对象由上往下传递(由父控件传递给子控件,也就是<code>从底层到顶层</code>)，找到最合适的控件来处理这个事件。</p></li>
<li><p>调用<code>最合适控件的touches….方法</code></p></li>
<li><p>如果调用了<code>[super touches….];</code>就会将事件顺着响应者链条往上传递，传递给上一个响应者［可以做到<code>一个事件多个控件响应</code>］</p>

<ul>
<li>注意，<code>如果这时，父类实现了touches….方法，但是没有调用[super touches….]，就不会传给上一个响应者，而是以父类的touches….方法解决</code>

<ul>
<li>在继承UIButton的时候就需要注意这一点，自定义button调用[super touches….]是不会传递给父控件的，因为UIButton实现了touches….方法，但是没有调用[super touches….]

<ul>
<li><code>UIButton的addTagert:方法会和touches方法冲突</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接着就会调用上一个响应者的touches….方法</p></li>
<li>判断上一个响应者

<ul>
<li>如果<code>当前这个view是控制器的view，那么控制器就是上一个响应者</code></li>
<li>如果<code>当前这个view不是控制器的view，那么父控件就是上一个响应者</code></li>
</ul>
</li>
</ul>


<h2>利用事件传递解决需求</h2>

<ul>
<li><p>实例1<br>
<img src="./image/Snip20150616_4.png" alt="" /></p>

<ul>
<li>需求：在点击到按钮的部分时，需要按钮响应，其他部分由绿色view响应

<ul>
<li>问题：由于部分按钮被绿色view覆盖了，所以点击被覆盖的按钮时，还是绿色view响应</li>
<li>解决：自定义绿色view，添加按钮属性，并重写绿色view的-hitTest:withEvent:方法，在里面判断是否在按钮范围内。<br></li>
</ul>


<pre><code class="objc">// 自定义绿色view
@interface TPCView()
/** 按钮 */
@property (weak, nonatomic) IBOutlet UIButton *button;
@end

@implementation TPCView

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
// 转换成按钮坐标系
CGPoint buttonP = [self convertPoint:point toView:_button];

// 如果点在按钮上，就返回按钮
if ([_button pointInside:buttonP withEvent:event]) {
    return _button;
}

// 其他情况返回本身
return [super hitTest:point withEvent:event];
}
@end
</code></pre></li>
</ul>
</li>
<li><p>实例2</p>

<ul>
<li>开始<br>
<img src="./image/Snip20150616_5.png" alt="" /></li>
<li>点击按钮<br>
<img src="./image/Snip20150616_6.png" alt="" /></li>
<li>点击对话框<br>
<img src="./image/Snip20150616_10.png" alt="" /></li>
<li>需求：点击按钮出现对话框，能对对话框进行点击，并且能对按钮进行拖动（对话框也同时动）</li>
<li>解决：点击按钮时，将对话框设置为按钮的子控件</li>
<li>问题：对话框不在父控件范围内，点击对话框时，无法满足事件传递要求（触摸点不在父控件按钮上，在这里就断了，所以不会去判断其子控件）</li>
<li><p>解决：自定义按钮控件，添加对话框属性，重写按钮的-hitTest:withEvent:方法，在里面判断是否在对话框范围内范围内。<br></p>

<pre><code class="objc">// 控制器中代码
- (IBAction)popChatView:(PopBtn *)sender {
// 弹出对话框
UIButton *chatView = [UIButton buttonWithType:UIButtonTypeCustom];

chatView.bounds = CGRectMake(0, 0, 200, 200);
chatView.center = CGPointMake(100, -100);

[chatView setBackgroundImage:[UIImage imageNamed:@"对话框"] forState:UIControlStateNormal];
[chatView setBackgroundImage:[UIImage imageNamed:@"小孩"] forState:UIControlStateHighlighted];
sender.chatView = chatView;
[sender addSubview:chatView];

}
</code></pre>

<pre><code class="objc">
// 自定义按钮
@implementation PopBtn

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{

// 当前控件上的点转换到chatView上
CGPoint chatP = [self convertPoint:point toView:self.chatView];

// 判断下点在不在chatView上
if ([self.chatView pointInside:chatP withEvent:event]) {
    return self.chatView;
}else{
    return [super hitTest:point withEvent:event];
}

}

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
// 获取UITouch
UITouch *touch = [touches anyObject];

// 获取当前的点
CGPoint curP = [touch locationInView:self];

// 获取上一个的点
CGPoint preP = [touch previousLocationInView:self];

// 获取偏移量
CGFloat offsetX = curP.x - preP.x;
CGFloat OffsetY = curP.y - preP.y;

// 修改控件的位置
CGPoint center = self.center;
center.x += offsetX;
center.y += OffsetY;

self.center = center;

}
@end
</code></pre></li>
</ul>
</li>
<li><p>总结</p>

<ul>
<li>这种情况下，大都是自定义覆盖需要响应控件的控件，或者子控件超出父控件范围的父控件，然后添加对应需要接收响应的控件属性，重写自定义控件的hitTest方法，在里面将触摸点转换成需要接收响应控件的坐标系，判断是否在其坐标系内，再返回对应的控件
/Snip20150616_4.png)</li>
<li>需求：在点击到按钮的部分时，需要按钮响应，其他部分由绿色view响应

<ul>
<li>问题：由于部分按钮被绿色view覆盖了，所以点击被覆盖的按钮时，还是绿色view响应</li>
<li>解决：自定义绿色view，添加按钮属性，并重写绿色view的-hitTest:withEvent:方法，在里面判断是否在按钮范围内。<br></li>
</ul>


<pre><code class="objc">// 自定义绿色view
@interface TPCView()
/** 按钮 */
@property (weak, nonatomic) IBOutlet UIButton *button;
@end

@implementation TPCView

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
// 转换成按钮坐标系
CGPoint buttonP = [self convertPoint:point toView:_button];

// 如果点在按钮上，就返回按钮
if ([_button pointInside:buttonP withEvent:event]) {
    return _button;
}

// 其他情况返回本身
return [super hitTest:point withEvent:event];
}
@end
</code></pre></li>
</ul>
</li>
<li><p>实例2</p>

<ul>
<li>开始<br>
![](/images</li>
</ul>
</li>
<li>事件传递和触底整体过程

<ul>
<li>发生触摸事件后，系统会将该事件加入到一个由<code>UIApplication管理的事件队列</code>中(<strong>产生</strong>)</li>
<li>UIApplication会从事件队列中取出<code>最前面的事件</code>，并将事件分发下去以便处理，通常，先发送事件给应用程序的<code>主窗口（keyWindow）</code>（<strong>传递</strong>）</li>
<li>主窗口会在视图层次结构中找到一个<code>最合适的视图</code>来处理触摸事件，这也是整个事件处理过程的<code>第一步</code>（<strong>传递</strong>）</li>
<li>找到合适的视图控件后，就会调用<code>视图控件的touches方法</code>来作具体的事件处理（<strong>处理</strong>）</li>
</ul>
</li>
<li>事件<code>传递</code>方向

<ul>
<li>底层->顶层

<ul>
<li>所以<code>父控件不能接收</code>触摸事件时，<code>子控件就不能</code>接收触摸事件</li>
</ul>
</li>
</ul>
</li>
<li>事件<code>处理</code>方向

<ul>
<li>顶层->底层

<ul>
<li>所以在<code>子控件处理</code>了事件，并且<code>没有向父控件传递</code>事件时，<code>父控件就不会处理</code>事件</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>事件传递</h2>

<p><img src="./image/Snip20150616_2.png" alt="" /><br></p>

<ul>
<li>点击绿色View

<ul>
<li>UIApplication->UIWindow->白色View->绿色View</li>
</ul>
</li>
<li>点击黄色View

<ul>
<li>UIApplication->UIWindow->白色View->橙色View->蓝色View->黄色View</li>
</ul>
</li>
<li><p>查找最合适的控件来处理事件</p>

<ul>
<li><code>自己能否接收触摸事件</code>(1)</li>
<li><code>触摸点是否在自己身上</code>(2)</li>
<li><code>从后往前遍历子控件，重复前面两个步骤</code>(3)</li>
<li><code>如果没有符合条件的子控件，那么自己就是最合适的控件</code>(4)

<ul>
<li>点击黄色View的查找情况

<ul>
<li>UIApplication->UIWindow->白色View很明显</li>
<li>白色View:满足(1),(2)

<ul>
<li>执行(3)(在子控件数组中，橙色View在绿色View后面)

<ul>
<li>->橙色View:满足(1),(2)

<ul>
<li>执行(3)(红色View后于蓝色View添加，先遍历红色View)

<ul>
<li>->红色View:满足(1),不满足(2)</li>
<li>->蓝色View:满足(1),(2)

<ul>
<li>执行(3)

<ul>
<li>->黄色View:满足(1),(2)

<ul>
<li>执行(3),没有子控件，自己就是最适合的控件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>->绿色View:满足(1),不满足(2)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>UIView<code>不接受触摸</code>的三种情况</p>

<ul>
<li>不使能用户交互<br></li>
</ul>


<pre><code class="objc">userInteractionEnabled = NO
</code></pre>

<ul>
<li>隐藏<br></li>
</ul>


<pre><code class="objc">hidden = YES
</code></pre>

<ul>
<li>透明<br></li>
</ul>


<pre><code class="objc">alpha = 0.0 ~ 0.01
</code></pre>

<ul>
<li>苹果说明<br>
<img src="./image/Snip20150616_1.png" alt="" /></li>
</ul>
</li>
<li><p>寻找最适合控件内部实现</p>

<ul>
<li>寻找最适合控件方法<br>

<ul>
<li>方法内部的默认实现是依次调用子控件的这个方法，直到遍历完自己的子控件然后返回</li>
</ul>


<p>```objc
// 当事件传递给控件的时候[父控件找到子控件，调用子控件的这个方法并传入event参数]，就会调用控件的这个方法，去寻找最合适的view</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event;
```</li>
<li><p>坐标判断和转换<br></p>

<pre><code class="objc">// 将point的值，从调用这个方法的控件坐标系转到view控件    坐标系
- (CGPoint)convertPoint:(CGPoint)point toView:(UIView     *)view;
// 判断事件发生点是否在调用此方法的控件上
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent     *)event;
</code></pre></li>
<li><p>由以上两点信息可以写出<code>寻找最适合控件的内部实现</code> <br></p>

<p>```objc</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event
{
// 1.是否可以响应
if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt; 0.01) {
   return nil;
}</li>
</ul>


<p>  // 2.触摸点是否在控件上
  if ([self pointInside:point withEvent:event] == NO) {
      return nil;
  }</p>

<p>  // 3.递归遍历子控件
  for (int i = (int)self.subviews.count - 1; i >= 0; i&ndash;) {
      UIView *view = self.subviews[i];</p>

<pre><code>  // 将当前控件上的坐标系转换成子控件上的坐标系
  CGPoint childP = [self convertPoint:point toView:view];

  UIView *fitView = [view hitTest:childP withEvent:event];

  if (fitView) {
      // 找到适合的子控件
      return fitView;
  }
</code></pre>

<p>  }</p>

<p>  // 循环结束，表示没有比自己更适合的view
  return self;
}
```</p></li>
</ul>


<h2>事件处理</h2>

<ul>
<li>用户点击屏幕后产生的一个触摸事件，经过一系列的传递过程后，会找到最合适的视图控件来处理这个事件</li>
<li>找到最合适的视图控件后，就会调用<code>对应控件</code>的touches方法来作具体的事件处理

<ul>
<li>touchesBegan…</li>
<li>touchesMoved…</li>
<li>touchedEnded…</li>
<li>如果没有实现以上方法，就传递给父控件</li>
</ul>
</li>
<li>touches方法的<code>默认做法</code>是将事件<code>顺着响应者链条向上传递</code>，将事件交给上一个响应者进行处理

<ul>
<li>所以在相应控件实现了touches方法，就等于拦截了事件，在拦截控件上进行处理</li>
<li>这里<code>注意UIGestureRecognizer的区别</code>，两个并<code>不互相拦截</code>，要想拦截UIGestureRecognizer的手势处理，需要<code>在子控件上添加相同的手势</code>，<code>实现touches方法是没用的</code></li>
</ul>
</li>
</ul>


<h3>响应者链条</h3>

<ul>
<li>响应者链条：是由多个响应者对象连接起来的链条</li>
<li>作用：能很清楚的看见每个响应者之间的联系，并且可以让一个事件多个对象处理。</li>
<li>响应者对象：能处理事件的对象</li>
<li>响应者链条示意图
<img src="./image/Snip20150616_3.png" alt="" />

<ul>
<li>如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图</li>
<li>在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理</li>
<li>如果window对象也不处理，则其将事件或消息传递给UIApplication对象</li>
<li>如果UIApplication也不能处理该事件或消息，则将其丢弃</li>
</ul>
</li>
</ul>


<h2>事件传递的完整过程</h2>

<ul>
<li><p>先将事件对象由上往下传递(由父控件传递给子控件,也就是<code>从底层到顶层</code>)，找到最合适的控件来处理这个事件。</p></li>
<li><p>调用<code>最合适控件的touches….方法</code></p></li>
<li><p>如果调用了<code>[super touches….];</code>就会将事件顺着响应者链条往上传递，传递给上一个响应者［可以做到<code>一个事件多个控件响应</code>］</p>

<ul>
<li>注意，<code>如果这时，父类实现了touches….方法，但是没有调用[super touches….]，就不会传给上一个响应者，而是以父类的touches….方法解决</code>

<ul>
<li>在继承UIButton的时候就需要注意这一点，自定义button调用[super touches….]是不会传递给父控件的，因为UIButton实现了touches….方法，但是没有调用[super touches….]

<ul>
<li><code>UIButton的addTagert:方法会和touches方法冲突</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接着就会调用上一个响应者的touches….方法</p></li>
<li>判断上一个响应者

<ul>
<li>如果<code>当前这个view是控制器的view，那么控制器就是上一个响应者</code></li>
<li>如果<code>当前这个view不是控制器的view，那么父控件就是上一个响应者</code></li>
</ul>
</li>
</ul>


<h2>利用事件传递解决需求</h2>

<ul>
<li><p>实例1<br>
<img src="./image/Snip20150616_4.png" alt="" /></p>

<ul>
<li>需求：在点击到按钮的部分时，需要按钮响应，其他部分由绿色view响应

<ul>
<li>问题：由于部分按钮被绿色view覆盖了，所以点击被覆盖的按钮时，还是绿色view响应</li>
<li>解决：自定义绿色view，添加按钮属性，并重写绿色view的-hitTest:withEvent:方法，在里面判断是否在按钮范围内。<br></li>
</ul>


<pre><code class="objc">// 自定义绿色view
@interface TPCView()
/** 按钮 */
@property (weak, nonatomic) IBOutlet UIButton *button;
@end

@implementation TPCView

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
// 转换成按钮坐标系
CGPoint buttonP = [self convertPoint:point toView:_button];

// 如果点在按钮上，就返回按钮
if ([_button pointInside:buttonP withEvent:event]) {
    return _button;
}

// 其他情况返回本身
return [super hitTest:point withEvent:event];
}
@end
</code></pre></li>
</ul>
</li>
<li><p>实例2</p>

<ul>
<li>开始<br>
<img src="./image/Snip20150616_5.png" alt="" /></li>
<li>点击按钮<br>
<img src="./image/Snip20150616_6.png" alt="" /></li>
<li>点击对话框<br>
<img src="./image/Snip20150616_10.png" alt="" /></li>
<li>需求：点击按钮出现对话框，能对对话框进行点击，并且能对按钮进行拖动（对话框也同时动）</li>
<li>解决：点击按钮时，将对话框设置为按钮的子控件</li>
<li>问题：对话框不在父控件范围内，点击对话框时，无法满足事件传递要求（触摸点不在父控件按钮上，在这里就断了，所以不会去判断其子控件）</li>
<li><p>解决：自定义按钮控件，添加对话框属性，重写按钮的-hitTest:withEvent:方法，在里面判断是否在对话框范围内范围内。<br></p>

<pre><code class="objc">// 控制器中代码
- (IBAction)popChatView:(PopBtn *)sender {
// 弹出对话框
UIButton *chatView = [UIButton buttonWithType:UIButtonTypeCustom];

chatView.bounds = CGRectMake(0, 0, 200, 200);
chatView.center = CGPointMake(100, -100);

[chatView setBackgroundImage:[UIImage imageNamed:@"对话框"] forState:UIControlStateNormal];
[chatView setBackgroundImage:[UIImage imageNamed:@"小孩"] forState:UIControlStateHighlighted];
sender.chatView = chatView;
[sender addSubview:chatView];

}
</code></pre>

<pre><code class="objc">
// 自定义按钮
@implementation PopBtn

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{

// 当前控件上的点转换到chatView上
CGPoint chatP = [self convertPoint:point toView:self.chatView];

// 判断下点在不在chatView上
if ([self.chatView pointInside:chatP withEvent:event]) {
    return self.chatView;
}else{
    return [super hitTest:point withEvent:event];
}

}

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
// 获取UITouch
UITouch *touch = [touches anyObject];

// 获取当前的点
CGPoint curP = [touch locationInView:self];

// 获取上一个的点
CGPoint preP = [touch previousLocationInView:self];

// 获取偏移量
CGFloat offsetX = curP.x - preP.x;
CGFloat OffsetY = curP.y - preP.y;

// 修改控件的位置
CGPoint center = self.center;
center.x += offsetX;
center.y += OffsetY;

self.center = center;

}
@end
</code></pre></li>
</ul>
</li>
<li>总结

<ul>
<li>这种情况下，大都是自定义覆盖需要响应控件的控件，或者子控件超出父控件范围的父控件，然后添加对应需要接收响应的控件属性，重写自定义控件的hitTest方法，在里面将触摸点转换成需要接收响应控件的坐标系，判断是否在其坐标系内，再返回对应的控件

<h1>eventstransmitandhandle</h1></li>
</ul>
</li>
<li>事件传递和触底整体过程

<ul>
<li>发生触摸事件后，系统会将该事件加入到一个由<code>UIApplication管理的事件队列</code>中(<strong>产生</strong>)</li>
<li>UIApplication会从事件队列中取出<code>最前面的事件</code>，并将事件分发下去以便处理，通常，先发送事件给应用程序的<code>主窗口（keyWindow）</code>（<strong>传递</strong>）</li>
<li>主窗口会在视图层次结构中找到一个<code>最合适的视图</code>来处理触摸事件，这也是整个事件处理过程的<code>第一步</code>（<strong>传递</strong>）</li>
<li>找到合适的视图控件后，就会调用<code>视图控件的touches方法</code>来作具体的事件处理（<strong>处理</strong>）</li>
</ul>
</li>
<li>事件<code>传递</code>方向

<ul>
<li>底层->顶层

<ul>
<li>所以<code>父控件不能接收</code>触摸事件时，<code>子控件就不能</code>接收触摸事件</li>
</ul>
</li>
</ul>
</li>
<li>事件<code>处理</code>方向

<ul>
<li>顶层->底层

<ul>
<li>所以在<code>子控件处理</code>了事件，并且<code>没有向父控件传递</code>事件时，<code>父控件就不会处理</code>事件</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>事件传递</h2>

<p><img src="./image/Snip20150616_2.png" alt="" /><br></p>

<ul>
<li>点击绿色View

<ul>
<li>UIApplication->UIWindow->白色View->绿色View</li>
</ul>
</li>
<li>点击黄色View

<ul>
<li>UIApplication->UIWindow->白色View->橙色View->蓝色View->黄色View</li>
</ul>
</li>
<li><p>查找最合适的控件来处理事件</p>

<ul>
<li><code>自己能否接收触摸事件</code>(1)</li>
<li><code>触摸点是否在自己身上</code>(2)</li>
<li><code>从后往前遍历子控件，重复前面两个步骤</code>(3)</li>
<li><code>如果没有符合条件的子控件，那么自己就是最合适的控件</code>(4)

<ul>
<li>点击黄色View的查找情况

<ul>
<li>UIApplication->UIWindow->白色View很明显</li>
<li>白色View:满足(1),(2)

<ul>
<li>执行(3)(在子控件数组中，橙色View在绿色View后面)

<ul>
<li>->橙色View:满足(1),(2)

<ul>
<li>执行(3)(红色View后于蓝色View添加，先遍历红色View)

<ul>
<li>->红色View:满足(1),不满足(2)</li>
<li>->蓝色View:满足(1),(2)

<ul>
<li>执行(3)

<ul>
<li>->黄色View:满足(1),(2)

<ul>
<li>执行(3),没有子控件，自己就是最适合的控件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>->绿色View:满足(1),不满足(2)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>UIView<code>不接受触摸</code>的三种情况</p>

<ul>
<li>不使能用户交互<br></li>
</ul>


<pre><code class="objc">userInteractionEnabled = NO
</code></pre>

<ul>
<li>隐藏<br></li>
</ul>


<pre><code class="objc">hidden = YES
</code></pre>

<ul>
<li>透明<br></li>
</ul>


<pre><code class="objc">alpha = 0.0 ~ 0.01
</code></pre>

<ul>
<li>苹果说明<br>
<img src="./image/Snip20150616_1.png" alt="" /></li>
</ul>
</li>
<li><p>寻找最适合控件内部实现</p>

<ul>
<li>寻找最适合控件方法<br>

<ul>
<li>方法内部的默认实现是依次调用子控件的这个方法，直到遍历完自己的子控件然后返回</li>
</ul>


<p>```objc
// 当事件传递给控件的时候[父控件找到子控件，调用子控件的这个方法并传入event参数]，就会调用控件的这个方法，去寻找最合适的view</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event;
```</li>
<li><p>坐标判断和转换<br></p>

<pre><code class="objc">// 将point的值，从调用这个方法的控件坐标系转到view控件    坐标系
- (CGPoint)convertPoint:(CGPoint)point toView:(UIView     *)view;
// 判断事件发生点是否在调用此方法的控件上
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent     *)event;
</code></pre></li>
<li><p>由以上两点信息可以写出<code>寻找最适合控件的内部实现</code> <br></p>

<p>```objc</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event
{
// 1.是否可以响应
if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt; 0.01) {
   return nil;
}</li>
</ul>


<p>  // 2.触摸点是否在控件上
  if ([self pointInside:point withEvent:event] == NO) {
      return nil;
  }</p>

<p>  // 3.递归遍历子控件
  for (int i = (int)self.subviews.count - 1; i >= 0; i&ndash;) {
      UIView *view = self.subviews[i];</p>

<pre><code>  // 将当前控件上的坐标系转换成子控件上的坐标系
  CGPoint childP = [self convertPoint:point toView:view];

  UIView *fitView = [view hitTest:childP withEvent:event];

  if (fitView) {
      // 找到适合的子控件
      return fitView;
  }
</code></pre>

<p>  }</p>

<p>  // 循环结束，表示没有比自己更适合的view
  return self;
}
```</p></li>
</ul>


<h2>事件处理</h2>

<ul>
<li>用户点击屏幕后产生的一个触摸事件，经过一系列的传递过程后，会找到最合适的视图控件来处理这个事件</li>
<li>找到最合适的视图控件后，就会调用<code>对应控件</code>的touches方法来作具体的事件处理

<ul>
<li>touchesBegan…</li>
<li>touchesMoved…</li>
<li>touchedEnded…</li>
<li>如果没有实现以上方法，就传递给父控件</li>
</ul>
</li>
<li>touches方法的<code>默认做法</code>是将事件<code>顺着响应者链条向上传递</code>，将事件交给上一个响应者进行处理

<ul>
<li>所以在相应控件实现了touches方法，就等于拦截了事件，在拦截控件上进行处理</li>
<li>这里<code>注意UIGestureRecognizer的区别</code>，两个并<code>不互相拦截</code>，要想拦截UIGestureRecognizer的手势处理，需要<code>在子控件上添加相同的手势</code>，<code>实现touches方法是没用的</code></li>
</ul>
</li>
</ul>


<h3>响应者链条</h3>

<ul>
<li>响应者链条：是由多个响应者对象连接起来的链条</li>
<li>作用：能很清楚的看见每个响应者之间的联系，并且可以让一个事件多个对象处理。</li>
<li>响应者对象：能处理事件的对象</li>
<li>响应者链条示意图
<img src="./image/Snip20150616_3.png" alt="" />

<ul>
<li>如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图</li>
<li>在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理</li>
<li>如果window对象也不处理，则其将事件或消息传递给UIApplication对象</li>
<li>如果UIApplication也不能处理该事件或消息，则将其丢弃</li>
</ul>
</li>
</ul>


<h2>事件传递的完整过程</h2>

<ul>
<li><p>先将事件对象由上往下传递(由父控件传递给子控件,也就是<code>从底层到顶层</code>)，找到最合适的控件来处理这个事件。</p></li>
<li><p>调用<code>最合适控件的touches….方法</code></p></li>
<li><p>如果调用了<code>[super touches….];</code>就会将事件顺着响应者链条往上传递，传递给上一个响应者［可以做到<code>一个事件多个控件响应</code>］</p>

<ul>
<li>注意，<code>如果这时，父类实现了touches….方法，但是没有调用[super touches….]，就不会传给上一个响应者，而是以父类的touches….方法解决</code>

<ul>
<li>在继承UIButton的时候就需要注意这一点，自定义button调用[super touches….]是不会传递给父控件的，因为UIButton实现了touches….方法，但是没有调用[super touches….]

<ul>
<li><code>UIButton的addTagert:方法会和touches方法冲突</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接着就会调用上一个响应者的touches….方法</p></li>
<li>判断上一个响应者

<ul>
<li>如果<code>当前这个view是控制器的view，那么控制器就是上一个响应者</code></li>
<li>如果<code>当前这个view不是控制器的view，那么父控件就是上一个响应者</code></li>
</ul>
</li>
</ul>


<h2>利用事件传递解决需求</h2>

<ul>
<li><p>实例1<br>
<img src="./image/Snip20150616_4.png" alt="" /></p>

<ul>
<li>需求：在点击到按钮的部分时，需要按钮响应，其他部分由绿色view响应

<ul>
<li>问题：由于部分按钮被绿色view覆盖了，所以点击被覆盖的按钮时，还是绿色view响应</li>
<li>解决：自定义绿色view，添加按钮属性，并重写绿色view的-hitTest:withEvent:方法，在里面判断是否在按钮范围内。<br></li>
</ul>


<pre><code class="objc">// 自定义绿色view
@interface TPCView()
/** 按钮 */
@property (weak, nonatomic) IBOutlet UIButton *button;
@end

@implementation TPCView

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
// 转换成按钮坐标系
CGPoint buttonP = [self convertPoint:point toView:_button];

// 如果点在按钮上，就返回按钮
if ([_button pointInside:buttonP withEvent:event]) {
    return _button;
}

// 其他情况返回本身
return [super hitTest:point withEvent:event];
}
@end
</code></pre></li>
</ul>
</li>
<li><p>实例2</p>

<ul>
<li>开始<br>
<img src="./image/Snip20150616_5.png" alt="" /></li>
<li>点击按钮<br>
<img src="./image/Snip20150616_6.png" alt="" /></li>
<li>点击对话框<br>
<img src="./image/Snip20150616_10.png" alt="" /></li>
<li>需求：点击按钮出现对话框，能对对话框进行点击，并且能对按钮进行拖动（对话框也同时动）</li>
<li>解决：点击按钮时，将对话框设置为按钮的子控件</li>
<li>问题：对话框不在父控件范围内，点击对话框时，无法满足事件传递要求（触摸点不在父控件按钮上，在这里就断了，所以不会去判断其子控件）</li>
<li><p>解决：自定义按钮控件，添加对话框属性，重写按钮的-hitTest:withEvent:方法，在里面判断是否在对话框范围内范围内。<br></p>

<pre><code class="objc">// 控制器中代码
- (IBAction)popChatView:(PopBtn *)sender {
// 弹出对话框
UIButton *chatView = [UIButton buttonWithType:UIButtonTypeCustom];

chatView.bounds = CGRectMake(0, 0, 200, 200);
chatView.center = CGPointMake(100, -100);

[chatView setBackgroundImage:[UIImage imageNamed:@"对话框"] forState:UIControlStateNormal];
[chatView setBackgroundImage:[UIImage imageNamed:@"小孩"] forState:UIControlStateHighlighted];
sender.chatView = chatView;
[sender addSubview:chatView];

}
</code></pre>

<pre><code class="objc">
// 自定义按钮
@implementation PopBtn

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{

// 当前控件上的点转换到chatView上
CGPoint chatP = [self convertPoint:point toView:self.chatView];

// 判断下点在不在chatView上
if ([self.chatView pointInside:chatP withEvent:event]) {
    return self.chatView;
}else{
    return [super hitTest:point withEvent:event];
}

}

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
// 获取UITouch
UITouch *touch = [touches anyObject];

// 获取当前的点
CGPoint curP = [touch locationInView:self];

// 获取上一个的点
CGPoint preP = [touch previousLocationInView:self];

// 获取偏移量
CGFloat offsetX = curP.x - preP.x;
CGFloat OffsetY = curP.y - preP.y;

// 修改控件的位置
CGPoint center = self.center;
center.x += offsetX;
center.y += OffsetY;

self.center = center;

}
@end
</code></pre></li>
</ul>
</li>
<li>总结

<ul>
<li>这种情况下，大都是自定义覆盖需要响应控件的控件，或者子控件超出父控件范围的父控件，然后添加对应需要接收响应的控件属性，重写自定义控件的hitTest方法，在里面将触摸点转换成需要接收响应控件的坐标系，判断是否在其坐标系内，再返回对应的控件
/Snip20150616_5.png)</li>
<li>点击按钮<br>
![](/images</li>
</ul>
</li>
<li>事件传递和触底整体过程

<ul>
<li>发生触摸事件后，系统会将该事件加入到一个由<code>UIApplication管理的事件队列</code>中(<strong>产生</strong>)</li>
<li>UIApplication会从事件队列中取出<code>最前面的事件</code>，并将事件分发下去以便处理，通常，先发送事件给应用程序的<code>主窗口（keyWindow）</code>（<strong>传递</strong>）</li>
<li>主窗口会在视图层次结构中找到一个<code>最合适的视图</code>来处理触摸事件，这也是整个事件处理过程的<code>第一步</code>（<strong>传递</strong>）</li>
<li>找到合适的视图控件后，就会调用<code>视图控件的touches方法</code>来作具体的事件处理（<strong>处理</strong>）</li>
</ul>
</li>
<li>事件<code>传递</code>方向

<ul>
<li>底层->顶层

<ul>
<li>所以<code>父控件不能接收</code>触摸事件时，<code>子控件就不能</code>接收触摸事件</li>
</ul>
</li>
</ul>
</li>
<li>事件<code>处理</code>方向

<ul>
<li>顶层->底层

<ul>
<li>所以在<code>子控件处理</code>了事件，并且<code>没有向父控件传递</code>事件时，<code>父控件就不会处理</code>事件</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>事件传递</h2>

<p><img src="./image/Snip20150616_2.png" alt="" /><br></p>

<ul>
<li>点击绿色View

<ul>
<li>UIApplication->UIWindow->白色View->绿色View</li>
</ul>
</li>
<li>点击黄色View

<ul>
<li>UIApplication->UIWindow->白色View->橙色View->蓝色View->黄色View</li>
</ul>
</li>
<li><p>查找最合适的控件来处理事件</p>

<ul>
<li><code>自己能否接收触摸事件</code>(1)</li>
<li><code>触摸点是否在自己身上</code>(2)</li>
<li><code>从后往前遍历子控件，重复前面两个步骤</code>(3)</li>
<li><code>如果没有符合条件的子控件，那么自己就是最合适的控件</code>(4)

<ul>
<li>点击黄色View的查找情况

<ul>
<li>UIApplication->UIWindow->白色View很明显</li>
<li>白色View:满足(1),(2)

<ul>
<li>执行(3)(在子控件数组中，橙色View在绿色View后面)

<ul>
<li>->橙色View:满足(1),(2)

<ul>
<li>执行(3)(红色View后于蓝色View添加，先遍历红色View)

<ul>
<li>->红色View:满足(1),不满足(2)</li>
<li>->蓝色View:满足(1),(2)

<ul>
<li>执行(3)

<ul>
<li>->黄色View:满足(1),(2)

<ul>
<li>执行(3),没有子控件，自己就是最适合的控件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>->绿色View:满足(1),不满足(2)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>UIView<code>不接受触摸</code>的三种情况</p>

<ul>
<li>不使能用户交互<br></li>
</ul>


<pre><code class="objc">userInteractionEnabled = NO
</code></pre>

<ul>
<li>隐藏<br></li>
</ul>


<pre><code class="objc">hidden = YES
</code></pre>

<ul>
<li>透明<br></li>
</ul>


<pre><code class="objc">alpha = 0.0 ~ 0.01
</code></pre>

<ul>
<li>苹果说明<br>
<img src="./image/Snip20150616_1.png" alt="" /></li>
</ul>
</li>
<li><p>寻找最适合控件内部实现</p>

<ul>
<li>寻找最适合控件方法<br>

<ul>
<li>方法内部的默认实现是依次调用子控件的这个方法，直到遍历完自己的子控件然后返回</li>
</ul>


<p>```objc
// 当事件传递给控件的时候[父控件找到子控件，调用子控件的这个方法并传入event参数]，就会调用控件的这个方法，去寻找最合适的view</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event;
```</li>
<li><p>坐标判断和转换<br></p>

<pre><code class="objc">// 将point的值，从调用这个方法的控件坐标系转到view控件    坐标系
- (CGPoint)convertPoint:(CGPoint)point toView:(UIView     *)view;
// 判断事件发生点是否在调用此方法的控件上
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent     *)event;
</code></pre></li>
<li><p>由以上两点信息可以写出<code>寻找最适合控件的内部实现</code> <br></p>

<p>```objc</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event
{
// 1.是否可以响应
if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt; 0.01) {
   return nil;
}</li>
</ul>


<p>  // 2.触摸点是否在控件上
  if ([self pointInside:point withEvent:event] == NO) {
      return nil;
  }</p>

<p>  // 3.递归遍历子控件
  for (int i = (int)self.subviews.count - 1; i >= 0; i&ndash;) {
      UIView *view = self.subviews[i];</p>

<pre><code>  // 将当前控件上的坐标系转换成子控件上的坐标系
  CGPoint childP = [self convertPoint:point toView:view];

  UIView *fitView = [view hitTest:childP withEvent:event];

  if (fitView) {
      // 找到适合的子控件
      return fitView;
  }
</code></pre>

<p>  }</p>

<p>  // 循环结束，表示没有比自己更适合的view
  return self;
}
```</p></li>
</ul>


<h2>事件处理</h2>

<ul>
<li>用户点击屏幕后产生的一个触摸事件，经过一系列的传递过程后，会找到最合适的视图控件来处理这个事件</li>
<li>找到最合适的视图控件后，就会调用<code>对应控件</code>的touches方法来作具体的事件处理

<ul>
<li>touchesBegan…</li>
<li>touchesMoved…</li>
<li>touchedEnded…</li>
<li>如果没有实现以上方法，就传递给父控件</li>
</ul>
</li>
<li>touches方法的<code>默认做法</code>是将事件<code>顺着响应者链条向上传递</code>，将事件交给上一个响应者进行处理

<ul>
<li>所以在相应控件实现了touches方法，就等于拦截了事件，在拦截控件上进行处理</li>
<li>这里<code>注意UIGestureRecognizer的区别</code>，两个并<code>不互相拦截</code>，要想拦截UIGestureRecognizer的手势处理，需要<code>在子控件上添加相同的手势</code>，<code>实现touches方法是没用的</code></li>
</ul>
</li>
</ul>


<h3>响应者链条</h3>

<ul>
<li>响应者链条：是由多个响应者对象连接起来的链条</li>
<li>作用：能很清楚的看见每个响应者之间的联系，并且可以让一个事件多个对象处理。</li>
<li>响应者对象：能处理事件的对象</li>
<li>响应者链条示意图
<img src="./image/Snip20150616_3.png" alt="" />

<ul>
<li>如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图</li>
<li>在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理</li>
<li>如果window对象也不处理，则其将事件或消息传递给UIApplication对象</li>
<li>如果UIApplication也不能处理该事件或消息，则将其丢弃</li>
</ul>
</li>
</ul>


<h2>事件传递的完整过程</h2>

<ul>
<li><p>先将事件对象由上往下传递(由父控件传递给子控件,也就是<code>从底层到顶层</code>)，找到最合适的控件来处理这个事件。</p></li>
<li><p>调用<code>最合适控件的touches….方法</code></p></li>
<li><p>如果调用了<code>[super touches….];</code>就会将事件顺着响应者链条往上传递，传递给上一个响应者［可以做到<code>一个事件多个控件响应</code>］</p>

<ul>
<li>注意，<code>如果这时，父类实现了touches….方法，但是没有调用[super touches….]，就不会传给上一个响应者，而是以父类的touches….方法解决</code>

<ul>
<li>在继承UIButton的时候就需要注意这一点，自定义button调用[super touches….]是不会传递给父控件的，因为UIButton实现了touches….方法，但是没有调用[super touches….]

<ul>
<li><code>UIButton的addTagert:方法会和touches方法冲突</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接着就会调用上一个响应者的touches….方法</p></li>
<li>判断上一个响应者

<ul>
<li>如果<code>当前这个view是控制器的view，那么控制器就是上一个响应者</code></li>
<li>如果<code>当前这个view不是控制器的view，那么父控件就是上一个响应者</code></li>
</ul>
</li>
</ul>


<h2>利用事件传递解决需求</h2>

<ul>
<li><p>实例1<br>
<img src="./image/Snip20150616_4.png" alt="" /></p>

<ul>
<li>需求：在点击到按钮的部分时，需要按钮响应，其他部分由绿色view响应

<ul>
<li>问题：由于部分按钮被绿色view覆盖了，所以点击被覆盖的按钮时，还是绿色view响应</li>
<li>解决：自定义绿色view，添加按钮属性，并重写绿色view的-hitTest:withEvent:方法，在里面判断是否在按钮范围内。<br></li>
</ul>


<pre><code class="objc">// 自定义绿色view
@interface TPCView()
/** 按钮 */
@property (weak, nonatomic) IBOutlet UIButton *button;
@end

@implementation TPCView

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
// 转换成按钮坐标系
CGPoint buttonP = [self convertPoint:point toView:_button];

// 如果点在按钮上，就返回按钮
if ([_button pointInside:buttonP withEvent:event]) {
    return _button;
}

// 其他情况返回本身
return [super hitTest:point withEvent:event];
}
@end
</code></pre></li>
</ul>
</li>
<li><p>实例2</p>

<ul>
<li>开始<br>
<img src="./image/Snip20150616_5.png" alt="" /></li>
<li>点击按钮<br>
<img src="./image/Snip20150616_6.png" alt="" /></li>
<li>点击对话框<br>
<img src="./image/Snip20150616_10.png" alt="" /></li>
<li>需求：点击按钮出现对话框，能对对话框进行点击，并且能对按钮进行拖动（对话框也同时动）</li>
<li>解决：点击按钮时，将对话框设置为按钮的子控件</li>
<li>问题：对话框不在父控件范围内，点击对话框时，无法满足事件传递要求（触摸点不在父控件按钮上，在这里就断了，所以不会去判断其子控件）</li>
<li><p>解决：自定义按钮控件，添加对话框属性，重写按钮的-hitTest:withEvent:方法，在里面判断是否在对话框范围内范围内。<br></p>

<pre><code class="objc">// 控制器中代码
- (IBAction)popChatView:(PopBtn *)sender {
// 弹出对话框
UIButton *chatView = [UIButton buttonWithType:UIButtonTypeCustom];

chatView.bounds = CGRectMake(0, 0, 200, 200);
chatView.center = CGPointMake(100, -100);

[chatView setBackgroundImage:[UIImage imageNamed:@"对话框"] forState:UIControlStateNormal];
[chatView setBackgroundImage:[UIImage imageNamed:@"小孩"] forState:UIControlStateHighlighted];
sender.chatView = chatView;
[sender addSubview:chatView];

}
</code></pre>

<pre><code class="objc">
// 自定义按钮
@implementation PopBtn

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{

// 当前控件上的点转换到chatView上
CGPoint chatP = [self convertPoint:point toView:self.chatView];

// 判断下点在不在chatView上
if ([self.chatView pointInside:chatP withEvent:event]) {
    return self.chatView;
}else{
    return [super hitTest:point withEvent:event];
}

}

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
// 获取UITouch
UITouch *touch = [touches anyObject];

// 获取当前的点
CGPoint curP = [touch locationInView:self];

// 获取上一个的点
CGPoint preP = [touch previousLocationInView:self];

// 获取偏移量
CGFloat offsetX = curP.x - preP.x;
CGFloat OffsetY = curP.y - preP.y;

// 修改控件的位置
CGPoint center = self.center;
center.x += offsetX;
center.y += OffsetY;

self.center = center;

}
@end
</code></pre></li>
</ul>
</li>
<li>总结

<ul>
<li>这种情况下，大都是自定义覆盖需要响应控件的控件，或者子控件超出父控件范围的父控件，然后添加对应需要接收响应的控件属性，重写自定义控件的hitTest方法，在里面将触摸点转换成需要接收响应控件的坐标系，判断是否在其坐标系内，再返回对应的控件

<h1>eventstransmitandhandle</h1></li>
</ul>
</li>
<li>事件传递和触底整体过程

<ul>
<li>发生触摸事件后，系统会将该事件加入到一个由<code>UIApplication管理的事件队列</code>中(<strong>产生</strong>)</li>
<li>UIApplication会从事件队列中取出<code>最前面的事件</code>，并将事件分发下去以便处理，通常，先发送事件给应用程序的<code>主窗口（keyWindow）</code>（<strong>传递</strong>）</li>
<li>主窗口会在视图层次结构中找到一个<code>最合适的视图</code>来处理触摸事件，这也是整个事件处理过程的<code>第一步</code>（<strong>传递</strong>）</li>
<li>找到合适的视图控件后，就会调用<code>视图控件的touches方法</code>来作具体的事件处理（<strong>处理</strong>）</li>
</ul>
</li>
<li>事件<code>传递</code>方向

<ul>
<li>底层->顶层

<ul>
<li>所以<code>父控件不能接收</code>触摸事件时，<code>子控件就不能</code>接收触摸事件</li>
</ul>
</li>
</ul>
</li>
<li>事件<code>处理</code>方向

<ul>
<li>顶层->底层

<ul>
<li>所以在<code>子控件处理</code>了事件，并且<code>没有向父控件传递</code>事件时，<code>父控件就不会处理</code>事件</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>事件传递</h2>

<p><img src="./image/Snip20150616_2.png" alt="" /><br></p>

<ul>
<li>点击绿色View

<ul>
<li>UIApplication->UIWindow->白色View->绿色View</li>
</ul>
</li>
<li>点击黄色View

<ul>
<li>UIApplication->UIWindow->白色View->橙色View->蓝色View->黄色View</li>
</ul>
</li>
<li><p>查找最合适的控件来处理事件</p>

<ul>
<li><code>自己能否接收触摸事件</code>(1)</li>
<li><code>触摸点是否在自己身上</code>(2)</li>
<li><code>从后往前遍历子控件，重复前面两个步骤</code>(3)</li>
<li><code>如果没有符合条件的子控件，那么自己就是最合适的控件</code>(4)

<ul>
<li>点击黄色View的查找情况

<ul>
<li>UIApplication->UIWindow->白色View很明显</li>
<li>白色View:满足(1),(2)

<ul>
<li>执行(3)(在子控件数组中，橙色View在绿色View后面)

<ul>
<li>->橙色View:满足(1),(2)

<ul>
<li>执行(3)(红色View后于蓝色View添加，先遍历红色View)

<ul>
<li>->红色View:满足(1),不满足(2)</li>
<li>->蓝色View:满足(1),(2)

<ul>
<li>执行(3)

<ul>
<li>->黄色View:满足(1),(2)

<ul>
<li>执行(3),没有子控件，自己就是最适合的控件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>->绿色View:满足(1),不满足(2)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>UIView<code>不接受触摸</code>的三种情况</p>

<ul>
<li>不使能用户交互<br></li>
</ul>


<pre><code class="objc">userInteractionEnabled = NO
</code></pre>

<ul>
<li>隐藏<br></li>
</ul>


<pre><code class="objc">hidden = YES
</code></pre>

<ul>
<li>透明<br></li>
</ul>


<pre><code class="objc">alpha = 0.0 ~ 0.01
</code></pre>

<ul>
<li>苹果说明<br>
<img src="./image/Snip20150616_1.png" alt="" /></li>
</ul>
</li>
<li><p>寻找最适合控件内部实现</p>

<ul>
<li>寻找最适合控件方法<br>

<ul>
<li>方法内部的默认实现是依次调用子控件的这个方法，直到遍历完自己的子控件然后返回</li>
</ul>


<p>```objc
// 当事件传递给控件的时候[父控件找到子控件，调用子控件的这个方法并传入event参数]，就会调用控件的这个方法，去寻找最合适的view</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event;
```</li>
<li><p>坐标判断和转换<br></p>

<pre><code class="objc">// 将point的值，从调用这个方法的控件坐标系转到view控件    坐标系
- (CGPoint)convertPoint:(CGPoint)point toView:(UIView     *)view;
// 判断事件发生点是否在调用此方法的控件上
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent     *)event;
</code></pre></li>
<li><p>由以上两点信息可以写出<code>寻找最适合控件的内部实现</code> <br></p>

<p>```objc</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event
{
// 1.是否可以响应
if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt; 0.01) {
   return nil;
}</li>
</ul>


<p>  // 2.触摸点是否在控件上
  if ([self pointInside:point withEvent:event] == NO) {
      return nil;
  }</p>

<p>  // 3.递归遍历子控件
  for (int i = (int)self.subviews.count - 1; i >= 0; i&ndash;) {
      UIView *view = self.subviews[i];</p>

<pre><code>  // 将当前控件上的坐标系转换成子控件上的坐标系
  CGPoint childP = [self convertPoint:point toView:view];

  UIView *fitView = [view hitTest:childP withEvent:event];

  if (fitView) {
      // 找到适合的子控件
      return fitView;
  }
</code></pre>

<p>  }</p>

<p>  // 循环结束，表示没有比自己更适合的view
  return self;
}
```</p></li>
</ul>


<h2>事件处理</h2>

<ul>
<li>用户点击屏幕后产生的一个触摸事件，经过一系列的传递过程后，会找到最合适的视图控件来处理这个事件</li>
<li>找到最合适的视图控件后，就会调用<code>对应控件</code>的touches方法来作具体的事件处理

<ul>
<li>touchesBegan…</li>
<li>touchesMoved…</li>
<li>touchedEnded…</li>
<li>如果没有实现以上方法，就传递给父控件</li>
</ul>
</li>
<li>touches方法的<code>默认做法</code>是将事件<code>顺着响应者链条向上传递</code>，将事件交给上一个响应者进行处理

<ul>
<li>所以在相应控件实现了touches方法，就等于拦截了事件，在拦截控件上进行处理</li>
<li>这里<code>注意UIGestureRecognizer的区别</code>，两个并<code>不互相拦截</code>，要想拦截UIGestureRecognizer的手势处理，需要<code>在子控件上添加相同的手势</code>，<code>实现touches方法是没用的</code></li>
</ul>
</li>
</ul>


<h3>响应者链条</h3>

<ul>
<li>响应者链条：是由多个响应者对象连接起来的链条</li>
<li>作用：能很清楚的看见每个响应者之间的联系，并且可以让一个事件多个对象处理。</li>
<li>响应者对象：能处理事件的对象</li>
<li>响应者链条示意图
<img src="./image/Snip20150616_3.png" alt="" />

<ul>
<li>如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图</li>
<li>在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理</li>
<li>如果window对象也不处理，则其将事件或消息传递给UIApplication对象</li>
<li>如果UIApplication也不能处理该事件或消息，则将其丢弃</li>
</ul>
</li>
</ul>


<h2>事件传递的完整过程</h2>

<ul>
<li><p>先将事件对象由上往下传递(由父控件传递给子控件,也就是<code>从底层到顶层</code>)，找到最合适的控件来处理这个事件。</p></li>
<li><p>调用<code>最合适控件的touches….方法</code></p></li>
<li><p>如果调用了<code>[super touches….];</code>就会将事件顺着响应者链条往上传递，传递给上一个响应者［可以做到<code>一个事件多个控件响应</code>］</p>

<ul>
<li>注意，<code>如果这时，父类实现了touches….方法，但是没有调用[super touches….]，就不会传给上一个响应者，而是以父类的touches….方法解决</code>

<ul>
<li>在继承UIButton的时候就需要注意这一点，自定义button调用[super touches….]是不会传递给父控件的，因为UIButton实现了touches….方法，但是没有调用[super touches….]

<ul>
<li><code>UIButton的addTagert:方法会和touches方法冲突</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接着就会调用上一个响应者的touches….方法</p></li>
<li>判断上一个响应者

<ul>
<li>如果<code>当前这个view是控制器的view，那么控制器就是上一个响应者</code></li>
<li>如果<code>当前这个view不是控制器的view，那么父控件就是上一个响应者</code></li>
</ul>
</li>
</ul>


<h2>利用事件传递解决需求</h2>

<ul>
<li><p>实例1<br>
<img src="./image/Snip20150616_4.png" alt="" /></p>

<ul>
<li>需求：在点击到按钮的部分时，需要按钮响应，其他部分由绿色view响应

<ul>
<li>问题：由于部分按钮被绿色view覆盖了，所以点击被覆盖的按钮时，还是绿色view响应</li>
<li>解决：自定义绿色view，添加按钮属性，并重写绿色view的-hitTest:withEvent:方法，在里面判断是否在按钮范围内。<br></li>
</ul>


<pre><code class="objc">// 自定义绿色view
@interface TPCView()
/** 按钮 */
@property (weak, nonatomic) IBOutlet UIButton *button;
@end

@implementation TPCView

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
// 转换成按钮坐标系
CGPoint buttonP = [self convertPoint:point toView:_button];

// 如果点在按钮上，就返回按钮
if ([_button pointInside:buttonP withEvent:event]) {
    return _button;
}

// 其他情况返回本身
return [super hitTest:point withEvent:event];
}
@end
</code></pre></li>
</ul>
</li>
<li><p>实例2</p>

<ul>
<li>开始<br>
<img src="./image/Snip20150616_5.png" alt="" /></li>
<li>点击按钮<br>
<img src="./image/Snip20150616_6.png" alt="" /></li>
<li>点击对话框<br>
<img src="./image/Snip20150616_10.png" alt="" /></li>
<li>需求：点击按钮出现对话框，能对对话框进行点击，并且能对按钮进行拖动（对话框也同时动）</li>
<li>解决：点击按钮时，将对话框设置为按钮的子控件</li>
<li>问题：对话框不在父控件范围内，点击对话框时，无法满足事件传递要求（触摸点不在父控件按钮上，在这里就断了，所以不会去判断其子控件）</li>
<li><p>解决：自定义按钮控件，添加对话框属性，重写按钮的-hitTest:withEvent:方法，在里面判断是否在对话框范围内范围内。<br></p>

<pre><code class="objc">// 控制器中代码
- (IBAction)popChatView:(PopBtn *)sender {
// 弹出对话框
UIButton *chatView = [UIButton buttonWithType:UIButtonTypeCustom];

chatView.bounds = CGRectMake(0, 0, 200, 200);
chatView.center = CGPointMake(100, -100);

[chatView setBackgroundImage:[UIImage imageNamed:@"对话框"] forState:UIControlStateNormal];
[chatView setBackgroundImage:[UIImage imageNamed:@"小孩"] forState:UIControlStateHighlighted];
sender.chatView = chatView;
[sender addSubview:chatView];

}
</code></pre>

<pre><code class="objc">
// 自定义按钮
@implementation PopBtn

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{

// 当前控件上的点转换到chatView上
CGPoint chatP = [self convertPoint:point toView:self.chatView];

// 判断下点在不在chatView上
if ([self.chatView pointInside:chatP withEvent:event]) {
    return self.chatView;
}else{
    return [super hitTest:point withEvent:event];
}

}

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
// 获取UITouch
UITouch *touch = [touches anyObject];

// 获取当前的点
CGPoint curP = [touch locationInView:self];

// 获取上一个的点
CGPoint preP = [touch previousLocationInView:self];

// 获取偏移量
CGFloat offsetX = curP.x - preP.x;
CGFloat OffsetY = curP.y - preP.y;

// 修改控件的位置
CGPoint center = self.center;
center.x += offsetX;
center.y += OffsetY;

self.center = center;

}
@end
</code></pre></li>
</ul>
</li>
<li>总结

<ul>
<li>这种情况下，大都是自定义覆盖需要响应控件的控件，或者子控件超出父控件范围的父控件，然后添加对应需要接收响应的控件属性，重写自定义控件的hitTest方法，在里面将触摸点转换成需要接收响应控件的坐标系，判断是否在其坐标系内，再返回对应的控件
/Snip20150616_6.png)</li>
<li>点击对话框<br>
![](/images</li>
</ul>
</li>
<li>事件传递和触底整体过程

<ul>
<li>发生触摸事件后，系统会将该事件加入到一个由<code>UIApplication管理的事件队列</code>中(<strong>产生</strong>)</li>
<li>UIApplication会从事件队列中取出<code>最前面的事件</code>，并将事件分发下去以便处理，通常，先发送事件给应用程序的<code>主窗口（keyWindow）</code>（<strong>传递</strong>）</li>
<li>主窗口会在视图层次结构中找到一个<code>最合适的视图</code>来处理触摸事件，这也是整个事件处理过程的<code>第一步</code>（<strong>传递</strong>）</li>
<li>找到合适的视图控件后，就会调用<code>视图控件的touches方法</code>来作具体的事件处理（<strong>处理</strong>）</li>
</ul>
</li>
<li>事件<code>传递</code>方向

<ul>
<li>底层->顶层

<ul>
<li>所以<code>父控件不能接收</code>触摸事件时，<code>子控件就不能</code>接收触摸事件</li>
</ul>
</li>
</ul>
</li>
<li>事件<code>处理</code>方向

<ul>
<li>顶层->底层

<ul>
<li>所以在<code>子控件处理</code>了事件，并且<code>没有向父控件传递</code>事件时，<code>父控件就不会处理</code>事件</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>事件传递</h2>

<p><img src="./image/Snip20150616_2.png" alt="" /><br></p>

<ul>
<li>点击绿色View

<ul>
<li>UIApplication->UIWindow->白色View->绿色View</li>
</ul>
</li>
<li>点击黄色View

<ul>
<li>UIApplication->UIWindow->白色View->橙色View->蓝色View->黄色View</li>
</ul>
</li>
<li><p>查找最合适的控件来处理事件</p>

<ul>
<li><code>自己能否接收触摸事件</code>(1)</li>
<li><code>触摸点是否在自己身上</code>(2)</li>
<li><code>从后往前遍历子控件，重复前面两个步骤</code>(3)</li>
<li><code>如果没有符合条件的子控件，那么自己就是最合适的控件</code>(4)

<ul>
<li>点击黄色View的查找情况

<ul>
<li>UIApplication->UIWindow->白色View很明显</li>
<li>白色View:满足(1),(2)

<ul>
<li>执行(3)(在子控件数组中，橙色View在绿色View后面)

<ul>
<li>->橙色View:满足(1),(2)

<ul>
<li>执行(3)(红色View后于蓝色View添加，先遍历红色View)

<ul>
<li>->红色View:满足(1),不满足(2)</li>
<li>->蓝色View:满足(1),(2)

<ul>
<li>执行(3)

<ul>
<li>->黄色View:满足(1),(2)

<ul>
<li>执行(3),没有子控件，自己就是最适合的控件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>->绿色View:满足(1),不满足(2)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>UIView<code>不接受触摸</code>的三种情况</p>

<ul>
<li>不使能用户交互<br></li>
</ul>


<pre><code class="objc">userInteractionEnabled = NO
</code></pre>

<ul>
<li>隐藏<br></li>
</ul>


<pre><code class="objc">hidden = YES
</code></pre>

<ul>
<li>透明<br></li>
</ul>


<pre><code class="objc">alpha = 0.0 ~ 0.01
</code></pre>

<ul>
<li>苹果说明<br>
<img src="./image/Snip20150616_1.png" alt="" /></li>
</ul>
</li>
<li><p>寻找最适合控件内部实现</p>

<ul>
<li>寻找最适合控件方法<br>

<ul>
<li>方法内部的默认实现是依次调用子控件的这个方法，直到遍历完自己的子控件然后返回</li>
</ul>


<p>```objc
// 当事件传递给控件的时候[父控件找到子控件，调用子控件的这个方法并传入event参数]，就会调用控件的这个方法，去寻找最合适的view</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event;
```</li>
<li><p>坐标判断和转换<br></p>

<pre><code class="objc">// 将point的值，从调用这个方法的控件坐标系转到view控件    坐标系
- (CGPoint)convertPoint:(CGPoint)point toView:(UIView     *)view;
// 判断事件发生点是否在调用此方法的控件上
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent     *)event;
</code></pre></li>
<li><p>由以上两点信息可以写出<code>寻找最适合控件的内部实现</code> <br></p>

<p>```objc</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event
{
// 1.是否可以响应
if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt; 0.01) {
   return nil;
}</li>
</ul>


<p>  // 2.触摸点是否在控件上
  if ([self pointInside:point withEvent:event] == NO) {
      return nil;
  }</p>

<p>  // 3.递归遍历子控件
  for (int i = (int)self.subviews.count - 1; i >= 0; i&ndash;) {
      UIView *view = self.subviews[i];</p>

<pre><code>  // 将当前控件上的坐标系转换成子控件上的坐标系
  CGPoint childP = [self convertPoint:point toView:view];

  UIView *fitView = [view hitTest:childP withEvent:event];

  if (fitView) {
      // 找到适合的子控件
      return fitView;
  }
</code></pre>

<p>  }</p>

<p>  // 循环结束，表示没有比自己更适合的view
  return self;
}
```</p></li>
</ul>


<h2>事件处理</h2>

<ul>
<li>用户点击屏幕后产生的一个触摸事件，经过一系列的传递过程后，会找到最合适的视图控件来处理这个事件</li>
<li>找到最合适的视图控件后，就会调用<code>对应控件</code>的touches方法来作具体的事件处理

<ul>
<li>touchesBegan…</li>
<li>touchesMoved…</li>
<li>touchedEnded…</li>
<li>如果没有实现以上方法，就传递给父控件</li>
</ul>
</li>
<li>touches方法的<code>默认做法</code>是将事件<code>顺着响应者链条向上传递</code>，将事件交给上一个响应者进行处理

<ul>
<li>所以在相应控件实现了touches方法，就等于拦截了事件，在拦截控件上进行处理</li>
<li>这里<code>注意UIGestureRecognizer的区别</code>，两个并<code>不互相拦截</code>，要想拦截UIGestureRecognizer的手势处理，需要<code>在子控件上添加相同的手势</code>，<code>实现touches方法是没用的</code></li>
</ul>
</li>
</ul>


<h3>响应者链条</h3>

<ul>
<li>响应者链条：是由多个响应者对象连接起来的链条</li>
<li>作用：能很清楚的看见每个响应者之间的联系，并且可以让一个事件多个对象处理。</li>
<li>响应者对象：能处理事件的对象</li>
<li>响应者链条示意图
<img src="./image/Snip20150616_3.png" alt="" />

<ul>
<li>如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图</li>
<li>在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理</li>
<li>如果window对象也不处理，则其将事件或消息传递给UIApplication对象</li>
<li>如果UIApplication也不能处理该事件或消息，则将其丢弃</li>
</ul>
</li>
</ul>


<h2>事件传递的完整过程</h2>

<ul>
<li><p>先将事件对象由上往下传递(由父控件传递给子控件,也就是<code>从底层到顶层</code>)，找到最合适的控件来处理这个事件。</p></li>
<li><p>调用<code>最合适控件的touches….方法</code></p></li>
<li><p>如果调用了<code>[super touches….];</code>就会将事件顺着响应者链条往上传递，传递给上一个响应者［可以做到<code>一个事件多个控件响应</code>］</p>

<ul>
<li>注意，<code>如果这时，父类实现了touches….方法，但是没有调用[super touches….]，就不会传给上一个响应者，而是以父类的touches….方法解决</code>

<ul>
<li>在继承UIButton的时候就需要注意这一点，自定义button调用[super touches….]是不会传递给父控件的，因为UIButton实现了touches….方法，但是没有调用[super touches….]

<ul>
<li><code>UIButton的addTagert:方法会和touches方法冲突</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接着就会调用上一个响应者的touches….方法</p></li>
<li>判断上一个响应者

<ul>
<li>如果<code>当前这个view是控制器的view，那么控制器就是上一个响应者</code></li>
<li>如果<code>当前这个view不是控制器的view，那么父控件就是上一个响应者</code></li>
</ul>
</li>
</ul>


<h2>利用事件传递解决需求</h2>

<ul>
<li><p>实例1<br>
<img src="./image/Snip20150616_4.png" alt="" /></p>

<ul>
<li>需求：在点击到按钮的部分时，需要按钮响应，其他部分由绿色view响应

<ul>
<li>问题：由于部分按钮被绿色view覆盖了，所以点击被覆盖的按钮时，还是绿色view响应</li>
<li>解决：自定义绿色view，添加按钮属性，并重写绿色view的-hitTest:withEvent:方法，在里面判断是否在按钮范围内。<br></li>
</ul>


<pre><code class="objc">// 自定义绿色view
@interface TPCView()
/** 按钮 */
@property (weak, nonatomic) IBOutlet UIButton *button;
@end

@implementation TPCView

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
// 转换成按钮坐标系
CGPoint buttonP = [self convertPoint:point toView:_button];

// 如果点在按钮上，就返回按钮
if ([_button pointInside:buttonP withEvent:event]) {
    return _button;
}

// 其他情况返回本身
return [super hitTest:point withEvent:event];
}
@end
</code></pre></li>
</ul>
</li>
<li><p>实例2</p>

<ul>
<li>开始<br>
<img src="./image/Snip20150616_5.png" alt="" /></li>
<li>点击按钮<br>
<img src="./image/Snip20150616_6.png" alt="" /></li>
<li>点击对话框<br>
<img src="./image/Snip20150616_10.png" alt="" /></li>
<li>需求：点击按钮出现对话框，能对对话框进行点击，并且能对按钮进行拖动（对话框也同时动）</li>
<li>解决：点击按钮时，将对话框设置为按钮的子控件</li>
<li>问题：对话框不在父控件范围内，点击对话框时，无法满足事件传递要求（触摸点不在父控件按钮上，在这里就断了，所以不会去判断其子控件）</li>
<li><p>解决：自定义按钮控件，添加对话框属性，重写按钮的-hitTest:withEvent:方法，在里面判断是否在对话框范围内范围内。<br></p>

<pre><code class="objc">// 控制器中代码
- (IBAction)popChatView:(PopBtn *)sender {
// 弹出对话框
UIButton *chatView = [UIButton buttonWithType:UIButtonTypeCustom];

chatView.bounds = CGRectMake(0, 0, 200, 200);
chatView.center = CGPointMake(100, -100);

[chatView setBackgroundImage:[UIImage imageNamed:@"对话框"] forState:UIControlStateNormal];
[chatView setBackgroundImage:[UIImage imageNamed:@"小孩"] forState:UIControlStateHighlighted];
sender.chatView = chatView;
[sender addSubview:chatView];

}
</code></pre>

<pre><code class="objc">
// 自定义按钮
@implementation PopBtn

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{

// 当前控件上的点转换到chatView上
CGPoint chatP = [self convertPoint:point toView:self.chatView];

// 判断下点在不在chatView上
if ([self.chatView pointInside:chatP withEvent:event]) {
    return self.chatView;
}else{
    return [super hitTest:point withEvent:event];
}

}

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
// 获取UITouch
UITouch *touch = [touches anyObject];

// 获取当前的点
CGPoint curP = [touch locationInView:self];

// 获取上一个的点
CGPoint preP = [touch previousLocationInView:self];

// 获取偏移量
CGFloat offsetX = curP.x - preP.x;
CGFloat OffsetY = curP.y - preP.y;

// 修改控件的位置
CGPoint center = self.center;
center.x += offsetX;
center.y += OffsetY;

self.center = center;

}
@end
</code></pre></li>
</ul>
</li>
<li>总结

<ul>
<li>这种情况下，大都是自定义覆盖需要响应控件的控件，或者子控件超出父控件范围的父控件，然后添加对应需要接收响应的控件属性，重写自定义控件的hitTest方法，在里面将触摸点转换成需要接收响应控件的坐标系，判断是否在其坐标系内，再返回对应的控件

<h1>eventstransmitandhandle</h1></li>
</ul>
</li>
<li>事件传递和触底整体过程

<ul>
<li>发生触摸事件后，系统会将该事件加入到一个由<code>UIApplication管理的事件队列</code>中(<strong>产生</strong>)</li>
<li>UIApplication会从事件队列中取出<code>最前面的事件</code>，并将事件分发下去以便处理，通常，先发送事件给应用程序的<code>主窗口（keyWindow）</code>（<strong>传递</strong>）</li>
<li>主窗口会在视图层次结构中找到一个<code>最合适的视图</code>来处理触摸事件，这也是整个事件处理过程的<code>第一步</code>（<strong>传递</strong>）</li>
<li>找到合适的视图控件后，就会调用<code>视图控件的touches方法</code>来作具体的事件处理（<strong>处理</strong>）</li>
</ul>
</li>
<li>事件<code>传递</code>方向

<ul>
<li>底层->顶层

<ul>
<li>所以<code>父控件不能接收</code>触摸事件时，<code>子控件就不能</code>接收触摸事件</li>
</ul>
</li>
</ul>
</li>
<li>事件<code>处理</code>方向

<ul>
<li>顶层->底层

<ul>
<li>所以在<code>子控件处理</code>了事件，并且<code>没有向父控件传递</code>事件时，<code>父控件就不会处理</code>事件</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>事件传递</h2>

<p><img src="./image/Snip20150616_2.png" alt="" /><br></p>

<ul>
<li>点击绿色View

<ul>
<li>UIApplication->UIWindow->白色View->绿色View</li>
</ul>
</li>
<li>点击黄色View

<ul>
<li>UIApplication->UIWindow->白色View->橙色View->蓝色View->黄色View</li>
</ul>
</li>
<li><p>查找最合适的控件来处理事件</p>

<ul>
<li><code>自己能否接收触摸事件</code>(1)</li>
<li><code>触摸点是否在自己身上</code>(2)</li>
<li><code>从后往前遍历子控件，重复前面两个步骤</code>(3)</li>
<li><code>如果没有符合条件的子控件，那么自己就是最合适的控件</code>(4)

<ul>
<li>点击黄色View的查找情况

<ul>
<li>UIApplication->UIWindow->白色View很明显</li>
<li>白色View:满足(1),(2)

<ul>
<li>执行(3)(在子控件数组中，橙色View在绿色View后面)

<ul>
<li>->橙色View:满足(1),(2)

<ul>
<li>执行(3)(红色View后于蓝色View添加，先遍历红色View)

<ul>
<li>->红色View:满足(1),不满足(2)</li>
<li>->蓝色View:满足(1),(2)

<ul>
<li>执行(3)

<ul>
<li>->黄色View:满足(1),(2)

<ul>
<li>执行(3),没有子控件，自己就是最适合的控件</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>->绿色View:满足(1),不满足(2)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>UIView<code>不接受触摸</code>的三种情况</p>

<ul>
<li>不使能用户交互<br></li>
</ul>


<pre><code class="objc">userInteractionEnabled = NO
</code></pre>

<ul>
<li>隐藏<br></li>
</ul>


<pre><code class="objc">hidden = YES
</code></pre>

<ul>
<li>透明<br></li>
</ul>


<pre><code class="objc">alpha = 0.0 ~ 0.01
</code></pre>

<ul>
<li>苹果说明<br>
<img src="./image/Snip20150616_1.png" alt="" /></li>
</ul>
</li>
<li><p>寻找最适合控件内部实现</p>

<ul>
<li>寻找最适合控件方法<br>

<ul>
<li>方法内部的默认实现是依次调用子控件的这个方法，直到遍历完自己的子控件然后返回</li>
</ul>


<p>```objc
// 当事件传递给控件的时候[父控件找到子控件，调用子控件的这个方法并传入event参数]，就会调用控件的这个方法，去寻找最合适的view</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event;
```</li>
<li><p>坐标判断和转换<br></p>

<pre><code class="objc">// 将point的值，从调用这个方法的控件坐标系转到view控件    坐标系
- (CGPoint)convertPoint:(CGPoint)point toView:(UIView     *)view;
// 判断事件发生点是否在调用此方法的控件上
- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent     *)event;
</code></pre></li>
<li><p>由以上两点信息可以写出<code>寻找最适合控件的内部实现</code> <br></p>

<p>```objc</p></li>
<li>(UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event
{
// 1.是否可以响应
if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt; 0.01) {
   return nil;
}</li>
</ul>


<p>  // 2.触摸点是否在控件上
  if ([self pointInside:point withEvent:event] == NO) {
      return nil;
  }</p>

<p>  // 3.递归遍历子控件
  for (int i = (int)self.subviews.count - 1; i >= 0; i&ndash;) {
      UIView *view = self.subviews[i];</p>

<pre><code>  // 将当前控件上的坐标系转换成子控件上的坐标系
  CGPoint childP = [self convertPoint:point toView:view];

  UIView *fitView = [view hitTest:childP withEvent:event];

  if (fitView) {
      // 找到适合的子控件
      return fitView;
  }
</code></pre>

<p>  }</p>

<p>  // 循环结束，表示没有比自己更适合的view
  return self;
}
```</p></li>
</ul>


<h2>事件处理</h2>

<ul>
<li>用户点击屏幕后产生的一个触摸事件，经过一系列的传递过程后，会找到最合适的视图控件来处理这个事件</li>
<li>找到最合适的视图控件后，就会调用<code>对应控件</code>的touches方法来作具体的事件处理

<ul>
<li>touchesBegan…</li>
<li>touchesMoved…</li>
<li>touchedEnded…</li>
<li>如果没有实现以上方法，就传递给父控件</li>
</ul>
</li>
<li>touches方法的<code>默认做法</code>是将事件<code>顺着响应者链条向上传递</code>，将事件交给上一个响应者进行处理

<ul>
<li>所以在相应控件实现了touches方法，就等于拦截了事件，在拦截控件上进行处理</li>
<li>这里<code>注意UIGestureRecognizer的区别</code>，两个并<code>不互相拦截</code>，要想拦截UIGestureRecognizer的手势处理，需要<code>在子控件上添加相同的手势</code>，<code>实现touches方法是没用的</code></li>
</ul>
</li>
</ul>


<h3>响应者链条</h3>

<ul>
<li>响应者链条：是由多个响应者对象连接起来的链条</li>
<li>作用：能很清楚的看见每个响应者之间的联系，并且可以让一个事件多个对象处理。</li>
<li>响应者对象：能处理事件的对象</li>
<li>响应者链条示意图
<img src="./image/Snip20150616_3.png" alt="" />

<ul>
<li>如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图</li>
<li>在视图层次结构的最顶级视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理</li>
<li>如果window对象也不处理，则其将事件或消息传递给UIApplication对象</li>
<li>如果UIApplication也不能处理该事件或消息，则将其丢弃</li>
</ul>
</li>
</ul>


<h2>事件传递的完整过程</h2>

<ul>
<li><p>先将事件对象由上往下传递(由父控件传递给子控件,也就是<code>从底层到顶层</code>)，找到最合适的控件来处理这个事件。</p></li>
<li><p>调用<code>最合适控件的touches….方法</code></p></li>
<li><p>如果调用了<code>[super touches….];</code>就会将事件顺着响应者链条往上传递，传递给上一个响应者［可以做到<code>一个事件多个控件响应</code>］</p>

<ul>
<li>注意，<code>如果这时，父类实现了touches….方法，但是没有调用[super touches….]，就不会传给上一个响应者，而是以父类的touches….方法解决</code>

<ul>
<li>在继承UIButton的时候就需要注意这一点，自定义button调用[super touches….]是不会传递给父控件的，因为UIButton实现了touches….方法，但是没有调用[super touches….]

<ul>
<li><code>UIButton的addTagert:方法会和touches方法冲突</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>接着就会调用上一个响应者的touches….方法</p></li>
<li>判断上一个响应者

<ul>
<li>如果<code>当前这个view是控制器的view，那么控制器就是上一个响应者</code></li>
<li>如果<code>当前这个view不是控制器的view，那么父控件就是上一个响应者</code></li>
</ul>
</li>
</ul>


<h2>利用事件传递解决需求</h2>

<ul>
<li><p>实例1<br>
<img src="./image/Snip20150616_4.png" alt="" /></p>

<ul>
<li>需求：在点击到按钮的部分时，需要按钮响应，其他部分由绿色view响应

<ul>
<li>问题：由于部分按钮被绿色view覆盖了，所以点击被覆盖的按钮时，还是绿色view响应</li>
<li>解决：自定义绿色view，添加按钮属性，并重写绿色view的-hitTest:withEvent:方法，在里面判断是否在按钮范围内。<br></li>
</ul>


<pre><code class="objc">// 自定义绿色view
@interface TPCView()
/** 按钮 */
@property (weak, nonatomic) IBOutlet UIButton *button;
@end

@implementation TPCView

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{
// 转换成按钮坐标系
CGPoint buttonP = [self convertPoint:point toView:_button];

// 如果点在按钮上，就返回按钮
if ([_button pointInside:buttonP withEvent:event]) {
    return _button;
}

// 其他情况返回本身
return [super hitTest:point withEvent:event];
}
@end
</code></pre></li>
</ul>
</li>
<li><p>实例2</p>

<ul>
<li>开始<br>
<img src="./image/Snip20150616_5.png" alt="" /></li>
<li>点击按钮<br>
<img src="./image/Snip20150616_6.png" alt="" /></li>
<li>点击对话框<br>
<img src="./image/Snip20150616_10.png" alt="" /></li>
<li>需求：点击按钮出现对话框，能对对话框进行点击，并且能对按钮进行拖动（对话框也同时动）</li>
<li>解决：点击按钮时，将对话框设置为按钮的子控件</li>
<li>问题：对话框不在父控件范围内，点击对话框时，无法满足事件传递要求（触摸点不在父控件按钮上，在这里就断了，所以不会去判断其子控件）</li>
<li><p>解决：自定义按钮控件，添加对话框属性，重写按钮的-hitTest:withEvent:方法，在里面判断是否在对话框范围内范围内。<br></p>

<pre><code class="objc">// 控制器中代码
- (IBAction)popChatView:(PopBtn *)sender {
// 弹出对话框
UIButton *chatView = [UIButton buttonWithType:UIButtonTypeCustom];

chatView.bounds = CGRectMake(0, 0, 200, 200);
chatView.center = CGPointMake(100, -100);

[chatView setBackgroundImage:[UIImage imageNamed:@"对话框"] forState:UIControlStateNormal];
[chatView setBackgroundImage:[UIImage imageNamed:@"小孩"] forState:UIControlStateHighlighted];
sender.chatView = chatView;
[sender addSubview:chatView];

}
</code></pre>

<pre><code class="objc">
// 自定义按钮
@implementation PopBtn

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{

// 当前控件上的点转换到chatView上
CGPoint chatP = [self convertPoint:point toView:self.chatView];

// 判断下点在不在chatView上
if ([self.chatView pointInside:chatP withEvent:event]) {
    return self.chatView;
}else{
    return [super hitTest:point withEvent:event];
}

}

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
// 获取UITouch
UITouch *touch = [touches anyObject];

// 获取当前的点
CGPoint curP = [touch locationInView:self];

// 获取上一个的点
CGPoint preP = [touch previousLocationInView:self];

// 获取偏移量
CGFloat offsetX = curP.x - preP.x;
CGFloat OffsetY = curP.y - preP.y;

// 修改控件的位置
CGPoint center = self.center;
center.x += offsetX;
center.y += OffsetY;

self.center = center;

}
@end
</code></pre></li>
</ul>
</li>
<li>总结

<ul>
<li>这种情况下，大都是自定义覆盖需要响应控件的控件，或者子控件超出父控件范围的父控件，然后添加对应需要接收响应的控件属性，重写自定义控件的hitTest方法，在里面将触摸点转换成需要接收响应控件的坐标系，判断是否在其坐标系内，再返回对应的控件
/Snip20150616_10.png)</li>
<li>需求：点击按钮出现对话框，能对对话框进行点击，并且能对按钮进行拖动（对话框也同时动）</li>
<li>解决：点击按钮时，将对话框设置为按钮的子控件</li>
<li>问题：对话框不在父控件范围内，点击对话框时，无法满足事件传递要求（触摸点不在父控件按钮上，在这里就断了，所以不会去判断其子控件）</li>
<li><p>解决：自定义按钮控件，添加对话框属性，重写按钮的-hitTest:withEvent:方法，在里面判断是否在对话框范围内范围内。<br></p>

<pre><code class="objc">// 控制器中代码
- (IBAction)popChatView:(PopBtn *)sender {
// 弹出对话框
UIButton *chatView = [UIButton buttonWithType:UIButtonTypeCustom];

chatView.bounds = CGRectMake(0, 0, 200, 200);
chatView.center = CGPointMake(100, -100);

[chatView setBackgroundImage:[UIImage imageNamed:@"对话框"] forState:UIControlStateNormal];
[chatView setBackgroundImage:[UIImage imageNamed:@"小孩"] forState:UIControlStateHighlighted];
sender.chatView = chatView;
[sender addSubview:chatView];

}
</code></pre>

<pre><code class="objc">
// 自定义按钮
@implementation PopBtn

- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event
{

// 当前控件上的点转换到chatView上
CGPoint chatP = [self convertPoint:point toView:self.chatView];

// 判断下点在不在chatView上
if ([self.chatView pointInside:chatP withEvent:event]) {
    return self.chatView;
}else{
    return [super hitTest:point withEvent:event];
}

}

- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event
{
// 获取UITouch
UITouch *touch = [touches anyObject];

// 获取当前的点
CGPoint curP = [touch locationInView:self];

// 获取上一个的点
CGPoint preP = [touch previousLocationInView:self];

// 获取偏移量
CGFloat offsetX = curP.x - preP.x;
CGFloat OffsetY = curP.y - preP.y;

// 修改控件的位置
CGPoint center = self.center;
center.x += offsetX;
center.y += OffsetY;

self.center = center;

}
@end
</code></pre></li>
</ul>
</li>
<li>总结

<ul>
<li>这种情况下，大都是自定义覆盖需要响应控件的控件，或者子控件超出父控件范围的父控件，然后添加对应需要接收响应的控件属性，重写自定义控件的hitTest方法，在里面将触摸点转换成需要接收响应控件的坐标系，判断是否在其坐标系内，再返回对应的控件</li>
</ul>
</li>
</ul>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">tripleCC</span></span>

      




<time class='entry-date' datetime='2015-09-02T00:20:22+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>12:20 am</span></time>
      


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015-06-03-cheng-xu-bu-si/" title="Previous Post: 程序不死">&laquo; 程序不死</a>
      
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>About Me</h1>
  <p> 喜欢技术，热衷底层，涉略微处理器、linux，最终加入移动大家庭 </p>
</section>

<section>
    <h1>文章分类</h1>
    <ul id="categories">
        
    </ul>
</section><section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015-09-02-shi-yong-xiang-ying-zhe-lian-tiao-jie-jue-xu-qiu/">使用响应者链条解决需求</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-06-03-cheng-xu-bu-si/">程序不死</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-05-31-runloopzhi-shi-shu-li/">Runloop知识梳理</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-04-27-uinavigationbarshu-xing-xiao-jie-ji-fan-hui-an-niu-geng-gai/">UINavigationBar属性小结及返回按钮更改</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-04-10-runtimeying-yong-zhi-guan-lian-dui-xiang-he-methodswizzling/">Runtime应用之关联对象和MethodSwizzling</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-03-02-jing-tai-fen-xi-bu-zhun-que-de-qing-kuang/">静态分析不准确的情况</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-02-10-blockji-qiao-yu-di-ceng-jie-xi/">Block技巧与底层解析</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-02-01-sdwebimagejia-zai-da-tu/">SDWebImage加载大图崩溃</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-01-27-uitextfiledwen-zi-dou-dong-xiao-guo/">UITextFiled文字抖动效果</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-01-22-chang-yong-runtimehan-shu/">常用Runtime函数</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-01-21-runtimeying-yong-zhi-kvc/">Runtime应用之KVC</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-01-10-runtimeji-chu/">Runtime基础</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-01-02-jian-ting-jian-pan-shan-chu-an-niu/">监听键盘删除按钮</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014-12-04-autorezingde-ying-yong/">Preview功能结合Autorezing的应用</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014-11-02-she-zhi-cellzhou-bian-jian-ju/">设置cell周边间距</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014-10-20-uialertcontrollerde-shi-yong/">UIAlertController的使用</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014-10-05-shuang-ji-di-bu-gong-ju-lan-itemdui-ying-uitableviewzhong-xin-shua-xin/">双击底部工具栏Item对应UITableView重新刷新</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014-09-11-zi-ding-yi-uitextview/">自定义UITextView</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014-09-01-zi-ding-yi-ti-shi-hong/">自定义提示宏</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014-08-29-tableviewyou-ce-biao-qian-suo-yin-xu-qiu/">UITableView右侧标签索引需求</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - tripleCC -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>


<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>tripleCC的技术博客</title>
  <meta name="author" content="tripleCC">

  
  <meta name="description" content="去年写了3个UIScrollView实现无限循环的思路，今天和别人讨论的时候，发现还可以用两个UIImageView实现无限循环。实现的大体思路如下： 假设使用UIV1表示始终显示的UIImageView，使用UIV2表示备份的UIImageView 首先，初始状态如下图所示，显示的是图片1（ &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://triplecc.github.io/posts/7/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="tripleCC的技术博客" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://libs.useso.com/js/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.useso.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.useso.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">tripleCC的技术博客</a></h1>
  
    <h2>日拱一卒</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.baidu.com" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="triplecc.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives">所有文章</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014-03-20-uiscrollview2ge-uiimageviewwu-xian-xun-huan/">UIScrollView2个UIImageView无限循环</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-03-20T23:01:01+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>11:01 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>去年写了3个UIScrollView实现无限循环的思路，今天和别人讨论的时候，发现还可以用两个UIImageView实现无限循环。实现的大体思路如下：</p>

<p>假设使用UIV1表示始终显示的UIImageView，使用UIV2表示备份的UIImageView</p>

<ul>
<li>首先，初始状态如下图所示，显示的是图片1（为了方便查看，我把UIImageView下移了，实际上和上面一排重合）<br>

<ul>
<li>初始状态 <br>
<img src="/images/Snip20150630_26.png" alt="初始状态" /><br></li>
</ul>
</li>
<li>这时候，向右边滚动（是滚，不是滑&hellip;），UIV2就立即显示图片2，这是，在屏幕可以看见图片1、2<br>

<ul>
<li>向右滚动<br>
<img src="/images/Snip20150630_27.png" alt="向右滚动" /></li>
</ul>
</li>
<li>当滚动完成时只能看见图片2，如下

<ul>
<li>滚动完成<br>
<img src="/images/Snip20150630_28.png" alt="滚动完成" /></li>
</ul>
</li>
<li>这是，将UIV1的图片换成图片2，同时将UIScrollView的偏移量设置到中间的位置（这个过程很快，实际看不出来有修改和移动）<br>

<ul>
<li>修改图片<br><br/>
<img src="/images/Snip20150630_29.png" alt="修改图片" /><br></li>
<li>修改偏移量<br><br/>
<img src="/images/Snip20150630_30.png" alt="修改偏移量" /></li>
</ul>
</li>
<li>向左滚动的情况<br>

<ul>
<li>左滚动<br><br/>
<img src="/images/Snip20150630_31.png" alt="左滚动" /></li>
</ul>
</li>
<li>立即将UIV2的frame修改至最左边的位置，并设置图片为0<br>

<ul>
<li>左滚动修改UIV2图片并移动<br><br/>
<img src="/images/Snip20150630_32.png" alt="左滚动修改UIV2图片并移动" /></li>
</ul>
</li>
<li>修改完成后情况<br>

<ul>
<li>移动完成<br>
<img src="/images/Snip20150630_33.png" alt="移动完成" /></li>
</ul>
</li>
<li>修改UIV1图片为图片0，并且设置UIScrollView偏移至中间位置<br>

<ul>
<li>修改UIV1图片<br>
<img src="/images/Snip20150630_37.png" alt="修改UIV1图片" /><br></li>
<li>最终显示结果<br>
<img src="/images/Snip20150630_38.png" alt="最终显示结果" /></li>
</ul>
</li>
</ul>


<p>实现整体代码如下，有一个小技巧，使用tag标识对应的image，可以使代码更精简：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">TPCScrollViewByTwoImageView</span><span class="p">()</span> <span class="o">&lt;</span><span class="bp">UIScrollViewDelegate</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">weak</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">UIScrollView</span> <span class="o">*</span><span class="n">scrollView</span><span class="p">;</span>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> *  当前显示的view</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">weak</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">UIImageView</span> <span class="o">*</span><span class="n">currentView</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> *  备份的view（左右滑动时，显示的view）</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">weak</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">UIImageView</span> <span class="o">*</span><span class="n">backupView</span><span class="p">;</span>
</span><span class='line'><span class="k">@end</span>
</span><span class='line'>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">TPCScrollViewByTwoImageView</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">initWithFrame:</span><span class="p">(</span><span class="bp">CGRect</span><span class="p">)</span><span class="nv">frame</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="nl">initWithFrame</span><span class="p">:</span><span class="n">frame</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="n">setUp</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">awakeFromNib</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="n">setUp</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setUp</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 创建需要的三个控件</span>
</span><span class='line'>    <span class="bp">UIScrollView</span> <span class="o">*</span><span class="n">scrollView</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIScrollView</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="n">scrollView</span><span class="p">.</span><span class="n">pagingEnabled</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="n">scrollView</span><span class="p">.</span><span class="n">bounces</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>    <span class="n">scrollView</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>    <span class="n">scrollView</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="n">redColor</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span> <span class="nl">addSubview</span><span class="p">:</span><span class="n">scrollView</span><span class="p">];</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">scrollView</span> <span class="o">=</span> <span class="n">scrollView</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">UIImageView</span> <span class="o">*</span><span class="n">currentView</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIImageView</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">scrollView</span> <span class="nl">addSubview</span><span class="p">:</span><span class="n">currentView</span><span class="p">];</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">currentView</span> <span class="o">=</span> <span class="n">currentView</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">UIImageView</span> <span class="o">*</span><span class="n">backupView</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UIImageView</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">scrollView</span> <span class="nl">addSubview</span><span class="p">:</span><span class="n">backupView</span><span class="p">];</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">backupView</span> <span class="o">=</span> <span class="n">backupView</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="n">greenColor</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">layoutSubviews</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">super</span> <span class="n">layoutSubviews</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">scrollView</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">imageViewW</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">imageViewH</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// 设置scrollView的内容大小</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">scrollView</span><span class="p">.</span><span class="n">contentSize</span> <span class="o">=</span> <span class="n">CGSizeMake</span><span class="p">(</span><span class="n">imageViewW</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 设置imageView的frame</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">currentView</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="n">imageViewW</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">imageViewW</span><span class="p">,</span> <span class="n">imageViewH</span><span class="p">);</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">backupView</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="n">imageViewW</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">imageViewW</span><span class="p">,</span> <span class="n">imageViewH</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setImages:</span><span class="p">(</span><span class="bp">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nv">images</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">_images</span> <span class="o">=</span> <span class="n">images</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 设置默认图片</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">currentView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">backupView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 设置tag为图片下标</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">currentView</span><span class="p">.</span><span class="n">tag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">backupView</span><span class="p">.</span><span class="n">tag</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">scrollView</span><span class="p">.</span><span class="n">contentOffset</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">imageViewW</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">scrollViewDidScroll:</span><span class="p">(</span><span class="bp">UIScrollView</span> <span class="o">*</span><span class="p">)</span><span class="nv">scrollView</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">offsetX</span> <span class="o">=</span> <span class="n">scrollView</span><span class="p">.</span><span class="n">contentOffset</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 根据偏移量，设置backView的图片，并修改其图片下标</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">offsetX</span> <span class="o">&lt;</span> <span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">backupView</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">backupView</span><span class="p">.</span><span class="n">tag</span> <span class="o">=</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">currentView</span><span class="p">.</span><span class="n">tag</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">self</span><span class="p">.</span><span class="n">images</span><span class="p">.</span><span class="n">count</span><span class="p">)</span> <span class="o">%</span> <span class="nb">self</span><span class="p">.</span><span class="n">images</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">backupView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">images</span><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">backupView</span><span class="p">.</span><span class="n">tag</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">offsetX</span> <span class="o">&gt;</span> <span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">backupView</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">backupView</span><span class="p">.</span><span class="n">tag</span> <span class="o">=</span> <span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">currentView</span><span class="p">.</span><span class="n">tag</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">self</span><span class="p">.</span><span class="n">images</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">backupView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">images</span><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">backupView</span><span class="p">.</span><span class="n">tag</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">scrollViewDidEndDecelerating:</span><span class="p">(</span><span class="bp">UIScrollView</span> <span class="o">*</span><span class="p">)</span><span class="nv">scrollView</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">CGFloat</span> <span class="n">offsetX</span> <span class="o">=</span> <span class="n">scrollView</span><span class="p">.</span><span class="n">contentOffset</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 停止时，设置偏移量为currentView所在位置</span>
</span><span class='line'>    <span class="n">scrollView</span><span class="p">.</span><span class="n">contentOffset</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 实际上没有换页，就返回</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">offsetX</span> <span class="o">&lt;</span> <span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="mf">1.5</span> <span class="o">&amp;&amp;</span> <span class="n">offsetX</span> <span class="o">&gt;</span> <span class="nb">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 根据backView的image，来进行图片更换</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">currentView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">backupView</span><span class="p">.</span><span class="n">image</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 设置当前图片下标</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">currentView</span><span class="p">.</span><span class="n">tag</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">backupView</span><span class="p">.</span><span class="n">tag</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014-02-02-ji-ge-layoutfang-fa-zhi-jian-de-guan-xi/">几个layout方法之间的关系</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-02-02T00:15:29+08:00'><span class='date'><span class='date-month'>Feb</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2014</span></span> <span class='time'>12:15 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><ul>
<li><p>layoutIfNeeded</p>

<ul>
<li>如果有<code>刷新标记</code>的话，立刻会调用layoutSubviews<br>
<img src="/images/Snip20150807_3.png" alt="" /></li>
</ul>
</li>
<li><p>setNeedsLayout</p>

<ul>
<li>设置一个<code>刷新标记</code>，在下个更新循环到来时，触发一次layoutSubviews<br>
<img src="/images/Snip20150807_4.png" alt="" /></li>
</ul>
</li>
</ul>


<p>所以如果要<code>立刻</code>获取控件尺寸的话，调用的是<code>layoutIfNeeded</code>;<br>
不需要立刻获取的调用<code>setNeedsLayout</code>。</p>

<ul>
<li>setNeedsDisplay

<ul>
<li>立刻进行重绘</li>
</ul>
</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014-01-10-coreanimation/">CoreAnimation</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-01-10T08:14:19+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>8:14 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><ul>
<li>核心动画执行过程都是在<code>后台</code>,不会阻塞主线程</li>
<li>Core Animation是直接作用在CALayer上的，并非UIView。所以Core Animation的一些方法的消息接受者是CALayer，写UIView无法自动补全</li>
</ul>


<h2>CAAnimation</h2>

<ul>
<li>继承结构
<img src="/images/Snip20150623_12.png" alt="" />

<ul>
<li>所有动画对象的父类，负责控制动画的持续时间和速度，是个<code>抽象类</code>，不能直接使用，应该使用它具体的子类。</li>
<li>常用属性</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="cm">/** 来自CAMediaTiming协议 */</span>
</span><span class='line'><span class="n">duration</span><span class="err">：动画的持续时间</span>
</span><span class='line'><span class="n">repeatCount</span><span class="err">：动画的重复次数</span>
</span><span class='line'><span class="n">repeatDuration</span><span class="err">：动画的重复时间</span>
</span><span class='line'><span class="n">autoreverses</span><span class="err">：自动返回，做相反的动作</span>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm">1、 kCAFillModeRemoved 这个是默认值,也就是说当动画开始前和动画结束后,动画对layer都没有影响,动画结束后,layer会恢复到之前的状态</span>
</span><span class='line'><span class="cm">2、 kCAFillModeForwards 当动画结束后,layer会一直保持着动画最后的状态</span>
</span><span class='line'><span class="cm">3、 kCAFillModeBackwards 在动画开始前,你只要将动画加入了一个layer,layer便立即进入动画的初始状态并等待动画开始.你可以这样设定测试代码,将一个动画加入一个layer的时候延迟5秒执行.然后就会发现在动画没有开始的时候,只要动画被加入了layer,layer便处于动画初始状态</span>
</span><span class='line'><span class="cm">4、 kCAFillModeBoth 这个其实就是上面两个的合成.动画加入后开始之前,layer便处于动画初始状态,动画结束后layer保持动画最后的状态</span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'><span class="n">fillMode</span><span class="err">：决定当前对象在非</span><span class="n">active</span><span class="err">时间段的行为</span><span class="p">.</span><span class="err">比如动画开始之前</span><span class="p">,</span><span class="err">动画结束之后</span>
</span><span class='line'><span class="n">beginTime</span><span class="err">：可以用来设置动画延迟执行时间，若想延迟</span><span class="mi">2</span><span class="n">s</span><span class="err">，就设置为</span><span class="n">CACurrentMediaTime</span><span class="p">()</span><span class="o">+</span><span class="mi">2</span><span class="err">，</span><span class="n">CACurrentMediaTime</span><span class="p">()</span><span class="err">为图层的当前时间</span>
</span><span class='line'>
</span><span class='line'> <span class="cm">/** 自身属性 */</span>
</span><span class='line'> <span class="cm">/**</span>
</span><span class='line'><span class="cm"> CAMediaTimingFunction functionWithName: 加以下常字符串</span>
</span><span class='line'><span class="cm"> 1.kCAMediaTimingFunctionLinear（线性）：匀速，给你一个相对静态的感觉</span>
</span><span class='line'><span class="cm">2.kCAMediaTimingFunctionEaseIn（渐进）：动画缓慢进入，然后加速离开</span>
</span><span class='line'><span class="cm">3.kCAMediaTimingFunctionEaseOut（渐出）：动画全速进入，然后减速的到达目的地</span>
</span><span class='line'><span class="cm">4.kCAMediaTimingFunctionEaseInEaseOut（渐进渐出）：动画缓慢的进入，中间加速，然后减速的到达目的地。这个是默认的动画行为。</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="n">timingFunction</span><span class="err">：速度控制函数，控制动画运行的节奏</span>
</span><span class='line'><span class="n">delegate</span><span class="err">：动画代理</span>
</span><span class='line'><span class="n">removedOnCompletion</span><span class="err">：默认为</span><span class="nb">YES</span><span class="err">，代表动画执行完毕后就从图层上移除，图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为</span><span class="nb">NO</span><span class="err">，不过还要设置</span><span class="n">fillMode</span><span class="err">为</span><span class="n">kCAFillModeForwards</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>取消动画反弹<br>
<img src="/images/Snip20150623_11.png" alt="" /><br></li>
<li>CALayer上动画的暂停和恢复</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// t - active local time   图层的本地时间</span>
</span><span class='line'><span class="c1">// tp - parent layer time  父图层的时间</span>
</span><span class='line'><span class="c1">// 父图层和图层本地的时间换算公式</span>
</span><span class='line'><span class="c1">// t = (tp - beginTime) * speed + timeOffset</span>
</span><span class='line'><span class="c1">// beginTime = tp - (t - timeOffset)/speed</span>
</span><span class='line'><span class="cp">#pragma mark 暂停CALayer的动画</span>
</span><span class='line'><span class="p">-(</span><span class="kt">void</span><span class="p">)</span><span class="nf">pauseLayer:</span><span class="p">(</span><span class="bp">CALayer</span><span class="o">*</span><span class="p">)</span><span class="nv">layer</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">CFTimeInterval</span> <span class="n">pausedTime</span> <span class="o">=</span> <span class="p">[</span><span class="n">layer</span> <span class="nl">convertTime</span><span class="p">:</span><span class="n">CACurrentMediaTime</span><span class="p">()</span> <span class="nl">fromLayer</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="c1">// 让CALayer的时间停止走动</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">timeOffset</span> <span class="o">=</span> <span class="n">pausedTime</span><span class="p">;</span> <span class="c1">// 让CALayer的时间停留在pausedTime这个时刻</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="cp">#pragma mark 恢复CALayer的动画</span>
</span><span class='line'><span class="p">-(</span><span class="kt">void</span><span class="p">)</span><span class="nf">resumeLayer:</span><span class="p">(</span><span class="bp">CALayer</span><span class="o">*</span><span class="p">)</span><span class="nv">layer</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">CFTimeInterval</span> <span class="n">pausedTime</span> <span class="o">=</span> <span class="n">layer</span><span class="p">.</span><span class="n">timeOffset</span><span class="p">;</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">speed</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span> <span class="c1">// 让CALayer的时间继续行走</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">timeOffset</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="c1">// 取消上次记录的停留时刻</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">beginTime</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span> <span class="c1">// 取消上次设置的时间</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 计算暂停的时间(这里用CACurrentMediaTime()-pausedTime也是一样的)</span>
</span><span class='line'>    <span class="n">CFTimeInterval</span> <span class="n">timeSincePause</span> <span class="o">=</span> <span class="p">[</span><span class="n">layer</span> <span class="nl">convertTime</span><span class="p">:</span><span class="n">CACurrentMediaTime</span><span class="p">()</span> <span class="nl">fromLayer</span><span class="p">:</span><span class="nb">nil</span><span class="p">]</span> <span class="o">-</span> <span class="n">pausedTime</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// 设置相对于父坐标系的开始时间(往后退timeSincePause)</span>
</span><span class='line'>    <span class="n">layer</span><span class="p">.</span><span class="n">beginTime</span> <span class="o">=</span> <span class="n">timeSincePause</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>CAPropertyAnimation</h3>

<ul>
<li>是CAAnimation的子类，也是个抽象类，要想创建动画对象，应该使用它的两个子类：CABasicAnimation和CAKeyframeAnimation</li>
<li>属性</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">keyPath</span><span class="err">：通过指定</span><span class="bp">CALayer</span><span class="err">的一个属性名称为</span><span class="n">keyPath</span><span class="p">(</span><span class="bp">NSString</span><span class="err">类型</span><span class="p">)</span><span class="err">，并且对</span><span class="bp">CALayer</span><span class="err">的这个属性的值进行修改，达到相应的动画效果。比如，指定</span><span class="p">@</span><span class="err">”</span><span class="n">position</span><span class="err">”为</span><span class="n">keyPath</span><span class="err">，就修改</span><span class="bp">CALayer</span><span class="err">的</span><span class="n">position</span><span class="err">属性的值，以达到平移的动画效果</span>
</span></code></pre></td></tr></table></div></figure>


<h4>CABasicAnimation</h4>

<ul>
<li>属性</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">fromValue</span><span class="err">：</span><span class="n">keyPath</span><span class="err">相应属性的初始值</span>
</span><span class='line'><span class="n">toValue</span><span class="err">：</span><span class="n">keyPath</span><span class="err">相应属性的结束值</span>
</span><span class='line'><span class="nl">byValue</span><span class="p">:</span> <span class="err">在当前基础增加属性值</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>随着动画的进行，在长度为duration的持续时间内，keyPath相应属性的值从fromValue渐渐地变为toValue
如果fillMode=kCAFillModeForwards和removedOnComletion=NO，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。比如，CALayer的position初始值为(0,0)，CABasicAnimation的fromValue为(10,10)，toValue为(100,100)，虽然动画执行完毕后图层保持在(100,100)这个位置，实质上图层的position还是为(0,0);也就是说<code>核心动画一切都是虚的，都是表象，不会真实地改变图层属性</code>，而UIView动画则不一样，<code>UIView动画需要通过修改属性的真实值才会有动画效果</code></li>
<li>代码示例</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 平移动画</span>
</span><span class='line'><span class="bp">CABasicAnimation</span> <span class="o">*</span><span class="n">anim</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CABasicAnimation</span> <span class="nl">animationWithKeyPath</span><span class="p">:</span><span class="s">@&quot;position&quot;</span><span class="p">];</span>
</span><span class='line'><span class="n">anim</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 动画持续1秒</span>
</span><span class='line'><span class="c1">// 因为CGPoint是结构体，所以用NSValue包装成一个OC对象</span>
</span><span class='line'><span class="n">anim</span><span class="p">.</span><span class="n">fromValue</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSValue</span> <span class="nl">valueWithCGPoint</span><span class="p">:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)];</span>
</span><span class='line'><span class="n">anim</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSValue</span> <span class="nl">valueWithCGPoint</span><span class="p">:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)];</span>
</span><span class='line'><span class="c1">// 在当前位置的基础上增加多少</span>
</span><span class='line'><span class="c1">// anima.byValue = [NSValue valueWithCGPoint:CGPointMake(0, 300)];</span>
</span><span class='line'><span class="p">[</span><span class="n">layer</span> <span class="nl">addAnimation</span><span class="p">:</span><span class="n">anim</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;MyAnim&quot;</span><span class="p">];</span>
</span><span class='line'><span class="c1">// 通过MyAnim可以取回相应的动画对象，比如用来中途取消动画</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 缩放动画</span>
</span><span class='line'><span class="bp">CABasicAnimation</span> <span class="o">*</span><span class="n">anim</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CABasicAnimation</span> <span class="nl">animationWithKeyPath</span><span class="p">:</span><span class="s">@&quot;transform&quot;</span><span class="p">];</span>
</span><span class='line'><span class="c1">// 没有设置fromValue说明当前状态作为初始值</span>
</span><span class='line'><span class="c1">// 宽度(width)变为原来的2倍，高度(height)变为原来的1.5倍</span>
</span><span class='line'><span class="n">anim</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSValue</span> <span class="nl">valueWithCATransform3D</span><span class="p">:</span><span class="n">CATransform3DMakeScale</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)];</span>
</span><span class='line'><span class="n">anim</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">layer</span> <span class="nl">addAnimation</span><span class="p">:</span><span class="n">anim</span> <span class="nl">forKey</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 旋转动画</span>
</span><span class='line'><span class="bp">CABasicAnimation</span> <span class="o">*</span><span class="n">anim</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CABasicAnimation</span> <span class="nl">animationWithKeyPath</span><span class="p">:</span><span class="s">@&quot;transform&quot;</span><span class="p">];</span>
</span><span class='line'><span class="c1">// 这里是以向量(1, 1, 0)为轴，旋转π/2弧度(90°)</span>
</span><span class='line'><span class="c1">// 如果只是在手机平面上旋转，就设置向量为(0, 0, 1)，即Z轴</span>
</span><span class='line'><span class="n">anim</span><span class="p">.</span><span class="n">toValue</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSValue</span> <span class="nl">valueWithCATransform3D</span><span class="p">:</span><span class="n">CATransform3DMakeRotation</span><span class="p">(</span><span class="n">M_PI_2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)];</span>
</span><span class='line'><span class="n">anim</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">layer</span> <span class="nl">addAnimation</span><span class="p">:</span><span class="n">anim</span> <span class="nl">forKey</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h4>CAKeyframeAnimation</h4>

<ul>
<li>CApropertyAnimation的子类，跟CABasicAnimation的区别是：CABasicAnimation只能从一个数值(fromValue)变到另一个数值(toValue)，而CAKeyframeAnimation会使用一个NSArray保存这些数值;

<ul>
<li>CABasicAnimation可看做是最多只有2个关键帧的CAKeyframeAnimation</li>
</ul>
</li>
<li>属性</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">values</span><span class="err">：就是上述的</span><span class="bp">NSArray</span><span class="err">对象。里面的元素称为”关键帧”</span><span class="p">(</span><span class="n">keyframe</span><span class="p">)</span><span class="err">。动画对象会在指定的时间</span><span class="p">(</span><span class="n">duration</span><span class="p">)</span><span class="err">内，依次显示</span><span class="n">values</span><span class="err">数组中的每一个关键帧</span>
</span><span class='line'><span class="n">path</span><span class="err">：可以设置一个</span><span class="n">CGPathRef</span><span class="err">\</span><span class="n">CGMutablePathRef</span><span class="p">,</span><span class="err">让层跟着路径移动。</span><span class="n">path</span><span class="err">只对</span><span class="bp">CALayer</span><span class="err">的</span><span class="n">anchorPoint</span><span class="err">和</span><span class="n">position</span><span class="err">起作用。如果你设置了</span><span class="n">path</span><span class="err">，那么</span><span class="n">values</span><span class="err">将被忽略</span>
</span><span class='line'><span class="c1">// 如有5个关键帧，则值可为@[@(0.1), @(0.4), @(0.5), @(0.7), @(1.0)]。注意，这其中的元素是时间点，而不是时间段，所以后面的要大于前面的值。</span>
</span><span class='line'><span class="n">keyTimes</span><span class="err">：可以为对应的关键帧指定对应的时间点</span><span class="p">,</span><span class="err">其取值范围为</span><span class="mi">0</span><span class="err">到</span><span class="mf">1.0</span><span class="p">,</span><span class="n">keyTimes</span><span class="err">中的每一个时间值都对应</span><span class="n">values</span><span class="err">中的每一帧</span><span class="p">.</span><span class="err">当</span><span class="n">keyTimes</span><span class="err">没有设置的时候</span><span class="p">,</span><span class="err">各个关键帧的时间是平分的。</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm">kCAAnimationLinear calculationMode的默认值,表示当关键帧为座标点的时候,关键帧之间直接直线相连进行插值计算;</span>
</span><span class='line'><span class="cm">kCAAnimationDiscrete 离散的,就是不进行插值计算,所有关键帧直接逐个进行显示;</span>
</span><span class='line'><span class="cm">kCAAnimationPaced 使得动画均匀进行,而不是按keyTimes设置的或者按关键帧平分时间,此时keyTimes和timingFunctions无效;</span>
</span><span class='line'><span class="cm">kCAAnimationCubic 对关键帧为座标点的关键帧进行圆滑曲线相连后插值计算，这里的主要目的是使得运行的轨迹变得圆滑；</span>
</span><span class='line'><span class="cm">kCAAnimationCubicPaced 看这个名字就知道和kCAAnimationCubic有一定联系,其实就是在kCAAnimationCubic的基础上使得动画运行变得均匀,就是系统时间内运动的距离相同,此时keyTimes以及timingFunctions也是无效的</span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'><span class="c1">// 针对的是每一帧的内容为一个座标点的情况,也就是对anchorPoint 和 position 进行的动画.当在平面座标系中有多个离散的点的时候,可以是离散的,也可以直线相连后进行插值计算,也可以使用圆滑的曲线将他们相连后进行插值计算</span>
</span><span class='line'><span class="n">calculationMode</span><span class="err">：</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>图标抖动</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="c1">// 1.创建核心动画</span>
</span><span class='line'>    <span class="bp">CAKeyframeAnimation</span>  <span class="o">*</span><span class="n">keyAnima</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CAKeyframeAnimation</span> <span class="n">animation</span><span class="p">];</span>
</span><span class='line'>    <span class="n">keyAnima</span><span class="p">.</span><span class="n">keyPath</span> <span class="o">=</span> <span class="s">@&quot;transform.rotation&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// 度数 / 180 * M_PI</span>
</span><span class='line'>    <span class="n">keyAnima</span><span class="p">.</span><span class="n">values</span> <span class="o">=</span> <span class="l">@[@(</span><span class="o">-</span><span class="n">M_PI_4</span> <span class="o">*</span> <span class="mf">0.1</span><span class="l">)</span><span class="p">,</span> <span class="l">@(</span><span class="n">M_PI_4</span> <span class="o">*</span> <span class="mf">0.1</span><span class="l">)</span><span class="p">,</span> <span class="l">@(</span><span class="o">-</span><span class="n">M_PI_4</span> <span class="o">*</span> <span class="mf">0.1</span><span class="l">)]</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">keyAnima</span><span class="p">.</span><span class="n">removedOnCompletion</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>    <span class="n">keyAnima</span><span class="p">.</span><span class="n">fillMode</span> <span class="o">=</span> <span class="n">kCAFillModeForwards</span><span class="p">;</span>
</span><span class='line'>    <span class="n">keyAnima</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 设置动画重复的次数</span>
</span><span class='line'>    <span class="n">keyAnima</span><span class="p">.</span><span class="n">repeatCount</span> <span class="o">=</span> <span class="n">MAXFLOAT</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 2.添加核心动画</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">iconView</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addAnimation</span><span class="p">:</span><span class="n">keyAnima</span> <span class="nl">forKey</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h4>CAAnimationGroup</h4>

<ul>
<li>CAAnimation的子类，可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行

<ul>
<li>默认情况下，一组动画对象是同时运行的，也可以通过<code>设置动画对象的beginTime属性</code>来<code>更改动画的开始时间</code></li>
</ul>
</li>
<li>属性</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">animations</span><span class="err">：用来保存一组动画对象的</span><span class="bp">NSArray</span>
</span></code></pre></td></tr></table></div></figure>


<h4>CATransition</h4>

<ul>
<li>CAAnimation的子类，用于做转场动画，能够为层提供移出屏幕和移入屏幕的动画效果。iOS比Mac OS X的转场动画效果少一点</li>
<li>UINavigationController就是通过CATransition实现了将控制器的视图推入屏幕的动画效果</li>
<li>属性</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cm">/* 过渡效果</span>
</span><span class='line'><span class="cm"> fade     //交叉淡化过渡(不支持过渡方向) kCATransitionFade</span>
</span><span class='line'><span class="cm"> push     //新视图把旧视图推出去  kCATransitionPush</span>
</span><span class='line'><span class="cm"> moveIn   //新视图移到旧视图上面   kCATransitionMoveIn</span>
</span><span class='line'><span class="cm"> reveal   //将旧视图移开,显示下面的新视图  kCATransitionReveal</span>
</span><span class='line'><span class="cm"> cube     //立方体翻滚效果</span>
</span><span class='line'><span class="cm"> oglFlip  //上下左右翻转效果</span>
</span><span class='line'><span class="cm"> suckEffect   //收缩效果，如一块布被抽走(不支持过渡方向)</span>
</span><span class='line'><span class="cm"> rippleEffect //滴水效果(不支持过渡方向)</span>
</span><span class='line'><span class="cm"> pageCurl     //向上翻页效果</span>
</span><span class='line'><span class="cm"> pageUnCurl   //向下翻页效果</span>
</span><span class='line'><span class="cm"> cameraIrisHollowOpen  //相机镜头打开效果(不支持过渡方向)</span>
</span><span class='line'><span class="cm"> cameraIrisHollowClose //相机镜头关上效果(不支持过渡方向)</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="n">type</span><span class="err">：动画过渡类型</span>
</span><span class='line'><span class="cm">/* 过渡方向</span>
</span><span class='line'><span class="cm">kCATransitionFromRight</span>
</span><span class='line'><span class="cm">kCATransitionFromLeft</span>
</span><span class='line'><span class="cm">kCATransitionFromBottom</span>
</span><span class='line'><span class="cm">kCATransitionFromTop</span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'><span class="n">subtype</span><span class="err">：动画过渡方向</span>
</span><span class='line'><span class="n">startProgress</span><span class="err">：动画起点</span><span class="p">(</span><span class="err">在整体动画的百分比</span><span class="p">)</span>
</span><span class='line'><span class="n">endProgress</span><span class="err">：动画终点</span><span class="p">(</span><span class="err">在整体动画的百分比</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>代码示例

<ul>
<li>转场一般分为转场代码和转场动画</li>
<li>转场代码和转场动画一定要写在一起</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="bp">CATransition</span> <span class="o">*</span><span class="n">anim</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CATransition</span> <span class="n">animation</span><span class="p">];</span>
</span><span class='line'><span class="n">anim</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="p">@</span><span class="err">“</span><span class="n">cube</span><span class="err">”</span><span class="p">;</span> <span class="c1">// 动画过渡类型</span>
</span><span class='line'><span class="n">anim</span><span class="p">.</span><span class="n">subtype</span> <span class="o">=</span> <span class="n">kCATransitionFromTop</span><span class="p">;</span> <span class="c1">// 动画过渡方向</span>
</span><span class='line'><span class="n">anim</span><span class="p">.</span><span class="n">duration</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 动画持续1s</span>
</span><span class='line'><span class="c1">// 代理，动画执行完毕后会调用delegate的animationDidStop:finished:</span>
</span><span class='line'><span class="c1">// anim.delegate = self;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/*******中间穿插改变layer属性的代码**********/</span>
</span><span class='line'>
</span><span class='line'><span class="p">[</span><span class="n">layer</span> <span class="nl">addAnimation</span><span class="p">:</span><span class="n">anim</span> <span class="nl">forKey</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>UIView动画</h3>

<ul>
<li>UIKit直接将动画集成到UIView类中，当内部的一些属性发生改变时，UIView将为这些改变提供动画支持
执行动画所需要的工作由UIView类自动完成，但仍要在希望执行动画时通知视图，为此需要将改变属性的代码放在<code>[UIView beginAnimations:nil context:nil]和[UIView commitAnimations]</code>之间</li>
<li>常见方法</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setAnimationDelegate:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">delegate</span>
</span><span class='line'><span class="c1">// 设置动画代理对象，当动画开始或者结束时会发消息给代理对象</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setAnimationWillStartSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">selector</span>
</span><span class='line'><span class="c1">// 当动画即将开始时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setAnimationDidStopSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">selector</span>
</span><span class='line'><span class="c1">// 当动画结束时，执行delegate对象的selector，并且把beginAnimations:context:中传入的参数传进selector</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setAnimationDuration:</span><span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nv">duration</span>
</span><span class='line'><span class="c1">// 动画的持续时间，秒为单位</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setAnimationDelay:</span><span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nv">delay</span>
</span><span class='line'><span class="c1">// 动画延迟delay秒后再开始</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setAnimationStartDate:</span><span class="p">(</span><span class="bp">NSDate</span> <span class="o">*</span><span class="p">)</span><span class="nv">startDate</span>
</span><span class='line'><span class="c1">// 动画的开始时间，默认为now</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 动画的节奏控制，跟CAAnimation的timingFunction属性类似</span>
</span><span class='line'><span class="k">typedef</span> <span class="nf">NS_ENUM</span><span class="p">(</span><span class="bp">NSInteger</span><span class="p">,</span> <span class="n">UIViewAnimationCurve</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">UIViewAnimationCurveEaseInOut</span><span class="p">,</span>         <span class="c1">// slow at beginning and end</span>
</span><span class='line'>    <span class="n">UIViewAnimationCurveEaseIn</span><span class="p">,</span>            <span class="c1">// slow at beginning</span>
</span><span class='line'>    <span class="n">UIViewAnimationCurveEaseOut</span><span class="p">,</span>           <span class="c1">// slow at end</span>
</span><span class='line'>    <span class="n">UIViewAnimationCurveLinear</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setAnimationCurve:</span><span class="p">(</span><span class="n">UIViewAnimationCurve</span><span class="p">)</span><span class="nv">curve</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 动画的节奏控制,具体看下面的”备注”</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setAnimationRepeatCount:</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="nv">repeatCount</span>
</span><span class='line'><span class="c1">// 动画的重复次数</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setAnimationRepeatAutoreverses:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">repeatAutoreverses</span>
</span><span class='line'><span class="c1">// 如果设置为YES,代表动画每次重复执行的效果会跟上一次相反</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setAnimationTransition:</span><span class="p">(</span><span class="n">UIViewAnimationTransition</span><span class="p">)</span><span class="nv">transition</span> <span class="nf">forView:</span><span class="p">(</span><span class="bp">UIView</span> <span class="o">*</span><span class="p">)</span><span class="nv">view</span> <span class="nf">cache:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">cache</span>
</span><span class='line'><span class="c1">// 设置视图view的过渡效果, transition指定过渡类型, cache设置YES代表使用视图缓存，性能较好</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Block动画</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm">duration：动画的持续时间</span>
</span><span class='line'><span class="cm">delay：动画延迟delay秒后开始</span>
</span><span class='line'>
</span><span class='line'><span class="cm">// 动画的节奏控制枚举常量</span>
</span><span class='line'><span class="cm">// UIViewAnimationOptionCurveEaseInOut</span>
</span><span class='line'><span class="cm">// UIViewAnimationOptionCurveEaseIn</span>
</span><span class='line'><span class="cm">// UIViewAnimationOptionCurveEaseOut</span>
</span><span class='line'><span class="cm">// UIViewAnimationOptionCurveLinear</span>
</span><span class='line'><span class="cm">options：动画的节奏控制</span>
</span><span class='line'>
</span><span class='line'><span class="cm">animations：将改变视图属性的代码放在这个block中</span>
</span><span class='line'><span class="cm">completion：动画结束后，会自动调用这个block</span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">animateWithDuration:</span><span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nv">duration</span> <span class="nf">delay:</span><span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nv">delay</span> <span class="nf">options:</span><span class="p">(</span><span class="n">UIViewAnimationOptions</span><span class="p">)</span><span class="nv">options</span> <span class="nf">animations:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="nv">animations</span> <span class="nf">completion:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">BOOL</span> <span class="n">finished</span><span class="p">))</span><span class="nv">completion</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm">duration：动画的持续时间</span>
</span><span class='line'><span class="cm">view：需要进行转场动画的视图</span>
</span><span class='line'>
</span><span class='line'><span class="cm">// 转场动画的类型</span>
</span><span class='line'><span class="cm">//UIViewAnimationOptionTransitionNone</span>
</span><span class='line'><span class="cm">//UIViewAnimationOptionTransitionFlipFromLeft</span>
</span><span class='line'><span class="cm">//UIViewAnimationOptionTransitionFlipFromRight</span>
</span><span class='line'><span class="cm">//UIViewAnimationOptionTransitionCurlUp</span>
</span><span class='line'><span class="cm">//UIViewAnimationOptionTransitionCurlDown</span>
</span><span class='line'><span class="cm">//UIViewAnimationOptionTransitionCrossDissolve</span>
</span><span class='line'><span class="cm">//UIViewAnimationOptionTransitionFlipFromTop</span>
</span><span class='line'><span class="cm">//UIViewAnimationOptionTransitionFlipFromBottom</span>
</span><span class='line'><span class="cm">options：转场动画的类型</span>
</span><span class='line'>
</span><span class='line'><span class="cm">animations：将改变视图属性的代码放在这个block中</span>
</span><span class='line'><span class="cm">completion：动画结束后，会自动调用这个block</span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">transitionWithView:</span><span class="p">(</span><span class="bp">UIView</span> <span class="o">*</span><span class="p">)</span><span class="nv">view</span> <span class="nf">duration:</span><span class="p">(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="nv">duration</span> <span class="nf">options:</span><span class="p">(</span><span class="n">UIViewAnimationOptions</span><span class="p">)</span><span class="nv">options</span> <span class="nf">animations:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="nv">animations</span> <span class="nf">completion:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">BOOL</span> <span class="n">finished</span><span class="p">))</span><span class="nv">completion</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm">duration：动画的持续时间</span>
</span><span class='line'><span class="cm">options：转场动画的类型</span>
</span><span class='line'><span class="cm">animations：将改变视图属性的代码放在这个block中</span>
</span><span class='line'><span class="cm">completion：动画结束后，会自动调用这个block</span>
</span><span class='line'><span class="cm">*/</span>
</span><span class='line'> <span class="o">+</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">transitionFromView</span><span class="p">:(</span><span class="bp">UIView</span> <span class="o">*</span><span class="p">)</span><span class="n">fromView</span> <span class="nl">toView</span><span class="p">:(</span><span class="bp">UIView</span> <span class="o">*</span><span class="p">)</span><span class="n">toView</span> <span class="nl">duration</span><span class="p">:(</span><span class="n">NSTimeInterval</span><span class="p">)</span><span class="n">duration</span> <span class="nl">options</span><span class="p">:(</span><span class="n">UIViewAnimationOptions</span><span class="p">)</span><span class="n">options</span> <span class="nl">completion</span><span class="p">:(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">BOOL</span> <span class="n">finished</span><span class="p">))</span><span class="n">completion</span>
</span><span class='line'>
</span><span class='line'> <span class="c1">// 以上方法调用相当于以下两句</span>
</span><span class='line'> <span class="c1">// 添加toView到父视图</span>
</span><span class='line'><span class="p">[</span><span class="n">fromView</span><span class="p">.</span><span class="n">superview</span> <span class="nl">addSubview</span><span class="p">:</span><span class="n">toView</span><span class="p">];</span>
</span><span class='line'><span class="c1">// 把fromView从父视图中移除</span>
</span><span class='line'><span class="p">[</span><span class="n">fromView</span><span class="p">.</span><span class="n">superview</span> <span class="n">removeFromSuperview</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>UIImageView的帧动画</h3>

<ul>
<li>UIImageView可以让一系列的图片在特定的时间内按顺序显示</li>
<li>属性</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">animationImages</span><span class="err">：要显示的图片</span><span class="p">(</span><span class="err">一个装着</span><span class="bp">UIImage</span><span class="err">的</span><span class="bp">NSArray</span><span class="p">)</span>
</span><span class='line'><span class="n">animationDuration</span><span class="err">：完整地显示一次</span><span class="n">animationImages</span><span class="err">中的所有图片所需的时间</span>
</span><span class='line'><span class="n">animationRepeatCount</span><span class="err">：动画的执行次数</span><span class="p">(</span><span class="err">默认为</span><span class="mi">0</span><span class="err">，代表无限循环</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>方法</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">startAnimating</span><span class="p">;</span> <span class="err">开始动画</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">stopAnimating</span><span class="p">;</span>  <span class="err">停止动画</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="n">isAnimating</span><span class="p">;</span>  <span class="err">是否正在运行动画</span>
</span></code></pre></td></tr></table></div></figure>


<h3>UIActivityIndicatorView动画</h3>

<ul>
<li>是一个旋转进度轮，可以用来告知用户有一个操作正在进行中，一般用initWithActivityIndicatorStyle初始化</li>
<li>方法</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">startAnimating</span><span class="p">;</span> <span class="err">开始动画</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">stopAnimating</span><span class="p">;</span>  <span class="err">停止动画</span>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="n">isAnimating</span><span class="p">;</span>  <span class="err">是否正在运行动画</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>UIActivityIndicatorViewStyle有3个值可供选择：</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">UIActivityIndicatorViewStyleWhiteLarge</span>   <span class="c1">//大型白色指示器</span>
</span><span class='line'><span class="n">UIActivityIndicatorViewStyleWhite</span>      <span class="c1">//标准尺寸白色指示器</span>
</span><span class='line'><span class="n">UIActivityIndicatorViewStyleGray</span>    <span class="c1">//灰色指示器，用于白色背景</span>
</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014-01-01-calayer/">CALayer</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-01-01T22:08:09+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2014</span></span> <span class='time'>10:08 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><ul>
<li><img src="/images/Snip20150623_2.png" alt="" /></li>
<li>UIView之所以能显示在屏幕上，完全是因为它内部的一个图层

<ul>
<li>UIView本身不具备显示的功能，是它<code>内部的层才有显示功能</code></li>
</ul>
</li>
<li>在创建UIView对象时，UIView内部会<code>自动创建一个图层</code>(即CALayer对象)，通过UIView的layer属性可以访问这个层(<code>根图层</code>)

<ul>
<li>从这里也可以看出：如果一个控件是另外一个控件的子控件, 那么这个控件中的layer也是另外一个控件的子layer</li>
</ul>
</li>
<li>当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在<code>自己的图层</code>上，绘图完毕后，系统会<code>将图层拷贝到屏幕上</code>，于是就完成了UIView的显示</li>
<li>常用属性

<ul>
<li><code>UI框架的需要转换成CG框架</code>，直接在UI对象后加CG&hellip;就行</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cm">/** 阴影 */</span>
</span><span class='line'><span class="c1">// 不透明</span>
</span><span class='line'><span class="k">@property</span> <span class="kt">float</span> <span class="n">shadowOpacity</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 偏移</span>
</span><span class='line'><span class="k">@property</span> <span class="bp">CGSize</span> <span class="n">shadowOffset</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 圆角</span>
</span><span class='line'><span class="k">@property</span> <span class="n">CGFloat</span> <span class="n">shadowRadius</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 颜色</span>
</span><span class='line'><span class="k">@property</span> <span class="n">CGColorRef</span> <span class="n">shadowColor</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 阴影外形</span>
</span><span class='line'><span class="k">@property</span> <span class="n">CGPathRef</span> <span class="n">shadowPath</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/** 圆角 */</span>
</span><span class='line'><span class="k">@property</span> <span class="n">CGFloat</span> <span class="n">cornerRadius</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="cm">/** 边框 */</span>
</span><span class='line'><span class="c1">// 宽度</span>
</span><span class='line'><span class="k">@property</span> <span class="n">CGFloat</span> <span class="n">borderWidth</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 颜色</span>
</span><span class='line'><span class="k">@property</span> <span class="n">CGColorRef</span> <span class="n">borderColor</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>UIImageView的layer

<ul>
<li>可以通过以下代码实现显示圆形图片</li>
</ul>


<pre><code class="objc">// 设置主层边框
_imageView.layer.cornerRadius = _imageView.bounds.size.width * 0.5;
// 超出主层进行遮盖
_imageView.layer.masksToBounds = YES;
</code></pre>

<ul>
<li>以上第一句表示对<code>主层圆角</code>进行设置,注意，是<code>主层(创建view时，系统自动创建的那个layer)</code>，因为图片是在<code>contents层上</code>的，所以设置对他无效，只有设置了masksToBounds 属性才可以显示圆形

<ul>
<li><code>contents层</code>：专门显示内容(图片)的层, 传递的是CGImageRef
转化的成的对象<br>
<img src="/images/Snip20150623_21.png" alt="" /></li>
</ul>
</li>
<li>注意：这里使用以上方法盖的是<code>控件图层layer</code>的显示，而以前Quartz2D修改的是<code>图片</code>

<ul>
<li>在控件为<code>正方形</code>的情况下可以<code>使用这种方式</code>，但是如果<code>不是</code>的话还是需要<code>使用以前的方式</code></li>
<li>注意：<code>设置了超出主图层剪切后，阴影会无法显示</code>， 如果<code>要阴影，又要剪切图片</code>，则先<code>用quart-2d将图片剪切成想要的形状，再添加进图层</code></li>
</ul>
</li>
</ul>
</li>
<li><p>形变属性操作</p>

<pre><code class="objc">@property CATransform3D transform;
</code></pre>

<ul>
<li>1.可以使用KVC方式

<ul>
<li>支持的key<br>
<img src="/images/Snip20150623_6.png" alt="" /></li>
<li>用KVC时要用<code>keyPath</code>，不要用key</li>
<li>value的值一定是属性的类型才行</li>
<li>利用KVC可以快速的进行<code>二维旋转</code>和宽,高同时缩放.</li>
</ul>
</li>
</ul>


<pre><code class="objc">[_imageView.layer setValue:@(0.5) forKeyPath:@"transform.scale"];
</code></pre>

<ul>
<li>2.可以使用CATransform3D函数

<ul>
<li>CGA开头的为二维</li>
<li>CA开头的为三维</li>
</ul>
</li>
</ul>


<pre><code class="objc">_imageView.layer.transform = CATransform3DMakeScale(0.5, 0.5, 1);
</code></pre>

<ul>
<li>图层旋转

<ul>
<li>给三维坐标系的点，与原点形成<code>向量</code>，绕着向量旋转，加动画演示旋转效果</li>
</ul>
</li>
</ul>
</li>
<li>新建的子图层

<ul>
<li>通过以下语句，可以给新建图层<code>添加图片</code></li>
</ul>


<pre><code class="objc">UIImage *image = [UIImage imageNamed:@"阿狸头像"];
  layer.contents = (id)image.CGImage;
</code></pre>

<ul>
<li>隐式动画

<ul>
<li>只有<code>非根图层</code>才<code>有隐式动画</code>，即<code>自己建的CALayer对</code>象，而不是创建View时系统帮我们创建的。</li>
<li>具有隐式动画的属性，在头文件中包含<code>animatable</code>注释，查找即可,<code>大部分属性都支持隐式动画</code>

<ul>
<li>修改隐式动画属性，会有默认的动画效果</li>
<li>关闭隐式动画

<ul>
<li>通过CATransaction动画事务</li>
</ul>
</li>
</ul>


<pre><code class="objc">[CATransaction begin];
[CATransaction setDisableActions:YES];
self.myView.layer.position = CGPointMake(10, 10);
[CATransaction commit];
</code></pre>

<ul>
<li>设置隐式动画时间</li>
</ul>


<pre><code class="objc">[CATransaction setAnimationDuration:1.0];
</code></pre>

<ul>
<li>设置动画执行完毕后执行的block</li>
</ul>


<pre><code class="objc"> // 在修改属性代码段之前调用
  + (void)setCompletionBlock:(void (^)(void))block;
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>位置和锚点</p>

<pre><code class="objc">// 位置(默认指中点，具体由anchorPoint决定)
@property CGPoint position;
// 锚点(x,y的范围都是0-1)，决定了position的含义
@property CGPoint anchorPoint;
</code></pre>

<ul>
<li>position用来设置CALayer在<code>父层中</code>的位置

<ul>
<li>以父层的左上角为原点（0，0）</li>
<li>默认是<code>（0，0）</code></li>
</ul>
</li>
<li>anchorPoint决定CALayer<code>身上的哪个点</code>会在position属性所指向的位置

<ul>
<li>以自己左上角为原点（0，0）</li>
<li>默认<code>（0.5，0.5）</code></li>
<li><code>旋转都是绕着锚点旋转</code>

<ul>
<li>旋转要先考虑锚点，先确定锚点，再确定位置</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>自定义CALayer

<ul>
<li>在自定义view中，在drawRect方法中，最终也会调用：</li>
</ul>


<pre><code class="objc">[self.layer drawInContext:ctx];
</code></pre>

<ul>
<li>1、通过drawInContext:ctx

<ul>
<li>自定义CALayer需要重写以下方法：</li>
</ul>


<pre><code class="objc">// 重写该方法, 在该方法中给layer上绘制图形
// 注意CALayer中的drawInContext方法, 不会自动调用
// 只能自己通过setNeedDisplay方法调用
- (void)drawInContext:(CGContextRef)ctx
{
// 1.绘制图形
CGContextAddEllipseInRect(ctx, CGRectMake(0, 0, 100, 100));
//[[UIColor redColor] set]; // 注意不能用UIKit框架中的类
CGContextSetRGBFillColor(ctx, 1, 0, 0, 1);
// 1.渲染图形
CGContextFillPath(ctx);
}
</code></pre></li>
<li>2、通过代理</li>
</ul>


<pre><code class="objc">// 通过代理自定义layer
- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx
{

  // 1.绘制图形
  CGContextAddEllipseInRect(ctx, CGRectMake(0, 0, 50, 100));

  CGContextSetRGBFillColor(ctx, 1, 0, 0, 1);
  // 1.渲染图形
  CGContextFillPath(ctx);
}
</code></pre>

<ul>
<li>以上两种方法都需要在<code>添加自定义layer</code>时，<code>手动调用setNeedsDisplay</code>，以执行对应的绘制方法。

<ul>
<li>如果自定义了一个layer，并且重写了代理方法，那么他会调用drawInContext:,而不是代理方法；也就是<code>自定义方式比代理优先级高</code></li>
</ul>
</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="cm">/** 方式1 */</span>
</span><span class='line'>  <span class="c1">// 创建自定义Layer</span>
</span><span class='line'>    <span class="n">NJLayer</span> <span class="o">*</span><span class="n">myLayer</span> <span class="o">=</span> <span class="p">[</span><span class="n">NJLayer</span> <span class="n">layer</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">myLayer</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class='line'>    <span class="n">myLayer</span><span class="p">.</span><span class="n">anchorPoint</span> <span class="o">=</span> <span class="n">CGPointZero</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">// 手动调用CALayer中的SETNEEDDISPLAY方法绘制图片</span>
</span><span class='line'>    <span class="p">[</span><span class="n">myLayer</span> <span class="n">setNeedsDisplay</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 将自定义Layer添加到控制器的view的layer上</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer</span><span class="p">:</span><span class="n">myLayer</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/** 方式2 */</span>
</span><span class='line'>    <span class="c1">// 创建自定义Layer</span>
</span><span class='line'>    <span class="bp">CALayer</span> <span class="o">*</span><span class="n">myLayer</span> <span class="o">=</span> <span class="p">[</span><span class="bp">CALayer</span> <span class="n">layer</span><span class="p">];</span>
</span><span class='line'>    <span class="n">myLayer</span><span class="p">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
</span><span class='line'>    <span class="n">myLayer</span><span class="p">.</span><span class="n">anchorPoint</span> <span class="o">=</span> <span class="n">CGPointZero</span><span class="p">;</span>
</span><span class='line'>    <span class="n">myLayer</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="n">greenColor</span><span class="p">].</span><span class="bp">CGColor</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 设置layer代理</span>
</span><span class='line'>    <span class="n">myLayer</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 手动调用CALayer中的SETNEEDDISPLAY方法绘制图片</span>
</span><span class='line'>    <span class="p">[</span><span class="n">myLayer</span> <span class="n">setNeedsDisplay</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 将自定义Layer添加到控制器的view的layer上</span>
</span><span class='line'>    <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer</span><span class="p">:</span><span class="n">myLayer</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013-11-15-chu-bu-ren-shi-nsthreadhe-gcd/">初步认识NSThread、GCD和NSOperation</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2013-11-15T23:12:47+08:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2013</span></span> <span class='time'>11:12 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>NSThread</h2>

<ul>
<li>手动创建线程的三种方式

<ul>
<li>只有方式1可以给线程添加名字</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 创建线程方式1</span>
</span><span class='line'><span class="bp">NSThread</span> <span class="o">*</span><span class="n">thread1</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSThread</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">run</span><span class="p">:)</span> <span class="nl">object</span><span class="p">:</span><span class="mi">@1</span><span class="p">];</span>
</span><span class='line'><span class="n">thread1</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">@&quot;com.tpc.thread&quot;</span><span class="p">;</span>
</span><span class='line'><span class="c1">// 需要手动开始</span>
</span><span class='line'><span class="p">[</span><span class="n">thread1</span> <span class="n">start</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 创建线程方式2</span>
</span><span class='line'><span class="p">[</span><span class="bp">NSThread</span> <span class="nl">detachNewThreadSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">run</span><span class="p">:)</span> <span class="nl">toTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">withObject</span><span class="p">:</span><span class="mi">@2</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 创建线程方式3</span>
</span><span class='line'><span class="p">[</span><span class="nb">self</span> <span class="nl">performSelectorInBackground</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">run</span><span class="p">:)</span> <span class="nl">withObject</span><span class="p">:</span><span class="mi">@3</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>主线程相关方法</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="bp">NSThread</span> <span class="o">*</span><span class="p">)</span><span class="nf">mainThread</span><span class="p">;</span> <span class="c1">// 获得主线程</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isMainThread</span><span class="p">;</span> <span class="c1">// 是否为主线程</span>
</span><span class='line'><span class="p">+</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isMainThread</span><span class="p">;</span> <span class="c1">// 是否为主线程</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>获取当前线程</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>线程状态<br>

<ul>
<li>状态控制方法

<ul>
<li>一旦停止，就不能重新开启</li>
</ul>
</li>
</ul>


<pre><code class="objc">// 启动
- (void)start;

// 阻塞
// 阻塞2.0秒
[NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:2.0]];
[NSThread sleepForTimeInterval:2.0];

// 停止
+ (void)exit;
</code></pre></li>
<li>OC中的互斥锁

<ul>
<li>达到线程同步

<ul>
<li><code>线程同步</code>：多条线程按照顺序执行</li>
</ul>
</li>
<li><code>锁对象一般为self</code></li>
<li>访问一份资源时，锁要统一<code>用一把</code></li>
<li>尽量使用细锁，不要使用粗锁，因为粗锁会让多线程达不到多线程的效果</li>
<li>但是细锁容易消耗过多的CPU资源，所以需要做下权衡，基本上选择细锁</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@synchronized</span><span class="p">(</span><span class="err">锁对象</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>属性的atomic和nonacomic

<ul>
<li>建议所有属性都声明为nonatomic，让服务端处理资源互斥问题</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">atomic</span><span class="err">：原子属性，为</span><span class="k">setter</span><span class="err">方法加锁（默认就是</span><span class="k">atomic</span><span class="err">）</span>
</span><span class='line'><span class="k">nonatomic</span><span class="err">：非原子属性，不会为</span><span class="k">setter</span><span class="err">方法加锁</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>测试程序执行时间</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 方式1</span>
</span><span class='line'>    <span class="n">CFTimeInterval</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">CFAbsoluteTimeGetCurrent</span><span class="p">();</span>
</span><span class='line'>    <span class="c1">// 代码</span>
</span><span class='line'>    <span class="n">CFTimeInterval</span> <span class="n">end</span> <span class="o">=</span> <span class="n">CFAbsoluteTimeGetCurrent</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 方式2</span>
</span><span class='line'>    <span class="bp">NSDate</span> <span class="o">*</span><span class="n">before</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSDate</span> <span class="n">date</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// 代码</span>
</span><span class='line'>    <span class="bp">NSDate</span> <span class="o">*</span><span class="n">after</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSDate</span> <span class="n">date</span><span class="p">];</span>
</span><span class='line'>    <span class="c1">// 获得时间差</span>
</span><span class='line'>    <span class="p">[</span><span class="n">after</span> <span class="nl">timeIntervalSinceDate</span><span class="p">:</span><span class="n">before</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>线程通信方法

<ul>
<li>注意，这两个方法是NSObject的分类方法，所以继承自NSObject得类定义的对象都可以调用</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 返回主线程执行</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">performSelectorOnMainThread:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="nf">withObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">arg</span> <span class="nf">waitUntilDone:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">wait</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 到特定线程执行</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">performSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">aSelector</span> <span class="nf">onThread:</span><span class="p">(</span><span class="bp">NSThread</span> <span class="o">*</span><span class="p">)</span><span class="nv">thr</span> <span class="nf">withObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">arg</span> <span class="nf">waitUntilDone:</span><span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nv">wait</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="c1">// 比如到主线程设置图片</span>
</span><span class='line'><span class="c1">// 直接发消息给self.loadImageTest对象，不用通过给self发消息，然后又得自己实现SEL</span>
</span><span class='line'><span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">loadImageTest</span> <span class="nl">performSelectorOnMainThread</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">setImage</span><span class="p">:)</span> <span class="nl">withObject</span><span class="p">:</span><span class="n">imageData</span> <span class="nl">waitUntilDone</span><span class="p">:</span><span class="nb">NO</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h2>GCD</h2>

<ul>
<li>GCD核心概念

<ul>
<li><code>任务</code></li>
<li><code>队列</code></li>
</ul>
</li>
<li>使用步骤

<ul>
<li>定制任务</li>
<li>添加<code>任务</code>至队列

<ul>
<li>GCD会自动将队列中的任务取出，放到对应的线程中执行</li>
<li>任务取出遵循先进先出原则</li>
</ul>
</li>
</ul>
</li>
<li>同步、异步、并发、串行介绍

<ul>
<li>开启新线程能力

<ul>
<li>同步：只是在当前线程中执行任务，不具备开启新线程的能力</li>
<li>异步：可以在新的线程中执行任务，具备开启新线程的能力</li>
</ul>
</li>
<li>任务执行方式

<ul>
<li>并发：允许多个任务并发（同时）执行</li>
<li>串行：一个任务执行完毕后，再执行下一个任务</li>
</ul>
</li>
</ul>
</li>
<li>执行任务的2个常用函数</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 同步</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">dispatch_sync</span><span class="p">(</span><span class="kt">dispatch_queue_t</span> <span class="n">queue</span><span class="p">,</span> <span class="kt">dispatch_block_t</span> <span class="n">block</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 异步</span>
</span><span class='line'><span class="kt">void</span> <span class="nf">dispatch_async</span><span class="p">(</span><span class="kt">dispatch_queue_t</span> <span class="n">queue</span><span class="p">,</span> <span class="kt">dispatch_block_t</span> <span class="n">block</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>另一个执行任务的函数</p>

<ul>
<li>栅栏函数

<ul>
<li>也就是说以下任务的执行必须按照(&frac12;) -> barrier -> (&frac34;)顺序执行

<ul>
<li>可以应用在一些必须在执行完某些并发事件后才能执行某些特殊处理的场合(比如加载图片后，对图片进行合成，可以起到和组队列相同的效果)</li>
</ul>
</li>
</ul>
</li>
</ul>


<pre><code class="objc">/**
*  栅栏线程，执行完此线程之前的线程，再执行词线程，再执行此线程之后的线程（加入队列的顺序）
*/
  - (void)barrierThread
{
    // 只能使用DISPATCH_QUEUE_CONCURRENT queues，不能用全局并行队列
    dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_CONCURRENT);

    dispatch_async(queue, ^{
         NSLog(@"1----%@", [NSThread currentThread]);
    });
    dispatch_async(queue, ^{
         NSLog(@"2----%@", [NSThread currentThread]);
    });

    dispatch_barrier_async(queue, ^{
         NSLog(@"dispatch_barrier_async----%@", [NSThread currentThread]);
    });

    dispatch_async(queue, ^{
         NSLog(@"3----%@", [NSThread currentThread]);
    });
    dispatch_async(queue, ^{
         NSLog(@"4----%@", [NSThread currentThread]);
    });
}
</code></pre></li>
<li><p>队列的获取</p>

<ul>
<li>并发队列

<ul>
<li>多个任务并发（同时）执行</li>
<li>并发功能只有在异步（dispatch_async）函数下才有效</li>
</ul>
</li>
</ul>


<pre><code class="objc">// 方式1.直接创建
dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_CONCURRENT);

// 方式2.获取全局并发队列
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
</code></pre>

<ul>
<li>串行队列

<ul>
<li>让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）</li>
<li>主队列

<ul>
<li>是GCD自带的一种特殊的<code>串行队列</code></li>
<li>放在主队列中的任务，都会<code>放到主线程中执行</code></li>
</ul>
</li>
</ul>
</li>
</ul>


<pre><code class="objc">// 方式1.直接创建
dispatch_queue_t queue = dispatch_queue_create(NULL, DISPATCH_QUEUE_SERIAL);

// 方式2.使用主队列
dispatch_queue_t queue = dispatch_get_main_queue(void);
</code></pre></li>
<li>各种队列执行效果<br>

<ul>
<li><code>凡是涉及到主队列的，都不会创建新的线程，只在主线程中执行任务</code></li>
<li>同步函数－－一定不会开线程(在<code>同一个队列</code>中开启使用<code>同步函数</code>执行任务，那么这个任务会<code>立刻执行</code>)</li>
<li>异步函数－－可能开线程（除了加入主队列的情况，其他都会开新线程）－－线程多少由是什么队列决定</li>
<li>注意：

<ul>
<li>使用sync函数往<code>当前串行</code>队列中添加任务，会卡住当前的串行队列(注意，是当前，也就是说在<code>当前串行队列的任务中</code>又使用<code>sync</code>函数向<code>同一个队列</code>添加了任务)

<ul>
<li>使用sync函数向主队列中添加任务，也会卡住主队列，因为主队列是串行队列</li>
<li>以下两种情况都会阻塞</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="c1">// 情况1</span>
</span><span class='line'>  <span class="c1">// 主队列为串行队列，主线程和同步函数创建的线程具有一样的属性，</span>
</span><span class='line'>  <span class="c1">// 在主队列中，使用同步函数执行任务，由于是同步类型，且在同一个队列中，所以创建的任务需要立刻执行，而主线程中的任务也需要执行完，所以会出现阻塞</span>
</span><span class='line'>  <span class="c1">// 相当于刚开始是没任务的，然后使用sync向主队列中添加了主线程的任务，又使用sync在同个串行队列中添加了另一个任务，这样，阻塞的情况和情况2其实差不多</span>
</span><span class='line'>    <span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_get_main_queue</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;begin sync&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="bp">NSInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;1---%@--%ld&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">],</span> <span class="n">i</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">});</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;end sync&quot;</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 情况2</span>
</span><span class='line'>  <span class="kt">dispatch_queue_t</span> <span class="n">queue</span> <span class="o">=</span> <span class="n">dispatch_queue_create</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">DISPATCH_QUEUE_SERIAL</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="bp">NSInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;1---%@--%ld&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">],</span> <span class="n">i</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">dispatch_sync</span><span class="p">(</span><span class="n">queue</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="bp">NSInteger</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;2---%@--%ld&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">],</span> <span class="n">i</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>线程间通信</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_async</span><span class="p">(</span>
</span><span class='line'><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>    <span class="c1">// 执行耗时的异步操作...</span>
</span><span class='line'>      <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="c1">// 回到主线程，执行UI刷新操作</span>
</span><span class='line'>        <span class="p">});</span>
</span><span class='line'><span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>延时操作的三种方式</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// 方式1</span>
</span><span class='line'><span class="n">dispatch_after</span><span class="p">(</span><span class="n">dispatch_time</span><span class="p">(</span><span class="n">DISPATCH_TIME_NOW</span><span class="p">,</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">NSEC_PER_SEC</span><span class="p">)),</span> <span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">NSStringFromSelector</span><span class="p">(</span><span class="n">_cmd</span><span class="p">));</span>
</span><span class='line'>        <span class="p">[</span><span class="nb">self</span> <span class="n">communicateBetweenThreads</span><span class="p">];</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 方式2</span>
</span><span class='line'><span class="p">[</span><span class="bp">NSTimer</span> <span class="nl">scheduledTimerWithTimeInterval</span><span class="p">:</span><span class="mf">2.0</span> <span class="nl">target</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">communicateBetweenThreads</span><span class="p">)</span> <span class="nl">userInfo</span><span class="p">:</span><span class="nb">nil</span> <span class="nl">repeats</span><span class="p">:</span><span class="nb">NO</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 方式3</span>
</span><span class='line'><span class="p">[</span><span class="nb">self</span> <span class="nl">performSelector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">communicateBetweenThreads</span><span class="p">)</span> <span class="nl">withObject</span><span class="p">:</span><span class="nb">nil</span> <span class="nl">afterDelay</span><span class="p">:</span><span class="mf">2.0</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>执行一次的代码</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>   <span class="c1">// 整个程序生命周期，就执行一次代码</span>
</span><span class='line'>    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 线程id和调用这个函数的线程的id一样</span>
</span><span class='line'>        <span class="k">static</span> <span class="kt">dispatch_once_t</span> <span class="n">onceToken</span><span class="p">;</span>
</span><span class='line'>        <span class="n">dispatch_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">onceToken</span><span class="p">,</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;once--%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>        <span class="p">});</span>
</span><span class='line'>    <span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>快速遍历

<ul>
<li>遍历的顺序是不确定的，用在不关心顺序，但是需要快速操作的场合，如复制图片，移动图片等</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">dispatch_apply</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%ld&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
</span><span class='line'>    <span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>队列组

<ul>
<li>如果队列组中没有队列和他相关联，那么dispatch_group_notify中的任务会立即执行</li>
<li>一般应用场合

<ul>
<li>1.分别异步执行2个耗时的操作; 2.等2个异步操作都执行完毕后，再回到主线程执行操作</li>
</ul>
</li>
</ul>


<pre><code class="objc">dispatch_group_t group =  dispatch_group_create();
dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
  // 执行1个耗时的异步操作
});
dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
  // 执行1个耗时的异步操作
});
dispatch_group_notify(group, dispatch_get_main_queue(), ^{
  // 等前面的异步操作都执行完毕后，回到主线程...
});
</code></pre>

<ul>
<li>如以下情况

<ul>
<li>在并发下载完图片后，才能进行主线程进行图片的显示，所以需要用到组队列</li>
</ul>
</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>  <span class="kt">dispatch_group_t</span> <span class="n">group</span> <span class="o">=</span> <span class="n">dispatch_group_create</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">__block</span> <span class="bp">UIImage</span> <span class="o">*</span><span class="n">image1</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="k">__block</span> <span class="bp">UIImage</span> <span class="o">*</span><span class="n">image2</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 加载图片1</span>
</span><span class='line'>    <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="bp">NSURL</span> <span class="o">*</span><span class="n">url</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="s">@&quot;http://img.pconline.com.cn/images/photoblog/9/9/8/1/9981681/200910/11/1255259355826.jpg&quot;</span><span class="p">];</span>
</span><span class='line'>        <span class="bp">NSData</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSData</span> <span class="nl">dataWithContentsOfURL</span><span class="p">:</span><span class="n">url</span><span class="p">];</span>
</span><span class='line'>        <span class="n">image1</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageWithData</span><span class="p">:</span><span class="n">data</span><span class="p">];</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 加载图片2</span>
</span><span class='line'>    <span class="n">dispatch_group_async</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="bp">NSURL</span> <span class="o">*</span><span class="n">url</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="s">@&quot;http://img.pconline.com.cn/images/photoblog/9/9/8/1/9981681/200910/11/1255259355826.jpg&quot;</span><span class="p">];</span>
</span><span class='line'>        <span class="bp">NSData</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSData</span> <span class="nl">dataWithContentsOfURL</span><span class="p">:</span><span class="n">url</span><span class="p">];</span>
</span><span class='line'>        <span class="n">image2</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageWithData</span><span class="p">:</span><span class="n">data</span><span class="p">];</span>
</span><span class='line'>    <span class="p">});</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// block会强引用内部的所有强指针，所以image1和image2才不会释放</span>
</span><span class='line'>    <span class="c1">// 上面两个任务执行完成后，就会执行这个任务</span>
</span><span class='line'>    <span class="n">dispatch_group_notify</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">UIGraphicsBeginImageContext</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">loadImageView</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>        <span class="p">[</span><span class="n">image1</span> <span class="nl">drawInRect</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">loadImageView</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">loadImageView</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">)];</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">[</span><span class="n">image2</span> <span class="nl">drawInRect</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">loadImageView</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">loadImageView</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">loadImageView</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">)];</span>
</span><span class='line'>        <span class="bp">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 回到主队列进行显示</span>
</span><span class='line'>        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
</span><span class='line'>            <span class="nb">self</span><span class="p">.</span><span class="n">loadImageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">;</span>
</span><span class='line'>        <span class="p">});</span>
</span><span class='line'>    <span class="p">});</span>
</span></code></pre></td></tr></table></div></figure>


<h1>NSOperation</h1>

<h2>NSOperation+NSOperationQueue实现多线程步骤</h2>

<ul>
<li>1.封装要执行的任务至NSOperation对象</li>
<li>2.将NSOperation对象添加到NSOperationQueue队列中</li>
<li>3.系统自动将NSOperationQueue中的NSOperation取出来</li>
<li>4.将取出的NSOperation封装的任务放到一条新线程中执行</li>
</ul>


<h2>NSOperation类</h2>

<ul>
<li>NSOperation是抽象类，必须使用它的子类

<ul>
<li>1.NSInvocationOperation</li>
<li>2.NSBlockOperation

<ul>
<li>只要此类的实例对象封装的<code>任务数&gt;1</code>，就会<code>异步</code>执行操作</li>
</ul>
</li>
<li>3.自定义子类继承NSOperation，实现内部相应的方法(<code>main</code>)</li>
<li>注意：

<ul>
<li>如果对NSOperation子类对象调用<code>start</code>方法后，并不会开一条新线程去执行操作，而是在<code>当前线程同步执行</code></li>
<li>只有将NSOperation子类对象<code>放到一个NSOperationQueue</code>中，才会<code>异步执行</code>操作</li>
</ul>
</li>
<li>创建实例</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>     <span class="c1">// NSInvocationOperation</span>
</span><span class='line'>      <span class="bp">NSInvocationOperation</span> <span class="o">*</span><span class="n">op1</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSInvocationOperation</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">selector</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="n">run</span><span class="p">)</span> <span class="nl">object</span><span class="p">:</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// NSBlockOperation</span>
</span><span class='line'>      <span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">op3</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>    <span class="c1">// addExecutionBlock添加更多操作</span>
</span><span class='line'>    <span class="p">[</span><span class="n">op3</span> <span class="nl">addExecutionBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 自定义NSOperation</span>
</span><span class='line'>    <span class="n">TPCOperation</span> <span class="o">*</span><span class="n">op4</span> <span class="o">=</span> <span class="p">[[</span><span class="n">TPCOperation</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// TPCOperation.m</span>
</span><span class='line'>    <span class="c1">// 任务主题函数main</span>
</span><span class='line'>    <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">main</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;1--%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>          <span class="p">[</span><span class="bp">NSThread</span> <span class="nl">sleepForTimeInterval</span><span class="p">:</span><span class="mf">0.1</span><span class="p">];</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>自定义NSOperation  (一般使用在任务代码长，使用场所多的情况)

<ul>
<li>重写<code>- (void)main</code>方法，在里面实现想执行的任务</li>
<li>注意：

<ul>
<li>自己创建<code>自动释放池</code>（因为如果是异步操作，无法访问主线程的自动释放池）[@autoreleasepool]</li>
<li>经常<code>通过- (BOOL)isCancelled方法检测</code>操作是否被取消，对取消做出响应</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>NSOperationQueue</h2>

<ul>
<li>将NSOperation添加到NSOperationQueue（操作队列）中，才有可能<code>异步执行</code>NSOperation中的操作</li>
<li>添加NSOperation的方法

<ul>
<li><code>addOperation:</code></li>
<li><code>addOperationWithBlock:</code></li>
</ul>
</li>
<li>最大并发数

<ul>
<li>同时执行的任务数

<ul>
<li>当设置<code>maxConcurrentOperationCount=1</code>时，里面的<code>任务</code>就会<code>串行执行</code>，队列也就变成了<code>串行队列</code></li>
</ul>
</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>     <span class="o">-</span> <span class="p">(</span><span class="bp">NSInteger</span><span class="p">)</span><span class="n">maxConcurrentOperationCount</span><span class="p">;</span>
</span><span class='line'>   <span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">setMaxConcurrentOperationCount</span><span class="p">:(</span><span class="bp">NSInteger</span><span class="p">)</span><span class="n">cnt</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>队列状态操作

<ul>
<li>注意

<ul>
<li><code>主队列</code>无法取消、挂起</li>
<li><code>已经执行</code>的任务<code>无法取消或挂起</code>，<code>队列状态</code>的更改操作只对<code>队列中还没执行</code>的任务有效</li>
<li>这里有一点，苹果建议自定义operation中有耗时操作时，需要<code>在耗时操作中判断isCancel</code>，以便及时响应取消操作

<ul>
<li>如以下例子，在耗时操作的中间，判断一次任务是否被取消</li>
</ul>


<pre><code class="objc">  - (void)main
  {
      for (int i = 0; i &lt; 50; i++) {
          NSLog(@"1--%@", [NSThread currentThread]);
          [NSThread sleepForTimeInterval:0.1];
      }
      // 判断是否被取消
      if (self.isCancelled) return;

      for (int i = 0; i &lt; 50; i++) {
          NSLog(@"2--%@", [NSThread currentThread]);
          [NSThread sleepForTimeInterval:0.1];
      }
  }
</code></pre></li>
</ul>
</li>
<li><p>1.取消</p>

<pre><code class="objc">- (void)cancelAllOperations;
</code></pre>

<ul>
<li>任务的取消

<ul>
<li>使用NSOperation子类对象的<code>cancel</code></li>
</ul>
</li>
</ul>
</li>
<li>2.挂起</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">getter</span><span class="o">=</span><span class="n">isSuspended</span><span class="p">)</span> <span class="kt">BOOL</span> <span class="n">suspended</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>操作依赖（注意任务的取出（按队列类型）－－任务的执行（按线程创建类型）概念）

<ul>
<li>添加方法：<code>addDependency:</code></li>
<li>NSOperation之间可以设置依赖来保证执行顺序</li>
<li>还可以在<code>不同的queue</code>之间的NSOperation设置依赖关系</li>
<li>比如图片下载合成操作

<ul>
<li><code>图片合成依赖于图片下载完成任务</code></li>
</ul>
</li>
</ul>
</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'>       <span class="bp">NSOperationQueue</span> <span class="o">*</span><span class="n">queue</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSOperationQueue</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">__block</span> <span class="bp">UIImage</span> <span class="o">*</span><span class="n">image1</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>      <span class="k">__block</span> <span class="bp">UIImage</span> <span class="o">*</span><span class="n">image2</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>      <span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">op1</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="bp">NSURL</span> <span class="o">*</span><span class="n">url</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="s">@&quot;http://img.pconline.com.cn/images/photoblog/9/9/8/1/9981681/200910/11/1255259355826.jpg&quot;</span><span class="p">];</span>
</span><span class='line'>      <span class="bp">NSData</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSData</span> <span class="nl">dataWithContentsOfURL</span><span class="p">:</span><span class="n">url</span><span class="p">];</span>
</span><span class='line'>      <span class="n">image1</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageWithData</span><span class="p">:</span><span class="n">data</span><span class="p">];</span>
</span><span class='line'>      <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>      <span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">op2</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="bp">NSURL</span> <span class="o">*</span><span class="n">url</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSURL</span> <span class="nl">URLWithString</span><span class="p">:</span><span class="s">@&quot;http://img.pconline.com.cn/images/photoblog/9/9/8/1/9981681/200910/11/1255259355826.jpg&quot;</span><span class="p">];</span>
</span><span class='line'>        <span class="bp">NSData</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSData</span> <span class="nl">dataWithContentsOfURL</span><span class="p">:</span><span class="n">url</span><span class="p">];</span>
</span><span class='line'>        <span class="n">image2</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageWithData</span><span class="p">:</span><span class="n">data</span><span class="p">];</span>
</span><span class='line'>      <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>      <span class="bp">NSBlockOperation</span> <span class="o">*</span><span class="n">op3</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSBlockOperation</span> <span class="nl">blockOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>        <span class="n">UIGraphicsBeginImageContext</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">dependencyImage</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">);</span>
</span><span class='line'>        <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="bp">NSThread</span> <span class="n">currentThread</span><span class="p">]);</span>
</span><span class='line'>        <span class="p">[</span><span class="n">image1</span> <span class="nl">drawInRect</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">dependencyImage</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">dependencyImage</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">)];</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">[</span><span class="n">image2</span> <span class="nl">drawInRect</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="n">dependencyImage</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">dependencyImage</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">self</span><span class="p">.</span><span class="n">dependencyImage</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">)];</span>
</span><span class='line'>        <span class="bp">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="n">UIGraphicsGetImageFromCurrentImageContext</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">UIGraphicsEndImageContext</span><span class="p">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 回到主线程</span>
</span><span class='line'>        <span class="p">[[</span><span class="bp">NSOperationQueue</span> <span class="n">mainQueue</span><span class="p">]</span> <span class="nl">addOperationWithBlock</span><span class="p">:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>            <span class="nb">self</span><span class="p">.</span><span class="n">dependencyImage</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}];</span>
</span><span class='line'>      <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// 添加任务依赖，op3依赖于op1、op2</span>
</span><span class='line'>      <span class="p">[</span><span class="n">op3</span> <span class="nl">addDependency</span><span class="p">:</span><span class="n">op1</span><span class="p">];</span>
</span><span class='line'>      <span class="p">[</span><span class="n">op3</span> <span class="nl">addDependency</span><span class="p">:</span><span class="n">op2</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>      <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperation</span><span class="p">:</span><span class="n">op3</span><span class="p">];</span>
</span><span class='line'>      <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperation</span><span class="p">:</span><span class="n">op2</span><span class="p">];</span>
</span><span class='line'>      <span class="p">[</span><span class="n">queue</span> <span class="nl">addOperation</span><span class="p">:</span><span class="n">op1</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>任务运行完成监听</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="k">copy</span><span class="p">)</span> <span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">completionBlock</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'><span class="p">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setCompletionBlock:</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="kt">void</span><span class="p">))</span><span class="nv">block</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/8">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/6">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>About Me</h1>
  <p> 喜欢技术，热衷底层，涉略微处理器、linux，最终加入移动大家庭 </p>
</section>

<section>
    <h1>文章分类</h1>
    <ul id="categories">
        
    </ul>
</section><section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015-09-02-shi-yong-xiang-ying-zhe-lian-tiao-jie-jue-xu-qiu/">使用响应者链条解决需求</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-06-03-cheng-xu-bu-si/">程序不死</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-05-31-runloopzhi-shi-shu-li/">Runloop知识梳理</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-04-27-uinavigationbarshu-xing-xiao-jie-ji-fan-hui-an-niu-geng-gai/">UINavigationBar属性小结及返回按钮更改</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-04-10-runtimeying-yong-zhi-guan-lian-dui-xiang-he-methodswizzling/">Runtime应用之关联对象和MethodSwizzling</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-03-02-jing-tai-fen-xi-bu-zhun-que-de-qing-kuang/">静态分析不准确的情况</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-02-10-blockji-qiao-yu-di-ceng-jie-xi/">Block技巧与底层解析</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-02-01-sdwebimagejia-zai-da-tu/">SDWebImage加载大图崩溃</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-01-27-uitextfiledwen-zi-dou-dong-xiao-guo/">UITextFiled文字抖动效果</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-01-22-chang-yong-runtimehan-shu/">常用Runtime函数</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-01-21-runtimeying-yong-zhi-kvc/">Runtime应用之KVC</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-01-10-runtimeji-chu/">Runtime基础</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015-01-02-jian-ting-jian-pan-shan-chu-an-niu/">监听键盘删除按钮</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014-12-04-autorezingde-ying-yong/">Preview功能结合Autorezing的应用</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014-11-02-she-zhi-cellzhou-bian-jian-ju/">设置cell周边间距</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014-10-20-uialertcontrollerde-shi-yong/">UIAlertController的使用</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014-10-05-shuang-ji-di-bu-gong-ju-lan-itemdui-ying-uitableviewzhong-xin-shua-xin/">双击底部工具栏Item对应UITableView重新刷新</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014-09-11-zi-ding-yi-uitextview/">自定义UITextView</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014-09-01-zi-ding-yi-ti-shi-hong/">自定义提示宏</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014-08-29-tableviewyou-ce-biao-qian-suo-yin-xu-qiu/">UITableView右侧标签索引需求</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - tripleCC -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
